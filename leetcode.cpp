//Reverse integer 
#include<iostream>
using namespace std;
class Solution {
public:
    int reverse(int x) {
        int rev=0;
        while(x!=0){
            int pop=x%10;
            x/=10;
            if(rev>INT_MAX/10 || (rev==INT_MAX/10 && pop>7)) return 0;
            if(rev<INT_MIN/10 || (rev==INT_MIN/10 && pop<-8)) return 0;
            rev=rev*10+pop;
        }
        return rev;
    }
};
// class Solution {
// public:
//     int reverse(int x) {
//         long long int rev=0;
//         while(x!=0){
//             rev=rev*10+x%10;
//             x=x/10;
//         }
//         if(rev>INT_MAX || rev<INT_MIN){
//             return 0;
//         }
//         return rev;
//     }
// };
int main(){
    Solution s;
    int x;
    cin>>x;
    cout<<s.reverse(x)<<endl;
    return 0;
}

Break a palindrome
# include <iostream>
# include <string>
using namespace std;
class Solution {
public:
    string breakPalindrome(string palindrome) {
        int n=palindrome.length();
        if(n==1) return "";
        for(int i=0;i<n/2;i++){
            if(palindrome[i]!='a'){
                palindrome[i]='a';
                return palindrome;
            }
        }
        palindrome[n-1]='b';
        return palindrome;
    }
};
int main(){
    Solution s;
    string str;
    cin>>str;
    cout<<s.breakPalindrome(str)<<endl;
    return 0;
}

3 sum
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) { // 3 sum
        vector<vector<int>> ans;     // vector of vector
        int n=nums.size();    // size of vector
        sort(nums.begin(),nums.end()); // sort the vector
        for(int i=0;i<n;i++){   //  loop for first element
            if(i>0 && nums[i]==nums[i-1]) continue;     //  if first element is same as previous element then continue
            int j=i+1;  // second element index is i+1 
            int k=n-1;    // third element   index is n-1
            while(j<k){   // loop for second and third element
                int sum=nums[i]+nums[j]+nums[k];   // sum of three elements
                if(sum==0){    // if sum is zero
                    ans.push_back({nums[i],nums[j],nums[k]});  // push the elements in vector
                    j++;  // increment second element
                    k--;  // increment j and decrement k
                    while(j<k && nums[j]==nums[j-1]) j++;  // if second element is same as previous element then increment second element
                    while(j<k && nums[k]==nums[k+1]) k--;  // if third element is same as previous element then decrement third element
                }
                else if(sum>0){  // if sum is greater than zero
                    k--;  // decrement third element
                }
                else{
                    j++;  // increment second element
                }
            }
        }
        return ans;
    }
};
int main(){
    Solution s;
    int n;
    cin>>n;
    vector<int> v;
    for(int i=0;i<n;i++){
        int x;
        cin>>x;
        v.push_back(x);
    }
    vector<vector<int>> ans=s.threeSum(v);
    for(int i=0;i<ans.size();i++){
        for(int j=0;j<ans[i].size();j++){
            cout<<ans[i][j]<<" ";
        }
        cout<<endl;
    }
    return 0;
}


3 sum closest
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {  // 3 sum closest
        int n=nums.size(); // size of vector
        sort(nums.begin(),nums.end());  // sort the vector
        int ans=nums[0]+nums[1]+nums[2];  // initialize ans with sum of first three elements
        for(int i=0;i<n;i++){  // loop for first element
            int j=i+1;   // second element index is i+1
            int k=n-1;   // third element index is n-1
            while(j<k){   // loop for second and third element
                int sum=nums[i]+nums[j]+nums[k];  // sum of three elements
                if(abs(sum-target)<abs(ans-target)){  // if sum is closer to target // abs is used to get absolute value
                    ans=sum;  // update ans
                }  
                if(sum>target){   // if sum is greater than target
                    k--;  // decrement third element
                }
                else{
                    j++;  // increment second element
                }
            }
        }
        return ans;
    }
};
int main(){
    Solution s;
    int n;
    cin>>n;
    vector<int> v;
    for(int i=0;i<n;i++){
        int x;
        cin>>x;
        v.push_back(x);
    }
    int target;
    cin>>target;
    cout<<s.threeSumClosest(v,target)<<endl;
    return 0;
}

check palindrome
#include <iostream>
#include <string>
using namespace std;
class Solution {
public:
    bool isPalindrome(int x) {
        if(x<0) return false;
        int rev=0;
        int temp=x;
        while(temp>0){
            int rem=temp%10;
            rev=rev*10+rem;
            temp=temp/10;
        }
        if(rev==x) return true;
        return false;
    }
        
};
int main(){
    Solution s;
    int x;
    cin>>x;
    cout<<s.isPalindrome(x)<<endl;
    return 0;
}

remove duplicates from sorted array 
#include <iostream>
#include <vector>
using namespace std;
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n=nums.size();
        if(n==0) return 0;
        int j=0;
        for(int i=0;i<n;i++){
            if(nums[i]!=nums[j]){
                j++;
                nums[j]=nums[i];
            }
        }
        return j+1;
    }
};
int main(){
    Solution s;
    int n;
    cin>>n;
    vector<int> v;
    for(int i=0;i<n;i++){
        int x;
        cin>>x;
        v.push_back(x);
    }
    cout<<s.removeDuplicates(v)<<endl;
    return 0;
}

roman to integer easy 
#include <iostream>
#include <string>
using namespace std;
class Solution {
public:  
    int romanToInt(string s) {  // roman to integer
        int n=s.length();   // length of string
        int ans=0;    // initialize ans with zero
        for(int i=0;i<n;i++){    // loop for string
            if(s[i]=='I'){    // if character is I
                if(i+1<n && s[i+1]=='V'){   // if next character is V
                    ans+=4;   // add 4 to ans
                    i++;   // increment i
                }
                else if(i+1<n && s[i+1]== 'X'){  // if next character is X
                    ans+=9;  // add 9 to ans
                    i++;  // increment i
                }   
                else{
                    ans+=1;  // add 1 to ans
                }
            }
            else if(s[i]=='V'){  // if character is V
                ans+=5;   // add 5 to ans
            }
            else if(s[i]=='X'){    // if character is X
                if(i+1<n && s[i+1]=='L'){   // if next character is L
                    ans+=40;   // add 40 to ans
                    i++;   // increment i
                }
                else if(i+1<n && s[i+1]=='C'){   // if next character is C
                    ans+=90;  // add 90 to ans
                    i++;
                }
                else{
                    ans+=10;   // add 10 to ans
                }
            }
            else if(s[i]=='L'){    // if character is L
                ans+=50;   // add 50 to ans
            }
            else if(s[i]=='C'){   // if character is C
                if(i+1<n && s[i+1]=='D'){   // if next character is D
                    ans+=400;   // add 400 to ans
                    i++;
                }
                else if(i+1<n && s[i+1]=='M'){    // if next character is M
                    ans+=900;   // add 900 to ans
                    i++;
                }
                else{
                    ans+=100;     // add 100 to ans
                }
            }
            else if(s[i]=='D'){     // if character is D
                ans+=500;   // add 500 to ans
            }
            else if(s[i]=='M'){     // if character is M
                ans+=1000;      // add 1000 to ans
            }
        }
        return ans;
    }
};
int main(){
    Solution s;
    string s1;
    cin>>s1;
    cout<<s.romanToInt(s1)<<endl;
    return 0;
}






longest common prefix
#include <iostream>
#include <vector>
#include <string>
using namespace std;
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {  // longest common prefix
        int n=strs.size();  // size of vector
        if(n==0) return ""; // if size is zero return empty string
        string ans=strs[0]; // initialize ans with first string
        for(int i=1;i<n;i++){   // loop for vector
            string temp=""; // initialize temp with empty string
            int j=0;    // initialize j with zero
            while(j<ans.length() && j<strs[i].length()){    // loop for ans and string
                if(ans[j]==strs[i][j]){    // if character is equal
                    temp+=ans[j];   // add character to temp
                }
                else{   
                    break;  // break the loop
                }
                j++;    // increment j
            }
            ans=temp;   // update ans with temp
        }
        return ans;
    }
};
int main(){
    Solution s;
    int n;
    cin>>n;
    vector<string> v;
    for(int i=0;i<n;i++){
        string s1;
        cin>>s1;
        v.push_back(s1);
    }
    cout<<s.longestCommonPrefix(v)<<endl;
    return 0;
}


Increasing triplet subsequence
#include <iostream>
#include <vector>
using namespace std;
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {  // increasing triplet subsequence
        int n=nums.size();  // size of vector
        if(n<3) return false;   // if size is less than 3 return false
        int first=INT_MAX;  // initialize first with maximum integer
        int second=INT_MAX; // initialize second with maximum integer
        for(int i=0;i<n;i++){   // loop for vector
            if(nums[i]<=first){ // if number is less than or equal to first
                first=nums[i];  // update first with number
            }
            else if(nums[i]<=second){   // if number is less than or equal to second
                second=nums[i]; // update second with number
            }
            else{
                return true;    // return true
            }
        }
        return false;   // return false
    }
};
int main(){
    Solution s;
    int n;
    cin>>n;
    vector<int> v;
    for(int i=0;i<n;i++){
        int x;
        cin>>x;
        v.push_back(x);
    }
    cout<<s.increasingTriplet(v)<<endl;
    return 0;
}


Add two numbers
#include <iostream>
#include <vector>
using namespace std;
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {  // add two numbers
        ListNode* head=new ListNode(0); // initialize head with zero
        ListNode* temp=head;    // initialize temp with head
        int carry=0;    // initialize carry with zero
        while(l1!=NULL || l2!=NULL){    // loop for l1 and l2
            int sum=0;  // initialize sum with zero
            if(l1!=NULL){   // if l1 is not nullLn
                sum+=l1->val;   // add l1 value to sum
                l1=l1->next;    // update l1
            }
            if(l2!=NULL){   // if l2 is not nulln
                sum+=l2->val;   // add l2 value to sum
                l2=l2->next;    // update l2
            }
            sum+=carry; // add carry to sum
            carry=sum/10;   // update carry
            ListNode* node=new ListNode(sum%10);  // create new node with sum%10
            temp->next=node;    // update temp next with node
            temp=temp->next;    // update temp
        }
        if(carry>0){    // if carry is greater than zero
            ListNode* node=new ListNode(carry); // create new node with carry
            temp->next=node;    // update temp next with node
        }
        return head->next;  // return head next
    }
};

int main(){
    Solution s;
    int n;
    cin>>n;
    ListNode* head1=new ListNode(0);
    ListNode* temp1=head1;
    for(int i=0;i<n;i++){
        int x;
        cin>>x;
        ListNode* node=new ListNode(x);
        temp1->next=node;
        temp1=temp1->next;
    }
    int m;
    cin>>m;
    ListNode* head2=new ListNode(0);
    ListNode* temp2=head2;
    for(int i=0;i<m;i++){
        int x;
        cin>>x;
        ListNode* node=new ListNode(x);
        temp2->next=node;
        temp2=temp2->next;
    }
    ListNode* ans=s.addTwoNumbers(head1->next,head2->next);
    while(ans!=NULL){
        cout<<ans->val<<" ";
        ans=ans->next;
    }
    cout<<endl;
    return 0;
}

Largeest perimeter triangle
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
class Solution {
    public:
    int largestPerimeter(vector<int>& nums) {  // largest perimeter triangle
        int n=nums.size();  // size of vector
        sort(nums.begin(),nums.end());  // sort the vector
        for(int i=n-1;i>=2;i--){    // loop for vector
            if(nums[i]<nums[i-1]+nums[i-2]){    // if condition is true
                return nums[i]+nums[i-1]+nums[i-2]; // return sum
            }
        }
        return 0;   // return zero
    }
};
int main(){
    Solution s;
    int n;
    cin>>n;
    vector<int> v;
    for(int i=0;i<n;i++){
        int x;
        cin>>x;
        v.push_back(x);
    }
    cout<<s.largestPerimeter(v)<<endl;
    return 0;
}
      
 
//My calendar III 
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
using namespace std;
class MyCalendarThree {
public:
    map<int,int> m; // map
    MyCalendarThree() { // constructor
    }
    int book(int start, int end) {   // book function
        m[start]++; // increment start
        m[end]--;   // decrement end
        int ans=0;  // initialize ans with zero
        int count=0;    // initialize count with zero
        for(auto it:m){ // loop for map
            count+=it.second;  // update count
            ans=max(ans,count); // update ans
        }
        return ans; // return ans
    }
};
int main(){
    MyCalendarThree s;
    int n;
    cin>>n;
    for(int i=0;i<n;i++){
        int x,y;
        cin>>x>>y;
        cout<<s.book(x,y)<<endl;
    }
    return 0;
}





// delete node in a linked list
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
class Solution {
public:
    void deleteNode(ListNode* node) { // delete node in a linked list
        node->val=node->next->val;  // update node
        node->next=node->next->next;    // update node
    }
};


// delete the middle node of a linked list in C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
      ListNode* deleteMiddle(ListNode* head) {
      
        ListNode* slow=head;    // initialize slow with head
        ListNode* fast=head;    // initialize fast with head
        ListNode *prev=NULL;    // initialize prev with NULL

    
        while(fast!=NULL && fast->next!=NULL){ // loop for fast and fast->next
            prev=slow;  // update prev
            slow=slow->next;    // update slow
            fast=fast->next->next;  // update fast
            
        }
        if(prev==NULL || prev->next==NULL) return prev; // if prev is null or prev.next is null 
        prev->next=slow->next;  // update prev
        return head;    // return head
        
    }
};


//Median of two sorted arrays
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) { // median of two sorted arrays
       // n = even , m = odd
         
        int n=nums1.size(); // size of nums1
        int m=nums2.size(); // size of nums2
        if(n>m){    // if n is greater than m
            return findMedianSortedArrays(nums2,nums1); // return findMedianSortedArrays
        }
        int low=0;  // initialize low with zero
        int high=n; // initialize high with n
        while(low<=high){   // loop for low and high
            int cut1=(low+high)/2;  // cut1  
            int cut2=(n+m+1)/2-cut1;    // cut2
            int l1=cut1==0?INT_MIN:nums1[cut1-1]; //  l1 
            int l2=cut2==0?INT_MIN:nums2[cut2-1]; // l21  
            int r1=cut1==n?INT_MAX:nums1[cut1];    // r1
            int r2=cut2==m?INT_MAX:nums2[cut2];    // r2
            if(l1<=r2 && l2<=r1){   // if condition is true
                if((n+m)%2==0){ // if condition is truec=c
                    return (max(l1,l2)+min(r1,r2))/2.0;  // return median
                }
                else{   // else
                    return max(l1,l2);  // return median
                }
            }
            else if(l1>r2){ // else if condition is true
                high=cut1-1;    // update high
             }
            else{   // else
                low=cut1+1; // update low
            }
        }
        return 0.0; // return zero
    }
};
int main(){
    Solution s;
    int n,m;
    cin>>n>>m;
    vector<int> v1,v2;
    for(int i=0;i<n;i++){
        int x;
        cin>>x;
        v1.push_back(x);
    }
    for(int i=0;i<m;i++){
        int x;
        cin>>x;
        v2.push_back(x);
    }
    cout<<s.findMedianSortedArrays(v1,v2)<<endl;
    return 0;
}



//Median of two sorted arrays
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
class Solution {
    public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        vector<int> v;  // vector
        int i=0,j=0;    // initialize i and j with zero
        while(i<nums1.size() && j<nums2.size()){    // loop for i and j
            if(nums1[i]<nums2[j]){  // if condition is true
                v.push_back(nums1[i]);  // push nums1[i] in vector  
                i++;
            }
            else{
                v.push_back(nums2[j]);      // push nums2[j] in vector
                j++;
            }
        }
        while(i<nums1.size()){  // loop for i
            v.push_back(nums1[i]);  // push nums1[i] in vector
            i++;
        }
        while(j<nums2.size()){  // loop for j
            v.push_back(nums2[j]);  // push nums2[j] in vector
            j++;
        }
        int n=v.size(); // size of vector
        if(n%2==0){ // if condition is true
            return (v[n/2]+v[n/2-1])/2.0;   // return median
        }   
        else{
            return v[n/2];      // return median
        }
    }
};
int main(){
    Solution s;
    int n,m;
    cin>>n>>m;
    vector<int> v1,v2;
    for(int i=0;i<n;i++){
        int x;
        cin>>x;
        v1.push_back(x);
    }
    for(int i=0;i<m;i++){
        int x;
        cin>>x;
        v2.push_back(x);
    }
    cout<<s.findMedianSortedArrays(v1,v2)<<endl;
    return 0;
}





//Median of two sorted arrays
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
class Solution {
    public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) { // median of two sorted arrays
        vector<int> v;      // vector           
        for (int i = 0; i < nums1.size(); i++)         // loop for nums1

        {
            v.push_back(nums1[i]);      // push nums1[i] in vector
        }
        for (int i = 0; i < nums2.size(); i++)          // Loop for nums2
        {
            v.push_back(nums2[i]);    // push nums2[i] in vector
        }
        sort(v.begin(),v.end());    // sort vector
        int n=v.size(); // size of vector
        if(n%2==0){ 
            return (v[n/2]+v[n/2-1])/2.0;       // return median
        }
        else{
            return v[n/2];      // return median
        }
    }
};
int main(){
    Solution s;
    int n,m;
    cin>>n>>m;
    vector<int> v1,v2;
    for(int i=0;i<n;i++){
        int x;
        cin>>x;
        v1.push_back(x);
    }
    for(int i=0;i<m;i++){
        int x;
        cin>>x;
        v2.push_back(x);
    }
    cout<<s.findMedianSortedArrays(v1,v2)<<endl;
    return 0;
}





//Median of two sorted arrays
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
class Solution {
    public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) { // median of two sorted arrays
        vector<int> v;          // vector
        for(auto x:nums1){          // loop for nums1
            v.push_back(x);         // push x in vector
        }
        for(auto x:nums2){
            v.push_back(x);         // push x in vector
        }
        sort(v.begin(),v.end());            // sort vector
        int n=v.size();         // size of vector
        if(n%2==0){                     // if condition is true
            return (v[n/2]+v[n/2-1])/2.0;       // return median
        }
        else{
            return v[n/2];      // return median
        }
    }   
};
int main(){
    Solution s;
    int n,m;
    cin>>n>>m;
    vector<int> v1,v2;
    for(int i=0;i<n;i++){
        int x;
        cin>>x;
        v1.push_back(x);
    }
    for(int i=0;i<m;i++){
        int x;
        cin>>x;
        v2.push_back(x);
    }
    cout<<s.findMedianSortedArrays(v1,v2)<<endl;
    return 0;
}





//Median of two sorted arrays
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
class Solution {
    public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) { // median of two sorted arrays
        vector<int> v;    // vector
        for(auto num:nums1){        // loop for nums1
            v.push_back(num);       // push num in vector
        }

        for(auto num:nums2){        // loop for nums2
            v.push_back(num);       // push num in vector
        }   
        sort(v.begin(),v.end());    // sort vector

        int n=v.size();     // size of vector

        return n%2==0?(v[n/2]+v[n/2-1])/2.0:v[n/2];    // return median
    }
};
int main(){
    Solution s;
    int n,m;
    cin>>n>>m;
    vector<int> v1,v2;
    for(int i=0;i<n;i++){
        int x;
        cin>>x;
        v1.push_back(x);
    }
    for(int i=0;i<m;i++){
        int x;
        cin>>x;
        v2.push_back(x);
    }
    cout<<s.findMedianSortedArrays(v1,v2)<<endl;
    return 0;
}






Longest Substring Without Repeating Characters using map
 #include <iostream>
#include <vector>
#include <algorithm>
#include <unordered_map>
using namespace std;
class Solution {
    public:
    int lengthOfLongestSubstring(string s) { // length of longest substring
        int n=s.size();     // size of string
        int ans=0;      // initialize ans=0
        unordered_map<char,int> m;      // unordered map
        for(int i=0,j=0;j<n;j++){       // loop for j
            if(m.find(s[j])!=m.end()){      // if condition is true
                i=max(m[s[j]],i);       // i=max(m[s[j]],i)
            }
            ans=max(ans,j-i+1);     // ans=max(ans,j-i+1)
            m[s[j]]=j+1;        // m[s[j]]=j+1
        }
        return ans;     // return ans
    }
};
int main(){
    Solution s;
    string str;
    cin>>str;
    cout<<s.lengthOfLongestSubstring(str)<<endl;
    return 0;
}



Longest Substring Without Repeating Characters using vector
 #include <iostream>
#include <vector>
#include <algorithm>
class Solution {
    public:
    int lengthOfLongestSubstring(string s) { // length of longest substring
        int n=s.size();     // size of string
        int ans=0;      // initialize ans=0
        vector<int> v(256,-1);      // vector
        for(int i=0,j=0;j<n;j++){       // loop for j
            i=max(v[s[j]],i);       // i=max(v[s[j]],i)  fs
            ans=max(ans,j-i+1);     // ans=max(ans,j-i+1)
            v[s[j]]=j+1;        // v[s[j]]=j+1
        }
        return ans;     // return ans
    }
};
int main(){
    Solution s;
    string str;
    cin>>str;
    cout<<s.lengthOfLongestSubstring(str)<<endl;
    return 0;
}


Longest Substring Without Repeating Characters using vector in java
class Solution {
    public int lengthOfLongestSubstring(String s) { // length of longest substring
        int n=s.length();       // length of string  
        int ans=0;      // initialize ans=0
        int[] v=new int[256];       // array
        for(int i=0,j=0;j<n;j++){       // loop for j
            i=Math.max(v[s.charAt(j)],i);       // i=Math.max(v[s.charAt(j)],i)
            ans=Math.max(ans,j-i+1);        // ans=Math.max(ans,j-i+1)
            v[s.charAt(j)]=j+1;     // v[s.charAt(j)]=j+1
        }
        return ans;     // return ans
    }
}

Longest Substring Without Repeating Characters using map in java
class Solution {
    public int lengthOfLongestSubstring(String s) { // length of longest substring
        int n=s.length();       // length of string
        int ans=0;      // initialize ans=0
        Map<Character,Integer> m=new HashMap<>();       // map
        for(int i=0,j=0;j<n;j++){       // loop for j
            if(m.containsKey(s.charAt(j))){     // if condition is true
                i=Math.max(m.get(s.charAt(j)),i);       // i=Math.max(m.get(s.charAt(j)),i)
            }
            ans=Math.max(ans,j-i+1);        // ans=Math.max(ans,j-i+1)
            m.put(s.charAt(j),j+1);     // m.put(s.charAt(j),j+1)
        }
        return ans;     // return ans
    }
}








Decode Ways  in c++

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
class Solution {
    public:
    int numDecodings(string s) { // decode ways
        int n=s.size();     // size of string
        vector<int> dp(n+1,0);      // vector
        dp[0]=1;        // dp[0]=1
        dp[1]=s[0]=='0'?0:1;        // dp[1]=s[0]=='0'?0:1
        for(int i=2;i<=n;i++){      // loop for i
            int first=s[i-1]-'0';       // first=s[i-1]-'0'
            int second=(s[i-2]-'0')*10+(s[i-1]-'0');     // second=(s[i-2]-'0')*10+(s[i-1]-'0')
            if(first>=1 && first<=9){       // if condition is true
                dp[i]+=dp[i-1];     // dp[i]+=dp[i-1]
            }
            if(second>=10 && second<=26){       // if condition is true
                dp[i]+=dp[i-2];     // dp[i]+=dp[i-2]
            }
        }
        return dp[n];       // return dp[n]
    }
};
int main(){
    Solution s;
    string str;
    cin>>str;
    cout<<s.numDecodings(str)<<endl;
    return 0;
}


Decode ways using map
#include <iostream>
#include <vector>
#include <algorithm>
#include <unordered_map>
using namespace std;
class Solution {
    public:
    int numDecodings(string s) { // decode ways
        int n=s.size();     // size of string
        unordered_map<int,int> m;       // unordered map
        m[0]=1;     // m[0]=1
        m[1]=s[0]=='0'?0:1;     // m[1]=s[0]=='0'?0:1
        for(int i=2;i<=n;i++){      // loop for i
            int first=s[i-1]-'0';       // first=s[i-1]-'0'
            int second=(s[i-2]-'0')*10+(s[i-1]-'0');     // second=(s[i-2]-'0')*10+(s[i-1]-'0')
            if(first>=1 && first<=9){       // if condition is true
                m[i]+=m[i-1];       // m[i]+=m[i-1]
            }
            if(second>=10 && second<=26){       // if condition is true
                m[i]+=m[i-2];       // m[i]+=m[i-2]
            }
        }
        return m[n];        // return m[n]
    }
};

Decode ways  another method
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
class Solution {
    public:
    int numDecodings(string s) { // decode ways
        return numDecodings(s,0);       // return nmDecodings(s,0)

    }
    int numDecodings(string s,int i){       // numDecodings(s,i)
        int n=s.size();     // size of string
        if(i==n){       // if condition is true
            return 1;       // return 1
        }
        if(s[i]=='0'){      // if condition is true
            return 0;       // return 0
        }
        int ans=numDecodings(s,i+1);        // ans=numDecodings(s,i+1)
        if(i<n-1 && (s[i]=='1' || (s[i]=='2' && s[i+1]<'7'))){     // if condition is true
            ans+=numDecodings(s,i+2);       // ans+=numDecodings(s,i+2)
        }
        return ans;     // return ans
    }
};


Decode ways in Java

class Solution {
    public int numDecodings(String s) { // decode ways
        return numDecodings(s,0);       // return numDecodings(s,0)
    }
    public int numDecodings(String s,int i){       // numDecodings(s,i)
        int n=s.length();       // length of string
        if(i==n){       // if condition is true
            return 1;       // return 1
        }
        if(s.charAt(i)=='0'){       // if condition is true
            return 0;       // return 0
        }
        int ans=numDecodings(s,i+1);        // ans=numDecodings(s,i+1)
        if(i<n-1 && (s.charAt(i)=='1' || (s.charAt(i)=='2' && s.charAt(i+1)<'7'))){     // if condition is true
            ans+=numDecodings(s,i+2);       // ans+=numDecodings(s,i+2)
        }
        return ans;     // return ans
    }
}

Decode ways using map in Java

class Solution {
    public int numDecodings(String s) { // decode ways
        int n=s.length();       // length of string
        Map<Integer,Integer> m=new HashMap<>();     // map
        m.put(0,1);     // m.put(0,1)
        m.put(1,s.charAt(0)=='0'?0:1);      // m.put(1,s.charAt(0)=='0'?0:1)
        for(int i=2;i<=n;i++){      // loop for i
            int first=s.charAt(i-1)-'0';        // first=s.charAt(i-1)-'0'
            int second=(s.charAt(i-2)-'0')*10+(s.charAt(i-1)-'0');      // second=(s.charAt(i-2)-'0')*10+(s.charAt(i-1)-'0')
            if(first>=1 && first<=9){       // if condition is true
                m.put(i,m.get(i-1));        // m.put(i,m.get(i-1))
            }
            if(second>=10 && second<=26){       // if condition is true
                m.put(i,m.get(i)+m.get(i-2));       // m.put(i,m.get(i)+m.get(i-2))
            }
        }
        return m.get(n);        // return m.get(n)
    }
}

Decode ways using dp in Java

class Solution {
    public int numDecodings(String s) { // decode ways
        int n=s.length();       // length of string
        int[] dp=new int[n+1];      // dp array
        dp[0]=1;        // dp[0]=1
        dp[1]=s.charAt(0)=='0'?0:1;     // dp[1]=s.charAt(0)=='0'?0:1
        for(int i=2;i<=n;i++){      // loop for i
            int first=s.charAt(i-1)-'0';        // first=s.charAt(i-1)-'0'
            int second=(s.charAt(i-2)-'0')*10+(s.charAt(i-1)-'0');      // second=(s.charAt(i-2)-'0')*10+(s.charAt(i-1)-'0')
            if(first>=1 && first<=9){       // if condition is true
                dp[i]+=dp[i-1];     // dp[i]+=dp[i-1]
            }
            if(second>=10 && second<=26){       // if condition is true
                dp[i]+=dp[i-2];     // dp[i]+=dp[i-2]
            }
        }
        return dp[n];       // return dp[n]
    }
}






String comparison III using map 
Input 
aaabcccd
2
Output: 2 
Explanation: Delete both 'b' characters.
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
using namespace std;
class Solution {
public:
    int getLengthOfOptimalCompression(string s, int k) {
        int n=s.size();     // size of string
        map<char,int> m;        // map
        for(int i=0;i<n;i++){       // loop for i
            m[s[i]]++;      // m[s[i]]++
        }
        int ans=0;      // initialize ans=0
        for(auto it:m){     // loop for it
            if(it.second>k){        // if condition is true
                ans+=it.second-k;       // ans+=it.second-k
            }
        }
        return ans;     // return ans
    }
};
int main(){
    Solution s;
    string str;
    int k;
    cin>>str>>k;
    cout<<s.getLengthOfOptimalCompression(str,k)<<endl;
    return 0;
}



String Comparison III using dp
Input   
"aaabcccd"
2
Output: 4
Explanation: Delete both 'b' characters.
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
class Solution {
public:
    int dp[101][101];      // dp array
    int dfs(string &s, int left, int K) {   // dfs function
        int k = K;    // k=K
        if(s.size() - left <= k) return 0;    // if condition is true
        if(dp[left][k] >= 0) return dp[left][k];    // if condition is true
        int res = k ? dfs(s, left + 1, k - 1) : 10000, c = 1;   // initialize res
        for(int i = left + 1; i <= s.size(); ++i) {   // loop for i                             
            res = min(res, dfs(s, i, k) + 1 + (c >= 100 ? 3 : (c >= 10 ? 2 : (c > 1 ? 1 :0))));  // res=min(res,dfs(s,i,k)+1+(c>=100?3:(c>=10?2:(c>1?1:0))))
            if(i == s.size()) break;    // if condition is true
            if(s[i] == s[left]) ++c;    // if condition is true
            else if(--k < 0) break;    // else if condition is true
            
        }
        return dp[left][K] = res;   // return dp[left][K]=res
    }
    
    int getLengthOfOptimalCompression(string s, int k) {    // get length of optimal compression
        memset(dp, -1, sizeof(dp));   // memset
        return dfs(s, 0, k);    // return dfs(s,0,k)
    }
};
int main(){
    Solution s;
    string str;
    int k;
    cin>>str>>k;
    cout<<s.getLengthOfOptimalCompression(str,k)<<endl;
    return 0;
}




class Solution {
    const static int N = 127;  // constant variable

    // dp[left][k] means the minimal coding size for substring 
    // s[left:] and removing at most k chars
    int dp[N][N];   // dp array

    string str;   // string
    int n;

    // get length of digit
    inline int xs(int x) { return x == 1 ? 0 : x < 10 ? 1 : x < 100 ? 2 : 3; }   // inline function

    int solve(int left, int k) {   // solve function
        if(k < 0) return N;  // invalid, return INF    
        if(left >= n or n - left <= k) return 0;  // empty  // if condition is true

        int& res = dp[left][k];    // initialize res
        if(res != -1) return res;   // if condition is true
        res = N;  // initialize res

        int cnt[26] = {0};    // initialize cnt array
        // we try to make s[left:j] (both inculded) as one group,
        // and all chars in this group should be the same.
        // so we must keep the most chars in this range and remove others
        // the range length is (j - left + 1)
        // and the number of chars we need to remove is (j - left + 1 - most)
        for(int j = left, most = 0; j < n; j++) {
            most = max(most, ++cnt[str[j] - 'a']);  // most = max(count(s[left:j])   // if condition is true
            res = min(res, 1 + xs(most) + solve(j + 1, k - (j - left + 1 - most)));   // res = min(res, 1 + xs(most) + solve(j + 1, k - (j - left + 1 - most)))
        } 
        return res;
    }
public:
    int getLengthOfOptimalCompression(string s, int k) {
        memset(dp, -1, sizeof(dp));     // memset
        str = s;  // str=s
        n = s.size();
        return solve(0, k);
    }
};


 String Compression II 
Input: s = "aaabcccd", k = 2
Output: 2
Explanation: Delete both 'b' characters.
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
class Solution {
public:
    int getLengthOfOptimalCompression(string s, int k) {
        int n=s.size();     // size of string
        vector<vector<int>> dp(n+1,vector<int>(k+1,INT_MAX));     // dp array
        dp[0][0]=0;     // initialize dp[0][0]=0
        for(int i=1;i<=n;i++){      // loop for i
            for(int j=0;j<=k;j++){      // loop for j
                dp[i][j]=dp[i-1][j]+1;      // dp[i][j]=dp[i-1][j]+1
                for(int l=0;l<i;l++){       // loop for l
                    int cnt=0;      // initialize cnt=0
                    for(int m=l;m<i;m++){       // loop for m
                        if(s[m]!=s[l]) cnt++;       // if condition is true
                    }
                    if(cnt<=j) dp[i][j]=min(dp[i][j],dp[l][j-cnt]+(i-l-(i-l-cnt>1?i-l-cnt:0)));     // dp[i][j]=min(dp[i][j],dp[l][j-cnt]+(i-l-(i-l-cnt>1?i-l-cnt:0)))
                }
            }
        }
        return dp[n][k];        // return dp[n][k]
    }
};
int main(){
    Solution s;
    string str;
    int k;
    cin>>str>>k;
    cout<<s.getLengthOfOptimalCompression(str,k)<<endl;
    return 0;
}


 String Compression II  using map

#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
using namespace std;
class Solution {
public:
    int getLengthOfOptimalCompression(string s, int k) {
        int n=s.size();     // size of string
        vector<vector<int>> dp(n+1,vector<int>(k+1,INT_MAX));     // dp array
        dp[0][0]=0;     // initialize dp[0][0]=0
        for(int i=1;i<=n;i++){      // loop for i
            for(int j=0;j<=k;j++){      // loop for j
                dp[i][j]=dp[i-1][j]+1;      // dp[i][j]=dp[i-1][j]+1
                map<char,int> mp;       // map
                for(int l=i-1;l>=0;l--){        // loop for l
                    mp[s[l]]++;     // mp[s[l]]++
                    int cnt=0;      // initialize cnt=0
                    for(auto it:mp){        // loop for it
                        if(it.second>1) cnt+=it.second-1;       // if condition is true
                    }
                    if(cnt<=j) dp[i][j]=min(dp[i][j],dp[l][j-cnt]+(i-l-(i-l-cnt>1?i-l-cnt:0)));     // dp[i][j]=min(dp[i][j],dp[l][j-cnt]+(i-l-(i-l-cnt>1?i-l-cnt:0)))
                }
            }
        }
        return dp[n][k];        // return dp[n][k]
    }
};
int main(){
    Solution s;
    string str;
    int k;
    cin>>str>>k;
    cout<<s.getLengthOfOptimalCompression(str,k)<<endl;
    return 0;
}

 String Compression II  using map and vector

#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
using namespace std;
class Solution {
public:
    int getLengthOfOptimalCompression(string s, int k) {
        int n=s.size();     // size of string
        vector<vector<int>> dp(n+1,vector<int>(k+1,INT_MAX));     // dp array
        dp[0][0]=0;     // initialize dp[0][0]=0
        for(int i=1;i<=n;i++){      // loop for i
            for(int j=0;j<=k;j++){      // loop for j
                dp[i][j]=dp[i-1][j]+1;      // dp[i][j]=dp[i-1][j]+1
                vector<int> mp(26,0);       // vector
                for(int l=i-1;l>=0;l--){        // loop for l
                    mp[s[l]-'a']++;     // mp[s[l]-'a']++
                    int cnt=0;      // initialize cnt=0
                    for(auto it:mp){        // loop for it
                        if(it>1) cnt+=it-1;       // if condition is true
                    }
                    if(cnt<=j) dp[i][j]=min(dp[i][j],dp[l][j-cnt]+(i-l-(i-l-cnt>1?i-l-cnt:0)));     // dp[i][j]=min(dp[i][j],dp[l][j-cnt]+(i-l-(i-l-cnt>1?i-l-cnt:0)))
                }
            }
        }
        return dp[n][k];        // return dp[n][k]
    }
};
int main(){
    Solution s;
    string str;
    int k;
    cin>>str>>k;
    cout<<s.getLengthOfOptimalCompression(str,k)<<endl;
    return 0;
}



Minimum genetic mutation

A gene string can be represented by an 8-character long string, with choices from "A", "C", "G", "T".

#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;
class Solution {
public:
    int minMutation(string start, string end, vector<string>& bank) {
        int n=bank.size();      // size of bank
        vector<int> vis(n,0);       // vector
        queue<string> q;        // queue
        q.push(start);      // push start
        int ans=0;      // initialize ans=0
        while(!q.empty()){      // loop for q
            int sz=q.size();        // size of q
            while(sz--){        // loop for sz
                string s=q.front();     // string s=q.front()
                q.pop();        // pop
                if(s==end) return ans;      // if condition is true
                for(int i=0;i<n;i++){       // loop for i
                    if(vis[i]) continue;        // if condition is true
                    int cnt=0;      // initialize cnt=0
                    for(int j=0;j<8;j++){       // loop for j
                        if(s[j]!=bank[i][j]) cnt++;     // if condition is true
                    }
                    if(cnt==1){     // if condition is true
                        vis[i]=1;       // vis[i]=1
                        q.push(bank[i]);        // push bank[i]
                    }
                }
            }
            ans++;      // ans++
        }
        return -1;      // return -1
    }
};
int main(){
    Solution s;
    string start,end;
    vector<string> bank;
    int n;
    cin>>start>>end>>n;
    for(int i=0;i<n;i++){       // loop for i
        string str;
        cin>>str;
        bank.push_back(str);        // push str
    }
    cout<<s.minMutation(start,end,bank)<<endl;
    return 0;
}

// Minimum genetic mutation using map

#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
#include <map>
using namespace std;
class Solution {
public:
    int minMutation(string start, string end, vector<string>& bank) {
        int n=bank.size();      // size of bank
        map<string,int> mp;     // map
        for(int i=0;i<n;i++) mp[bank[i]]=1;      // mp[bank[i]]=1
        queue<string> q;        // queue
        q.push(start);      // push start
        int ans=0;      // initialize ans=0
        while(!q.empty()){      // loop for q
            int sz=q.size();        // size of q
            while(sz--){        // loop for sz
                string s=q.front();     // string s=q.front()
                q.pop();        // pop
                if(s==end) return ans;      // if condition is true
                for(int i=0;i<8;i++){       // loop for i
                    char ch=s[i];       // char ch=s[i]
                    for(int j=0;j<4;j++){       // loop for j
                        s[i]='A'+j;     // s[i]='A'+j
                        if(mp[s]){      // if condition is true
                            mp[s]=0;        // mp[s]=0
                            q.push(s);      // push s
                        }
                    }
                    s[i]=ch;        // s[i]=ch
                }
            }
            ans++;      // ans++
        }
        return -1;      // return -1
    }
};
int main(){
    Solution s;
    string start,end;
    vector<string> bank;
    int n;
    cin>>start>>end>>n;
    for(int i=0;i<n;i++){       // loop for i
        string str;
        cin>>str;
        bank.push_back(str);        // push str
    }
    cout<<s.minMutation(start,end,bank)<<endl;
    return 0;
}

Minimum genetic mutation using set

#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
#include <set>
using namespace std;
class Solution {
public:
    int minMutation(string start, string end, vector<string>& bank) {
        int n=bank.size();      // size of bank
        set<string> st;     // set
        for(int i=0;i<n;i++) st.insert(bank[i]);      // st.insert(bank[i])
        queue<string> q;        // queue
        q.push(start);      // push start
        int ans=0;      // initialize ans=0
        while(!q.empty()){      // loop for q
            int sz=q.size();        // size of q
            while(sz--){        // loop for sz
                string s=q.front();     // string s=q.front()
                q.pop();        // pop
                if(s==end) return ans;      // if condition is true
                for(int i=0;i<8;i++){       // loop for i
                    char ch=s[i];       // char ch=s[i]
                    for(int j=0;j<4;j++){       // loop for j
                        s[i]='A'+j;     // s[i]='A'+j
                        if(st.find(s)!=st.end()){      // if condition is true
                            st.erase(s);        // st.erase(s)
                            q.push(s);      // push s
                        }
                    }
                    s[i]=ch;        // s[i]=ch
                }
            }
            ans++;      // ans++
        }
        return -1;      // return -1
    }
};
int main(){
    Solution s;
    string start,end;
    vector<string> bank;
    int n;
    cin>>start>>end>>n;
    for(int i=0;i<n;i++){       // loop for i
        string str;
        cin>>str;
        bank.push_back(str);        // push str
    }
    cout<<s.minMutation(start,end,bank)<<endl;
    return 0;
}


Minimum genetic mutation using unordered_set

#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
#include <unordered_set>
using namespace std;
class Solution {
public:
    int minMutation(string start, string end, vector<string>& bank) {
        int n=bank.size();      // size of bank
        unordered_set<string> st;     // unordered_set
        for(int i=0;i<n;i++) st.insert(bank[i]);      // st.insert(bank[i])
        queue<string> q;        // queue
        q.push(start);      // push start
        int ans=0;      // initialize ans=0
        while(!q.empty()){      // loop for q
            int sz=q.size();        // size of q
            while(sz--){        // loop for sz
                string s=q.front();     // string s=q.front()
                q.pop();        // pop
                if(s==end) return ans;      // if condition is true
                for(int i=0;i<8;i++){       // loop for i
                    char ch=s[i];       // char ch=s[i]
                    for(int j=0;j<4;j++){       // loop for j
                        s[i]='A'+j;     // s[i]='A'+j
                        if(st.find(s)!=st.end()){      // if condition is true
                            st.erase(s);        // st.erase(s)
                            q.push(s);      // push s
                        }
                    }
                    s[i]=ch;        // s[i]=ch
                }
            }
            ans++;      // ans++
        }
        return -1;      // return -1
    }
};
int main(){
    Solution s;
    string start,end;
    vector<string> bank;
    int n;
    cin>>start>>end>>n;
    for(int i=0;i<n;i++){       // loop for i
        string str;
        cin>>str;
        bank.push_back(str);        // push str
    }
    cout<<s.minMutation(start,end,bank)<<endl;
    return 0;
}

Minimum genetic mutation using unordered_map

#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
#include <unordered_map>
using namespace std;
class Solution {
public:
    int minMutation(string start, string end, vector<string>& bank) {
        int n=bank.size();      // size of bank
        unordered_map<string,int> mp;     // unordered_map
        for(int i=0;i<n;i++) mp[bank[i]]=1;      // mp[bank[i]]=1
        queue<string> q;        // queue
        q.push(start);      // push start
        int ans=0;      // initialize ans=0
        while(!q.empty()){      // loop for q
            int sz=q.size();        // size of q
            while(sz--){        // loop for sz
                string s=q.front();     // string s=q.front()
                q.pop();        // pop
                if(s==end) return ans;      // if condition is true
                for(int i=0;i<8;i++){       // loop for i
                    char ch=s[i];       // char ch=s[i]
                    for(int j=0;j<4;j++){       // loop for j
                        s[i]='A'+j;     // s[i]='A'+j
                        if(mp[s]){      // if condition is true
                            mp[s]=0;        // mp[s]=0
                            q.push(s);      // push s
                        }
                    }
                    s[i]=ch;        // s[i]=ch
                }
            }
            ans++;      // ans++
        }
        return -1;      // return -1
    }
};
int main(){
    Solution s;
    string start,end;
    vector<string> bank;
    int n;
    cin>>start>>end>>n;
    for(int i=0;i<n;i++){       // loop for i
        string str;
        cin>>str;
        bank.push_back(str);        // push str
    }
    cout<<s.minMutation(start,end,bank)<<endl;
    return 0;
}

Minimum genetic mutation using BFS

#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;
class Solution {
public:
    int minMutation(string start, string end, vector<string>& bank) {
        int n=bank.size();      // size of bank
        vector<int> vis(n,0);       // vector
        queue<string> q;        // queue
        q.push(start);      // push start
        int ans=0;      // initialize ans=0
        while(!q.empty()){      // loop for q
            int sz=q.size();        // size of q
            while(sz--){        // loop for sz
                string s=q.front();     // string s=q.front()
                q.pop();        // pop
                if(s==end) return ans;      // if condition is true
                for(int i=0;i<n;i++){       // loop for i
                    if(vis[i]) continue;        // if condition is true
                    int cnt=0;      // initialize cnt=0
                    for(int j=0;j<8;j++){       // loop for j
                        if(s[j]!=bank[i][j]) cnt++;     // if condition is true
                    }
                    if(cnt==1){     // if condition is true
                        vis[i]=1;       // vis[i]=1
                        q.push(bank[i]);        // push bank[i]
                    }
                }
            }
            ans++;      // ans++
        }
        return -1;      // return -1
    }
};
int main(){
    Solution s;
    string start,end;
    vector<string> bank;
    int n;
    cin>>start>>end>>n;
    for(int i=0;i<n;i++){       // loop for i
        string str;
        cin>>str;
        bank.push_back(str);        // push str
    }
    cout<<s.minMutation(start,end,bank)<<endl;
    return 0;
}




#include<iostream>
#include<vector>
#include<queue>
#include<unordered_set>
using namespace std;
class Solution {
    public:
    int minMutation(string start ,string end , vector<string >& bank) {
        unordered_set<string> st(bank.begin(),bank.end());
        if(!st.count(end)) return -1;
        queue<string> q;
        q.push(start);
        int ans=0;
        while(!q.empty()){
            int sz=q.size();
            while(sz--){
                string s=q.front();
                q.pop();
                if(s==end) return ans;
                for(int i=0;i<8;i++){
                    char ch=s[i];
                    for(int j=0;j<4;j++){
                        s[i]='A'+j;
                        if(st.count(s)){
                            st.erase(s);
                            q.push(s);
                        }
                    }
                    s[i]=ch;
                }
            }
            ans++;
        }
        return -1;
    }   
};
int main(){
    Solution s;
    string start,end;
    vector<string> bank;
    int n;
    cin>>start>>end>>n;
    for(int i=0;i<n;i++){
        string str;
        cin>>str;
        bank.push_back(str);
    }
    cout<<s.minMutation(start,end,bank)<<endl;
    return 0;


}



 permutation of string using vector

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        int n=s1.size();        // size of s1
        int m=s2.size();        // size of s2
        vector<int> v1(26,0);       // vector
        vector<int> v2(26,0);       // vector
        for(int i=0;i<n;i++){       // loop for i
            v1[s1[i]-'a']++;        // v1[s1[i]-'a']++
            v2[s2[i]-'a']++;        // v2[s2[i]-'a']++
        }
        for(int i=n;i<m;i++){       // loop for i
            if(v1==v2) return true;     // if condition is true
            v2[s2[i]-'a']++;        // v2[s2[i]-'a']++
            v2[s2[i-n]-'a']--;      // v2[s2[i-n]-'a']--
        }
        return v1==v2;      // return v1==v2
    }
};
int main(){
    Solution s;
    string s1,s2;
    cin>>s1>>s2;
    cout<<s.checkInclusion(s1,s2)<<endl;
    return 0;
}




check  permutation of string using map


#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
using namespace std;
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        int n=s1.size();        // size of s1
        int m=s2.size();        // size of s2
        map<char,int> m1;       // map
        map<char,int> m2;       // map
        for(int i=0;i<n;i++){       // loop for i
            m1[s1[i]]++;        // m1[s1[i]]++
            m2[s2[i]]++;        // m2[s2[i]]++
        }
        for(int i=n;i<m;i++){       // loop for i
            if(m1==m2) return true;     // if condition is true
            m2[s2[i]]++;        // m2[s2[i]]++
            m2[s2[i-n]]--;      // m2[s2[i-n]]--
        }
        return m1==m2;      // return m1==m2
    }
};
int main(){
    Solution s;
    string s1,s2;
    cin>>s1>>s2;
    cout<<s.checkInclusion(s1,s2)<<endl;
    return 0;
}



// Erect the Fencem 
// You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden.

// You are asked to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed.

// Return the coordinates of trees that are exactly located on the fence perimeter.


#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
class Solution {
public:
    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {
        int n=trees.size();     // size of trees
        vector<vector<int>> ans;        // vector
        sort(trees.begin(),trees.end());        // sort trees
        for(int i=0;i<n;i++){       // loop for i
            while(ans.size()>=2 && cross(ans[ans.size()-2],ans[ans.size()-1],trees[i])<0) ans.pop_back();       // while condition is true
            ans.push_back(trees[i]);        // push trees[i]
        }
        ans.pop_back();     // pop_back
        for(int i=n-1;i>=0;i--){        // loop for i
            while(ans.size()>=2 && cross(ans[ans.size()-2],ans[ans.size()-1],trees[i])<0) ans.pop_back();       // while condition is true
            ans.push_back(trees[i]);        // push trees[i]
        }
        ans.pop_back();     // pop_back
        sort(ans.begin(),ans.end());        // sort ans
        ans.erase(unique(ans.begin(),ans.end()),ans.end());        // erase unique
        return ans;     // return ans
    }
    int cross(vector<int> a,vector<int> b,vector<int> c){
        return (b[0]-a[0])*(c[1]-a[1])-(b[1]-a[1])*(c[0]-a[0]);        // return (b[0]-a[0])*(c[1]-a[1])-(b[1]-a[1])*(c[0]-a[0])
    }
};
int main(){
    Solution s;
    int n;
    cin>>n;
    vector<vector<int>> trees(n,vector<int>(2));        // vector
    for(int i=0;i<n;i++){       // loop for i
        for(int j=0;j<2;j++){       // loop for j
            cin>>trees[i][j];       // cin trees[i][j]
        }
    }
    vector<vector<int>> ans=s.outerTrees(trees);        // vector
    for(int i=0;i<ans.size();i++){      // loop for i
        for(int j=0;j<2;j++){       // loop for j
            cout<<ans[i][j]<<" ";       // cout ans[i][j]
        }
        cout<<endl;
    }
    return 0;
}



Evaluate Reverse Polish Notation in C++
# include <iostream>
# include <vector>
# include <stack>
# include <string>
using namespace std;
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> s;       // stack
        for(int i=0;i<tokens.size();i++){       // loop for i
            if(tokens[i]=="+" || tokens[i]=="-" || tokens[i]=="*" || tokens[i]=="/"){        // if condition is true
                long a=s.top();      // a=s.top()
                s.pop();        // pop
                long b=s.top();      // b=s.top()
                s.pop();        // pop
                if(tokens[i]=="+") s.push(b+a);     // if condition is true
                else if(tokens[i]=="-") s.push(b-a);       // else if condition is true
                else if(tokens[i]=="*") s.push(b*a);       // else if condition is true
                else s.push(b/a);       // else
            }
            else s.push(stoi(tokens[i]));       // else
        }
        return s.top();     // return s.top()
    }   
};


 Daily Temperatures in java
 import java.util.*;
public class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
       int n=temperatures.length;        // size of temperatures
         int[] ans=new int[n];     // array
            Stack<Integer> s=new Stack<>();     // stack
            for(int i=0;i<n;i++){       // loop for i
                while(!s.isEmpty() && temperatures[s.peek()]<temperatures[i]){        // while condition is true
                    ans[s.peek()]=i-s.peek();       // ans[s.peek()]=i-s.peek()
                    s.pop();        // pop
                }
                s.push(i);      // push i
            }
            return ans;     // return ans
    }
    //  Time Complexity: O(n)
    //  Space Complexity: O(n)
}



 Daily Temperatures in c++
    # include <iostream>
    # include <vector>
    # include <stack>
    using namespace std;
    class Solution {
    public:
        vector<int> dailyTemperatures(vector<int>& temperatures) {
            int n=temperatures.size();      // size of temperatures
            vector<int> ans(n);     // vector
            stack<int> s;       // stack
            for(int i=0;i<n;i++){       // loop for i
                while(!s.empty() && temperatures[s.top()]<temperatures[i]){        // while condition is true
                    ans[s.top()]=i-s.top();     // ans[s.top()]=i-s.top()
                    s.pop();        // pop
                }
                s.push(i);      // push i
            }
            return ans;     // return ans
        }
    };

    //  Time complexity: O(n)
    //  Space complexity: O(n)


Possible Bipartition in C++
# include <iostream>
# include <vector>
# include <queue>
using namespace std;
class Solution {
public:
    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {
        vector<vector<int>> g(n+1);     // vector
        for(int i=0;i<dislikes.size();i++){     // loop for i
            g[dislikes[i][0]].push_back(dislikes[i][1]);      // g[dislikes[i][0]].push_back(dislikes[i][1])
            g[dislikes[i][1]].push_back(dislikes[i][0]);      // g[dislikes[i][1]].push_back(dislikes[i][0])
        }
        vector<int> color(n+1,-1);      // vector
        for(int i=1;i<=n;i++){      // loop for i
            if(color[i]==-1){       // if condition is true
                queue<int> q;       // queue
                q.push(i);      // push i
                color[i]=0;     // color[i]=0
                while(!q.empty()){      // while condition is true
                    int t=q.front();        // t=q.front()
                    q.pop();        // pop
                    for(int j=0;j<g[t].size();j++){     // loop for j
                        if(color[g[t][j]]==-1){     // if condition is true
                            color[g[t][j]]=1-color[t];     // color[g[t][j]]=1-color[t]
                            q.push(g[t][j]);        // push g[t][j]
                        }
                        else if(color[g[t][j]]==color[t]) return false;      // else if condition is true
                    }
                }
            }
        }
        return true;        // return true
    }
};




Possible Bipartition using DFS in C++
# include <iostream>
# include <vector>
using namespace std;
class Solution {
public:
    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {
        vector<vector<int>> g(n+1);     // vector
        for(int i=0;i<dislikes.size();i++){     // loop for icf
            g[dislikes[i][0]].push_back(dislikes[i][1]);      // g[dislikes[i][0]].push_back(dislikes[i][1])
            g[dislikes[i][1]].push_back(dislikes[i][0]);      // g[dislikes[i][1]].push_back(dislikes[i][0])
        }
        vector<int> color(n+1,-1);      // vector
        for(int i=1;i<=n;i++){      // loop for i
            if(color[i]==-1){       // if condition isc true
                if(!dfs(g,color,i,0)) return false;     // if condition is true
            }
        }
        return true;        // return true
    }
    bool dfs(vector<vector<int>>& g,vector<int>& color,int i,int c){      // dfs function // what is c here ?  // c is color
        color[i]=c;     // color[i]=c
        for(int j=0;j<g[i].size();j++){     // loop for j
            if(color[g[i][j]]==-1){     // if condition is true
                if(!dfs(g,color,g[i][j],1-c)) return false;     // if condition is true
            }
            else if(color[g[i][j]]==c) return false;      // else if condition is true
        }
        return true;        // return true
    }
};

// Time Complexity: O(n)
// Space Complexity: O(n)



Possible Bipartition using DFS in Java
class Solution {
    public boolean possibleBipartition(int n, int[][] dislikes) {
        ArrayList<Integer>[] g = new ArrayList[n+1];      // arraylist
        for(int i=0;i<=n;i++) g[i] = new ArrayList<>();       // loop for i
        for(int i=0;i<dislikes.length;i++){      // loop for i
            g[dislikes[i][0]].add(dislikes[i][1]);       // g[dislikes[i][0]].add(dislikes[i][1])
            g[dislikes[i][1]].add(dislikes[i][0]);       // g[dislikes[i][1]].add(dislikes[i][0])
        }
        int[] color = new int[n+1];     // array
        for(int i=1;i<=n;i++){      // loop for i
            if(color[i]==0){        // if condition is true
                if(!dfs(g,color,i,1)) return false;      // if condition is true
            }
        }
        return true;        // return true
    }
    public boolean dfs(ArrayList<Integer>[] g,int[] color,int i,int c){      // dfs function
        color[i]=c;     // color[i]=c
        for(int j=0;j<g[i].size();j++){     // loop for j
            if(color[g[i].get(j)]==0){      // if condition is true
                if(!dfs(g,color,g[i].get(j),-c)) return false;      // if condition is true
            }
            else if(color[g[i].get(j)]==c) return false;       // else if condition is true
        }
        return true;        // return true
    }
}

// Time Complexity: O(n)
// Space Complexity: O(n)

Possible Bipartition using BFS in Java
class Solution {
    public boolean possibleBipartition(int n, int[][] dislikes) {
        ArrayList<Integer>[] g = new ArrayList[n+1];      // arraylist
        for(int i=0;i<=n;i++) g[i] = new ArrayList<>();       // loop for i
        for(int i=0;i<dislikes.length;i++){      // loop for i
            g[dislikes[i][0]].add(dislikes[i][1]);       // g[dislikes[i][0]].add(dislikes[i][1])
            g[dislikes[i][1]].add(dislikes[i][0]);       // g[dislikes[i][1]].add(dislikes[i][0])
        }
        int[] color = new int[n+1];     // array
        for(int i=1;i<=n;i++){      // loop for i
            if(color[i]==0){        // if condition is true
                Queue<Integer> q = new LinkedList<>();      // queue
                q.add(i);       // add i
                color[i]=1;     // color[i]=1
                while(!q.isEmpty()){        // while condition is true
                    int t = q.poll();       // t = q.poll()
                    for(int j=0;j<g[t].size();j++){     // loop for j
                        if(color[g[t].get(j)]==0){      // if condition is true
                            color[g[t].get(j)]=-color[t];       // color[g[t].get(j)]=-color[t]
                            q.add(g[t].get(j));     // add g[t].get(j)
                        }
                        else if(color[g[t].get(j)]==color[t]) return false;      // else if condition is true
                    }
                }
            }
        }
        return true;        // return true
    }
}

// Time Complexity: O(n)
// Space Complexity: O(n)


Domino and Tromino Tiling in C++
# include <iostream>
# include <vector>
using namespace std;
class Solution {
public:
    int numTilings(int n) {    // numTilings function
        int mod = 1e9;    // mod
        mod += 7;
        vector<long long> dp(1001,0);
        dp[1] = 1;
        dp[2] = 2;
        dp[3] = 5;
        if(n<=3) return dp[n];
        for(int i=4; i<=n; i++){
            dp[i] = 2*dp[i-1]+dp[i-3];
            dp[i] %= mod;
        }
        return dp[n];
    }
};

in Java Solution
class Solution {
    public int numTilings(int n) {
        int mod = 1e9;
        mod += 7;
        long[] dp = new long[1001];
        dp[1] = 1;
        dp[2] = 2;
        dp[3] = 5;
        if(n<=3) return (int)dp[n];
        for(int i=4; i<=n; i++){
            dp[i] = 2*dp[i-1]+dp[i-3];
            dp[i] %= mod;
        }
        return (int)dp[n];
    }
}


Jump Game in C++
# include <iostream>
# include <vector>
using namespace std;

class Solution {
public:
    bool canJump(vector<int>& nums) {    // canJump function
        int n = nums.size();  // n = nums.size()
        int maxReach = 0;  //   maxReach = 0
        for(int i=0; i<n; i++){ //   loop for i
            if(i>maxReach) return false;  //  if condition is true
            maxReach = max(maxReach, i+nums[i]);   // maxReach = max(maxReach, i+nums[i])  
        }
        return true;
    }
};
     


Jump Game in Java Solution
class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;
        int maxReach = 0;
        for(int i=0; i<n; i++){
            if(i>maxReach) return false;
            maxReach = Math.max(maxReach, i+nums[i]);
        }
        return true;
    }
}


maximum bag with full capacity in C++ // Time Complexity O(n*maxCapacity) and Space Complexity O(maxCapacity)
# include <iostream>
# include <vector>
using namespace std;
class Solution {
public:
    int maximumBagWithFullCapacity(vector<int>& capacity , vector<int>& rocks , int additionalRocks) {    // maximumBagWithFullCapacity function
        int n = capacity.size();
        int maxCapacity = 0;
        for(int i=0; i<n; i++){
            maxCapacity += capacity[i];
        }
        vector<int> dp(maxCapacity+1,0);
        for(int i=0; i<n; i++){
            for(int j=maxCapacity; j>=capacity[i]; j--){
                dp[j] = max(dp[j], dp[j-capacity[i]]+rocks[i]);
            }
        }
        int ans = 0;
        for(int i=0; i<=maxCapacity; i++){
            if(dp[i]>=additionalRocks) ans = max(ans, i);
        }
        return ans;
    }


 Remove Stones to Minimize the Total in C++ //  Time Complexity : O(nlogn) space Complexity : O(n)
# include <iostream>
# include <vector>
using namespace std;
class Solution {
public:
    int minStoneSum(vector<int>& piles, int k) {    // minStoneSum function
        priority_queue<int> pq;
        for(int i=0; i<piles.size(); i++){
            pq.push(piles[i]);
        }
        while(k--){
            int top = pq.top();
            pq.pop();
            pq.push(top - top/2);
        }
        int ans = 0;
        while(!pq.empty()){
            ans += pq.top();
            pq.pop();
        }
        return ans;
    }
};

Remove Stones to Minimize the Total in Java Solution //   Time Complexity : O(nlogn)
class Solution {
    public int minStoneSum(int[] piles, int k) {    // minStoneSum function
        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->b-a);
        for(int i=0; i<piles.length; i++){
            pq.add(piles[i]);
        }
        while(k-->0){
            int top = pq.poll();
            pq.add(top - top/2);
        }
        int ans = 0;
        while(!pq.isEmpty()){
            ans += pq.poll();
        }
        return ans;
    }
}

oddEven Linked List in C++  // time complexity O(n) and space complexity O(1)
# include <iostream>
# include <vector>
using namespace std;
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {    // oddEvenList function
        if(head==NULL) return head;
        ListNode* odd = head;
        ListNode* even = head->next;
        ListNode* evenHead = even;
        while(even!=NULL && even->next!=NULL){
            odd->next = even->next;
            odd = odd->next;
            even->next = odd->next;
            even = even->next;
        }
        odd->next = evenHead;
        return head;
    }
};  
oddEven Linked List in java Solution  // time complexity O(n) and space complexity O(1)
class Solution {
    public ListNode oddEvenList(ListNode head) {
        if(head==null) return head;
        ListNode odd = head;
        ListNode even = head.next;
        ListNode evenHead = even;
        while(even!=null && even.next!=null){
            odd.next = even.next;
            odd = odd.next;
            even.next = odd.next;
            even = even.next;
        }
        odd.next = evenHead;
        return head;
    }
}

check Palindrome in Linked List in C++ // time complexity O(n) and space complexity O(1)
# include <iostream>
# include <vector>
using namespace std;
class Solution {
public:
    bool isPalindrome(ListNode* head) {    // isPalindrome function
        if(head==NULL || head->next==NULL) return true;
        ListNode* slow = head;
        ListNode* fast = head;
        while(fast->next!=NULL && fast->next->next!=NULL){
            slow = slow->next;
            fast = fast->next->next;
        }
        slow->next = reverse(slow->next);
        slow = slow->next;
        while(slow!=NULL){
            if(head->val!=slow->val) return false
            head = head->next;
            slow = slow->next;
        }
        return true;
    }
    ListNode* reverse(ListNode* head){    // reverse function
        ListNode* prev = NULL;
        ListNode* curr = head;
        while(curr!=NULL){
            ListNode* next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
};


check palindrime in linked list in C++ easy solution // time complexity O(n) and space complexity O(n)
# include <iostream>
# include <vector>
using namespace std;
class Solution {
public:
    bool isPalindrome(ListNode* head) {    // isPalindrome function
        vector<int> v;
        ListNode* temp = head;
        while(temp!=NULL){
            v.push_back(temp->val);
            temp = temp->next;
        }
        int i=0;
        int j=v.size()-1;
        while(i<j){
            if(v[i]!=v[j]) return false;
            i++;
            j--;
        }
        return true;
    }
};


check palindrome in Linked list Beats 100% time and space complexity O(n)
# include <iostream>
# include <vector>
using namespace std;
int init = [] {  // This is a trick to speed up cin/cout  // Time complexity O(n) and space complexity O(1)
    ios_base::sync_with_stdio(false); // turn off sync between cin and cout (faster) 
    cin.tie(nullptr);  // untie in/out streams (faster) 
    ofstream out("user.out"); // redirect stdout to user.out 
    for (string s; getline(cin, s);)  // read a line into s  
        out << (equal(s.begin()+1, s.begin()+s.size()/2, s.rbegin()+1) ? "true\n" : "false\n");  // write to user.out
    out.flush(); // flush the buffer
    exit(0);  // exit normally
    return 0;
}();


class Solution {  // Time complexity O(n) and space complexity O(1)
public:
   void pal(ListNode*&head,ListNode*tail,int&c){
        if(!tail->next){
            return;
        }
        tail=tail->next;
        pal(head,tail,c);
        if(head->val!=tail->val){
            c++;
        }
       head=head->next;
    }
    bool isPalindrome(ListNode* head) {
        return true;
        ListNode*tail=head;
        int c=0;
        pal(head,tail,c);
        return !c;

    }
};

check palindrome in Linked list in java Solution // time complexity O(n) and space complexity O(1)
import java.math.BigInteger;
import java.util.Objects; // Time complexity O(n) and space complexity O(1)
class Solution {
       public boolean isPalindrome(ListNode head) {

        if (head == null) {
            return true;
        }
        ListNode slow = head, fast = head, rev = null;
        while (fast != null && fast.next != null) {
            ListNode temp = rev;
            rev = slow;
            slow = slow.next;
            fast = fast.next.next;
            rev.next = temp;
        }
        if (fast != null) {
            slow = slow.next;
        }
        while (rev != null) {
            if (slow.val != rev.val) {
                return false;
            }
            slow = slow.next;
            rev = rev.next;
        }
        return true;
    }

}

check palindrome in Linked list in java Solution // time complexity O(n) and space complexity O(n)
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head==null) return true;
        ListNode slow = head;
        ListNode fast = head;
        while(fast!=null && fast.next!=null){
            slow = slow.next;
            fast = fast.next.next;
        }
        if(fast!=null) slow = slow.next;
        slow = reverse(slow);
        fast = head;
        while(slow!=null){
            if(fast.val!=slow.val) return false;
            fast = fast.next;
            slow = slow.next;
        }
        return true;
    }
    public ListNode reverse(ListNode head){
        ListNode prev = null;
        ListNode curr = head;
        while(curr!=null){
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
}


reverse a linked list best solution // time complexity O(n) and space complexity O(1)
# include <iostream>
# include <vector>
using namespace std;
class Solution {
public:
    ListNode* reverseList(ListNode* head) {    // reverseList function
        ListNode* prev = NULL;
        ListNode* curr = head;
        while(curr!=NULL){
            ListNode* next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
};

reverse a linked list in java best solution // time complexity O(n) and space complexity O(1)
class Solution  // Time complexity O(n) and space complexity O(1)
{
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        while(curr!=null){
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
}

Single Threaded CPU in java best solution // time complexity O(nlogn) and space complexity O(n)
class Solution {
    public int[] getOrder(int[][] tasks) {
        int n = tasks.length;
        int[] ans = new int[n];
        int[][] v = new int[n][3];
        for(int i=0;i<n;i++){
            v[i][0] = tasks[i][0];
            v[i][1] = tasks[i][1];
            v[i][2] = i;
        }
        Arrays.sort(v,(a,b)->a[0]-b[0]);
        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[1]==b[1]?a[2]-b[2]:a[1]-b[1]);
        int i=0;
        int time = v[0][0];
        int j=0;
        while(i<n || !pq.isEmpty()){
            if(i<n && v[i][0]<=time){
                pq.add(v[i]);
                i++;
            }
            else if(!pq.isEmpty()){
                int[] temp = pq.poll();  
                time+=temp[1];
                ans[j++] = temp[2];
            }
            else{
                time = v[i][0];
            }
        }
        return ans;
    }
}


Single Threaded CPU in c++ best solution // time complexity O(nlogn) and space complexity O(n)
class Solution {
public:
    vector<int> getOrder(vector<vector<int>>& tasks) {
        int n = tasks.size();
        vector<int> ans(n);
        vector<vector<int>> v(n,vector<int>(3));
        for(int i=0;i<n;i++){
            v[i][0] = tasks[i][0];
            v[i][1] = tasks[i][1];
            v[i][2] = i;
        }
        sort(v.begin(),v.end(),[](vector<int>&a,vector<int>&b){
            return a[0]<b[0];
        });
        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> pq;
        int i=0;
        int time = v[0][0];
        int j=0;
        while(i<n || !pq.empty()){
            if(i<n && v[i][0]<=time){
                pq.push(v[i]);
                i++;
            }
            else if(!pq.empty()){
                vector<int> temp = pq.top();
                pq.pop();
                time+=temp[1];
                ans[j++] = temp[2];
            }
            else{
                time = v[i][0];
            }
        }
        return ans;
    }
};


Unique Path III in c++ best solution // time complexity O(3^N) and space complexity O(N)
class Solution {
public:
    int uniquePathsIII(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        int x,y;
        int count = 0;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]==0) count++;
                if(grid[i][j]==1){
                    x = i;
                    y = j;
                }
            }
        }
        return dfs(grid,x,y,count);
    }
    int dfs(vector<vector<int>>& grid,int x,int y,int count){
        if(x<0 || y<0 || x>=grid.size() || y>=grid[0].size() || grid[x][y]==-1) return 0;
        if(grid[x][y]==2){
            if(count==-1) return 1;
            return 0;
        }
        grid[x][y] = -1;
        int ans = dfs(grid,x+1,y,count-1) + dfs(grid,x-1,y,count-1) + dfs(grid,x,y+1,count-1) + dfs(grid,x,y-1,count-1);
        grid[x][y] = 0;
        return ans;
    }
};

Unique Path III in java best solution // time complexity O(3^N) and space complexity O(N)
class Solution {
    public int uniquePathsIII(int[][] grid) {
        int n = grid.length;
        int m = grid[0].length;
        int x=0,y=0;
        int count = 0;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]==0) count++;
                if(grid[i][j]==1){
                    x = i;
                    y = j;
                }
            }
        }
        return dfs(grid,x,y,count);
    }
    public int dfs(int[][] grid,int x,int y,int count){
        if(x<0 || y<0 || x>=grid.length || y>=grid[0].length || grid[x][y]==-1) return 0;
        if(grid[x][y]==2){
            if(count==-1) return 1;
            return 0;
        }
        grid[x][y] = -1;
        int ans = dfs(grid,x+1,y,count-1) + dfs(grid,x-1,y,count-1) + dfs(grid,x,y+1,count-1) + dfs(grid,x,y-1,count-1);
        grid[x][y] = 0;
        return ans;
    }
};

Unique Path III in c++ using dp // time complexity O(N*M) and space complexity O(N*M)
class Solution {
public:
    int uniquePathsIII(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        int x,y;
        int count = 0;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]==0) count++;
                if(grid[i][j]==1){
                    x = i;
                    y = j;
                }
            }
        }
        vector<vector<int>> dp(n,vector<int>(m,0));
        dp[x][y] = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]==-1) continue;
                if(i-1>=0 && grid[i-1][j]!=-1) dp[i][j]+=dp[i-1][j];
                if(j-1>=0 && grid[i][j-1]!=-1) dp[i][j]+=dp[i][j-1];
            }
        }
        return dp[n-1][m-1];
    }
};


   

word pattern in c++ best solution // time complexity O(N) and space complexity O(N)
class Solution {
public:
    bool wordPattern(string pattern, string s) {
        map<char,string> p;
        map<string,char> w;
        istringstream in(s);  // this is used to split the string into words   // istringstream in(s) is used to split the string into words
        int i=0 , n = pattern.size();
        for(string word;in>>word;i++){
            if(i==n || p[pattern[i]]!=w[word]) return false;
            p[pattern[i]] = w[word] = word;
        }
        return i==n;


    }
};





word pattern in java another best solution // time complexity O(N) and space complexity O(N)
class Solution {
    public boolean wordPattern(String pattern, String s) {
        String[] words = s.split(" ");
        if (words.length != pattern.length()) return false;
        Map index = new HashMap();
        for (Integer i=0; i<words.length; ++i)
            if (index.put(pattern.charAt(i), i) != index.put(words[i], i))
                return false;
        return true;
    }
}


All Paths From Source to Target in c++ best solution // time complexity O(N) and space complexity O(N)
class Solution {
public:
    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        vector<vector<int>> ans;
        vector<int> temp;
        temp.push_back(0);
        dfs(graph,ans,temp,0);
        return ans;
    }
    void dfs(vector<vector<int>>& graph,vector<vector<int>>& ans,vector<int> temp,int node){
        if(node==graph.size()-1){
            ans.push_back(temp);
            return;
        }
        for(int i=0;i<graph[node].size();i++){
            temp.push_back(graph[node][i]);
            dfs(graph,ans,temp,graph[node][i]);
            temp.pop_back();
        }

    }

};

All Paths From Source to Target in java best solution // time complexity O(N) and space complexity O(N)
class Solution {
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> temp = new ArrayList<>();
        temp.add(0);
        dfs(graph,ans,temp,0);
        return ans;
    }
    public void dfs(int[][] graph,List<List<Integer>> ans,List<Integer> ted,int node){
        if(node==graph.length-1){
            ans.add(new ArrayList<>(temp));
            return;
        }
        for(int i=0;i<graph[node].length;i++){
            temp.add(graph[node][i])in
            dfs(graph,ans,temp,graph[node][i]);
            temp.remove(temp.size()-1);
        }

    }

}

All Paths From Source to Target in c++ using bfs // time complexity O(N) and space complexity O(N)
class Solution {
public:
    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        vector<vector<int>> ans;
        queue<vector<int>> q;
        q.push({0});
        while(!q.empty()){
            vector<int> temp = q.front();
            q.pop();
            int node = temp.back();
            if(node==graph.size()-1) ans.push_back(temp);
            for(int i=0;i<graph[node].size();i++){
                vector<int> temp1 = temp;
                temp1.push_back(graph[node][i]);
                q.push(temp1);
            }
        }
        return ans;
    }

};

Maximum ice cream bars in c++ best solution // time complexity O(N) and space complexity O(1)
class Solution {
public:
    int maxIceCream(vector<int>& costs, int coins) {
        sort(costs.begin(),costs.end());
        int ans = 0;
        for(int i=0;i<costs.size();i++){
            if(coins>=costs[i]){
                coins-=costs[i];
                ans++;
            }
        }
        return ans;
    }
};

Maximum ice cream bars in java best solution // time complexity O(N) and space complexity O(1)
class Solution {
    public int maxIceCream(int[] costs, int coins) {
        Arrays.sort(costs);
        int ans = 0;
        for(int i=0;i<costs.length;i++){
            if(coins>=costs[i]){
                coins-=costs[i];
                ans++;
            }
        }
        return ans;
    }
};

Detect Capital in c++ best solution // time complexity O(N) and space complexity O(1)
class Solution {
public:
    bool detectCapitalUse(string word) {
        int n = word.size();
        int count = 0;
        for(int i=0;i<n;i++){
            if(word[i]>='A' && word[i]<='Z') count++;
        }
        if(count==n || count==0) return true;
        if(count==1 && word[0]>='A' && word[0]<='Z') return true;
        return false;
    }
};


Detect Capital in java best solution // time complexity O(N) and space complexity O(1)
class Solution {
    public boolean detectCapitalUse(String word) {
        int n = word.length();
        int count = 0;
        for(int i=0;i<n;i++){
            if(word.charAt(i)>='A' && word.charAt(i)<='Z') count++;
        }
        if(count==n || count==0) return true;
        if(count==1 && word.charAt(0)>='A' && word.charAt(0)<='Z') return true;
        return false;
    }
};

Delete coloumns to make sorted in c++ best solution // time complexity O(N) and space complexity O(1)
class Solution {
public:
    int minDeletionSize(vector<string>& strs) {
        int ans = 0;
        for(int i=0;i<strs[0].size();i++){
            for(int j=0;j<strs.size()-1;j++){
                if(strs[j][i]>strs[j+1][i]){
                    ans++;
                    break;
                }
            }
        }
        return ans;
    }
};

Delete coloumns to make sorted in java best solution // time complexity O(N) and space complexity O(1)
class Solution {
    public int minDeletionSize(String[] strs) {
        int ans = 0;
        for(int i=0;i<strs[0].length();i++){
            for(int j=0;j<strs.length-1;j++){
                if(strs[j].charAt(i)>strs[j+1].charAt(i)){
                    ans++;
                    break;
                }
            }
        }
        return ans;
    }
};

Minimum Rounds to Complete All Tasks in c++ using map // time complexity O(N) and space complexity O(N)
class Solution {
public:
    int minimumRounds(vector<int>& tasks){
        int n = tasks.size();
        map<int,int> mp;
        for(int i=0;i<n;i++){
            if(tasks[i]%2==0) mp[tasks[i]/2]++;
            else mp[tasks[i]/2+1]++;
        }
        int ans = 0;
        for(auto it:mp){
            int x = it.second;
            if(x%2==0) ans+=x/2;
            else ans+=x/2+1;
        }
        return ans;
    }
};

 Minimum Rounds to Complete All Tasks in c++ using unordered_map // time complexity O(N) and space complexity O(N)

class Solution {
public:
    int minimumRounds(vector<int>& tasks){
       unordered_map<int , int> count; // count of tasks with even number of rounds and odd number of rounds  
       int res = 0 ,freq1;  // freq1 is the count of tasks with odd number of rounds  and res is the minimum number of rounds to complete all tasks
       for(auto a : tasks){ 
        count[a]++;     // count of tasks with even number of rounds and odd number of rounds
       }
       for(auto& it : count){       // it.second is the count of tasks with even number of rounds and odd number of rounds
        if(it.second == 1) return -1; // if the count of tasks with odd number of rounds is 1 then we can't complete the task
        res += (it.second/2)+3; // if the count of tasks with odd number of rounds is 2 then we can complete the task in 3 rounds
       }
         return res;  // return the minimum number of rounds to complete all tasks
    }
};


Minimum Rounds to Complete All Tasks in java using map // time complexity O(N) and space complexity O(N)
class Solution{
    public int minimumRounds(int[] A) {
        HashMap<Integer, Integer> count = new HashMap<>();
        for (int a : A)
            count.put(a, count.getOrDefault(a, 0) + 1);
        int res = 0;
        for (int freq : count.values()) {
            if (freq == 1) return -1;
            res += (freq + 2) / 3;
        }
        return res;
    }
}


gas station in c++ best solution // time complexity O(N) and space complexity O(1)
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int total_fuel = 0 , total_cost = 0;
        int current =0 , start =0;
        int n = gas.size();
        for(int i=0; i<n; i++){
            total_fuel += gas[i];
        }
        for(int i=0; i<n; i++){
            total_cost += cost[i];
        }
        if(total_fuel < total_cost){
            return -1;
        }
        for(int i=0 ; i<n; i++){
            current += (gas[i]-cost[i]);
            if(current < 0){
                start = i+1;
                current = 0;
            }
        }
        return start;
    }
};

gas station in java best solution // time complexity O(N) and space complexity O(1)
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int total_fuel = 0 , total_cost = 0;
        int current = 0, start = 0;
        int n = gas.length;
        for(int i=0; i<n; i++){
            total_fuel += gas[i];
        }
        for(int i=0; i<n; i++){
            total_cost += cost[i];
        }
        if(total_fuel < total_cost){
            return -1;
        }
        for(int i=0 ; i<n ; i++){
            current += (gas[i] - cost[i]);
            if(current < 0){
                start = i+1;
                current = 0;
            }
        }
        return start;

    }
}

Minimum Number of Arrows to Burst Balloons in c++ best solution // time complexity O(N) and space complexity O(1)
class Solution {
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        int n = points.size();
        if(n==0) return 0;
        sort(points.begin(),points.end());
        int ans = 1;
        int end = points[0][1];     //  end = points[0][1] is the end of the current balloon
        for(int i=1;i<n;i++){
            if(points[i][0]>end){
                ans++;
                end = points[i][1];   // end = points[i][1] is the end of the current balloon   
            }
            else{
                end = min(end,points[i][1]);     // end = min(end,points[i][1])  is the end of the current balloon   
            }
        }
        return ans;
    }
};

Minimum Number of Arrows to Burst Balloons in java best solution // time complexity O(N) and space complexity O(1)
class Solution {
    public int findMinArrowShots(int[][] points) {
        int n = points.length;
        if(n==0) return 0;
        Arrays.sort(points,(a,b)->a[1]-b[1]);
        int ans = 1;
        int end = points[0][1];
        for(int i=1;i<n;i++){
            if(points[i][0]>end){
                ans++;
                end = points[i][1];
            }
            else{
                end = Math.min(end,points[i][1]);  
            }
        }
        return ans;
    }
}

Max points on a line in c++ best solution // time complexity O(N^2) and space complexity O(N)
class Solution {
    public:
    int maxPoints(vector<vector<int>>& points) { //  points[i][0] is the x coordinate of the ith point and points[i][1] is the y coordinate of the ith point
        int n = points.size(); // n is the number of points
        if(n<=2) return n;      // if there are less than 2 points then the maximum number of points on a line is n
        int ans = 0;         // ans is the maximum number of points on a line
        for(int i=0;i<n;i++){    // for each point 
            int x1 = points[i][0];      // x1 is the x coordinate of the ith point
            int y1 = points[i][1];      // y1 is the y coordinate of the ith point
            map<pair<int,int>,int> mp;      // mp is a map which stores the slope of the line and the number of points on that line
            int same = 0;           // same is the number of points which are same as the ith point
            int vertical = 0;       // vertical is the number of points which are vertical to the ith point
            int curr = 0;        // curr is the maximum number of points on a line which passes through the ith point
            for(int j=i+1;j<n;j++){    // for each point after the ith point
                int x2 = points[j][0];      // x2 is the x coordinate of the jth point  
                int y2 = points[j][1];    // y2 is the y coordinate of the jth point
                if(x1==x2 && y1==y2){   // if the jth point is same as the ith point
                    same++;        // increment same by 1
                }
                else if(x1==x2){        // if the jth point is vertical to the ith point
                    vertical++;     // increment vertical by 1
                }
                else{
                    int dx = x2-x1;     // dx is the change in x coordinate
                    int dy = y2-y1;     // dy is the change in y coordinate
                    int g = __gcd(dx,dy);       // g is the gcd of dx and dy
                    dx/=g;          // dx is the change in x coordinate divided by the gcd of dx and dy
                    dy/=g;      // dy is the change in y coordinate divided by the gcd of dx and dy
                    mp[{dx,dy}]++;      // increment the number of points on the line which passes through the ith point and the jth point by 1
                    curr = max(curr,mp[{dx,dy}]);       // curr is the maximum of curr and the number of points on the line which passes through the ith point and the jth point
                }                               // curr is the maximum number of points on a line which passes through the ith point
                curr = max(curr,vertical);          // curr is the maximum of curr and vertical
            }                        // curr is the maximum number of points on a line which passes through the ith point   
            ans = max(ans,curr+same+1);             // ans is the maximum of ans and curr+same+1
        }
        return ans;     // ans is the maximum number of points on a line
    }       
};


Max points on a line in java best solution // time complexity O(N^2) and space complexity O(N)
class Solution {
    public int maxPoints(int[][] points) { //  points[i][0] is the x coordinate of the ith point and points[i][1] is the y coordinate of the ith point
        int n = points.length; // n is the number of points
        if(n<=2) return n;      // if there are less than 2 points then the maximum number of points on a line is n
        int ans = 0;         // ans is the maximum number of points on a line
        for(int i=0;i<n;i++){    // for each point 
            int x1 = points[i][0];      // x1 is the x coordinate of the ith point
            int y1 = points[i][1];      // y1 is the y coordinate of the ith point
            HashMap<String,Integer> mp = new HashMap<>();      // mp is a map which stores the slope of the line and the number of points on that line
            int same = 0;           // same is the number of points which are same as the ith point
            int vertical = 0;       // vertical is the number of points which are vertical to the ith point
            int curr = 0;        // curr is the maximum number of points on a line which passes through the ith point
            for(int j=i+1;j<n;j++){    // for each point after the ith point
                int x2 = points[j][0];      // x2 is the x coordinate of the jth point  
                int y2 = points[j][1];    // y2 is the y coordinate of the jth point
                if(x1==x2 && y1==y2){   // if the jth point is same as the ith point
                    same++;        // increment same by 1
                }
                else if(x1==x2){        // if the jth point is vertical to the ith point
                    vertical++;     // increment vertical by 1
                }
                else{
                    int dx = x2-x1;     // dx is the change in x coordinate
                    int dy = y2-y1;     // dy is the change in y coordinate
                    int g = gcd(dx,dy);       // g is the gcd of dx and dy
                    dx/=g;          // dx is the change in x coordinate divided by the gcd of dx and dy
                    dy/=g;      // dy is the change in y coordinate divided by the gcd of dx and dy
                    String s = dx+" "+dy;       // s is the slope of the line which passes through the ith point and the jth point
                    mp.put(s,mp.getOrDefault(s,0)+1);       // increment the number of points on the line which passes through the ith point and the jth point by 1
                    curr = Math.max(curr,mp.get(s));        // curr is the maximum of curr and the number of points on the line which passes through the ith point and the jth point
                }                               // curr is the maximum number of points on a line which passes through the ith point 
        
                curr = Math.max(curr,vertical);         // curr is the maximum of curr and vertical
            }                        // curr is the maximum number of points on a line which passes through the ith point
            ans = Math.max(ans,curr+same+1);            // ans is the maximum of ans and curr+same+1
        }
        return ans;     // ans is the maximum number of points on a line
    }
    public int gcd(int a,int b){        // gcd of a and b
        if(b==0) return a;      // if b is 0 then gcd of a and b is a
        return gcd(b,a%b);      // gcd of a and b is gcd of b and a%b
    }
}


Max points on a line in java best solution  // time complexity O(N^2) and space complexity O(N)
class Solution {
    public int maxPoints(int[][] points) {    // points[i][0] is the x coordinate of the ith point and points[i][1] is the y coordinate of the ith point
        int n = points.length; // n is the number of points
        int ans = 1;        // ans is the maximum number of points on a line
        for (int i = 0; i < n; i++) {   // for each point
            int[] x = points[i];  // x is the ith point
            for (int j = i + 1; j < n; j++) {  // for each point after the ith point
                int[] y = points[j];  // y is the jth point
                int cnt = 2;        //  cnt is the number of points on the line which passes through the ith point and the jth point
                for (int k = j + 1; k < n; k++) {   // for each point after the jth point
                    int[] p = points[k];        // p is the kth point
                    int s1 = (y[1] - x[1]) * (p[0] - y[0]);  // s1 is the slope of the line which passes through the ith point and the jth point
                    int s2 = (p[1] - y[1]) * (y[0] - x[0]);  // s2 is the slope of the line which passes through the jth point and the kth point
                    if (s1 == s2) cnt++;   // if the slope of the line which passes through the ith point and the jth point is equal to the slope of the line which passes through the jth point and the kth point then increment cnt by 1
                }
                ans = Math.max(ans, cnt);   // ans is the maximum of ans and cnt
            }
        }
        return ans;
    }
}

Max points on a line in c++ best solution  // time complexity O(N^2) and space complexity O(N)
class Solution {
public:
    int maxPoints(vector<vector<int>>& points) {   // points[i][0] is the x coordinate of the ith point and points[i][1] is the y coordinate of the ith point
        int n = points.size();  // n is the number of points
        int ans = 1;        // ans is the maximum number of points on a line
        for (int i = 0; i < n; i++) {   // for each point
            vector<int> x = points[i];  // x is the ith point
            for (int j = i + 1; j < n; j++) {  // for each point after the ith point
                vector<int> y = points[j];  // y is the jth point
                int cnt = 2;        //  cnt is the number of points on the line which passes through the ith point and the jth point
                for (int k = j + 1; k < n; k++) {   // for each point after the jth point
                    vector<int> p = points[k];        // p is the kth point
                    int s1 = (y[1] - x[1]) * (p[0] - y[0]);  // s1 is the slope of the line which passes through the ith point and the jth point
                    int s2 = (p[1] - y[1]) * (y[0] - x[0]);  // s2 is the slope of the line which passes through the jth point and the kth point
                    if (s1 == s2) cnt++;   // if the slope of the line which passes through the ith point and the jth point is equal to the slope of the line which passes through the jth point and the kth point then increment cnt by 1
                }
                ans = max(ans, cnt);   // ans is the maximum of ans and cnt
            }
        }
        return ans;
    }
};
fv

Preorder traversal of binary tree in c++ best solution  // time complexity O(N) and space complexity O(N)

class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {  // root is the root of the binary tree
        vector<int> ans;        // ans is the preorder traversal of the binary tree
        if(root==NULL) return ans;      // if root is null then return ans
        stack<TreeNode*> st;        // st is the stack which stores the nodes of the binary tree
        st.push(root);      // push the root into the stack
        while(!st.empty()){     // while the stack is not empty
            TreeNode* node = st.top();      // node is the topmost node of the stack
            st.pop();       // pop the topmost node of the stack
            ans.push_back(node->val);       // add the value of the node into the ans
            if(node->right!=NULL) st.push(node->right);       // if the right child of the node is not null then push the right child of the node into the stack
            if(node->left!=NULL) st.push(node->left);     // if the left child of the node is not null then push the left child of the node into the stack
        }
        return ans;     // ans is the preorder traversal of the binary tree
    
    }
};

Preorder traversal of binary tree in c++ recursive solution  // time complexity O(N) and space complexity O(N)
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {  // root is the root of the binary tree
        vector<int> ans;        // ans is the preorder traversal of the binary tree
        if(root==NULL) return ans;      // if root is null then return ans
        ans.push_back(root->val);       // add the value of the root into the ans
        vector<int> left = preorderTraversal(root->left);     // left is the preorder traversal of the left subtree of the root
        vector<int> right = preorderTraversal(root->right);       // right is the preorder traversal of the right subtree of the root
        ans.insert(ans.end(),left.begin(),left.end());      // add the left into the ans
        ans.insert(ans.end(),right.begin(),right.end());        // add the right into the ans
        return ans;     // ans is the preorder traversal of the binary tree
    }


Preorder traversal of binary tree in java beslution  // time complexity O(N) and space complexity O(N) 
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {  // root is the root of the binary tree
        List<Integer> ans = new ArrayList<>();     // ans is the preorder traversal of the binary tree
        if(root==null) return ans;      // if root is null then return ans
        Stack<TreeNode> st = new Stack<>();        // st is the stack which stores the nodes of the binary tree 
        st.push(root);      // push the root into the stack
        while(!st.isEmpty()){       // while the stack is not empty
            TreeNode node = st.pop();       // node is the topmost node of the stack
            ans.add(node.val);      // add the value of the node into the ans
            if(node.right!=null) st.push(node.right);     // if the right child of the node is not null then push the right child into the stack
            if(node.left!=null) st.push(node.left);       // if the left child of the node is not null then push the left child into the stack
        }
        return ans;     // return ans
    }
}


Same tree in c++ best solution  
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {     // p is the root of the first binary tree and q is the root of the second binary tree   
        if(p==NULL && q==NULL) return true;      // if both the trees are null then return true
        if(p==NULL || q==NULL) return false;     // if one of the trees is null and the other is not null then return false
        if(p->val!=q->val) return false;        // if the value of the root of the first tree is not equal to the value of the root of the second tree then return false
        bool left = isSameTree(p->left,q->left);        // left is true if the left subtree of the first tree is equal to the left subtree of the second tree and false otherwise
        bool right = isSameTree(p->right,q->right);     // right is true if the right subtree of the first tree is equal to the right subtree of the second tree and false otherwise
        return left && right;       // return left && right   
        //Time  
    }
};

Same tree in java best solution  // time complexity O(N) and space complexity O(N)
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {     // p is the root of the first binary tree and q is the root of the second binary tree
        if(p==null && q==null) return true;      // if both the trees are null then return true
        if(p==null || q==null) return false;     // if one of the trees is null and the other is not null then return false
        if(p.val!=q.val) return false;      // if the value of the root of the first tree is not equal to the value of the root of the second tree then return false
        boolean left = isSameTree(p.left,q.left);        // left is true if the left subtree of the first tree is equal to the left subtree of the second tree and false otherwise
        boolean right = isSameTree(p.right,q.right);     // right is true if the right subtree of the first tree is equal to the right subtree of the second tree and false otherwise
        return left && right;       // return left && right
    }
};



Find if path exits in a graph in c++ using  dfs   // time complexity O(N+E) and space complexity O(N+E)

class Solution {
public:
    bool dfs(int node, vector<vector<int>>& adj, vector<bool>& vis, int end){     // node is the current node, adj is the adjacency list of the graph, vis is the vector which stores the visited nodes of the graph and end is the ending node
        if(node==end) return true;      // if the node is equal to the end then return true
        vis[node] = true;       // mark the node as visited
        for(auto child:adj[node]){      // for each child of the node
            if(!vis[child]){        // if the child is not visited
                if(dfs(child,adj,vis,end)) return true;     // if the dfs returns true then return true
            }
        }
        return false;       // return false
    }
    bool validPath(int n, vector<vector<int>>& edges, int start, int end) {     // n is the number of nodes in the graph, edges is the vector which stores the edges of the graph, start is the starting node and end is the ending node 
        vector<vector<int>> adj(n);     // adj is the adjacency list of the graph
        for(auto edge:edges){       // for each edge in the edges
            adj[edge[0]].push_back(edge[1]);        // add the edge[1] into the adj[edge[0]]
            adj[edge[1]].push_back(edge[0]);        // add the edge[0] into the adj[edge[1]]
        }
        vector<bool> vis(n,false);      // vis is the vector which stores the visited nodes of the graph
        return dfs(start,adj,vis,end);      // return the dfs
    }
};


Find if path exits in a graph in c++  using bfs  // time complexity O(N+E) and space complexity O(N+E)

class Solution {
public:
     bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {     // n is the number of nodes in the graph, edges is the vector which stores the edges of the graph, source is the starting node and destination is the ending node
        vector<vector<int>> adj(n);     // adj is the adjacency list of the graph   
        for(auto edge:edges){       // for each edge in the edges
            adj[edge[0]].push_back(edge[1]);        // add the edge[1] into the adj[edge[0]]
            adj[edge[1]].push_back(edge[0]);        // add the edge[0] into the adj[edge[1]]
        }
        vector<bool> vis(n,false);      // vis c the vector which stores the visited nodes of the graph
        queue<int> q;       // q is the queue which stores the nodes of the graph
        q.push(source);     // push the source into the queue
        vis[source] = true;     // mark the source as visited
        while(!q.empty()){      // while the queue is not empty
            int node = q.front();       // node is the frontmost node of the queue
            q.pop();        // pop the frontmost node of the queue
            if(node==destination) return true;      // if the node is equal to the destination then return true
            for(auto child:adj[node]){      // for each child of the node
                if(!vis[child]){        // if the child is not visited
                    q.push(child);      // push the child into the queue
                    vis[child] = true;      // mark the child as visited
                }
            }
        }
        return false;       // return false
    }
};



Find if path exits in a graph in java using dfs   // time complexity O(N+E) and space complexity O(N+E)

class Solution {
    public boolean dfs(int node, List<List<Integer>> adj, boolean[] vis, int end){     // node is the current node, adj is the adjacency list of the graph, vis is the vector which stores the visited nodes of the graph and end is the ending node
        if(node==end) return true;      // if the node is equal to the end then return true
        vis[node] = true;       // mark the node as visited
        for(int child:adj.get(node)){       // for each child of the node
            if(!vis[child]){        // if the child is not visited
                if(dfs(child,adj,vis,end)) return true;     // if the dfs returns true then return true
            }
        }
        return false;       // return false
    }
    public boolean validPath(int n, int[][] edges, int start, int end) {     // n is the number of nodes in the graph, edges is the vector which stores the edges of the graph, start is the starting node and end is the ending node
        List<List<Integer>> adj = new ArrayList<>();      // adj is the adjacency list of the graph
        for(int i=0;i<n;i++) adj.add(new ArrayList<>());      // add the empty list into the adj
        for(int[] edge:edges){      // for each edge in the edges
            adj.get(edge[0]).add(edge[1]);      // add the edge[1] into the adj[edge[0]]
            adj.get(edge[1]).add(edge[0]);      // add the edge[0] into the adj[edge[1]]
        }
        boolean[] vis = new boolean[n];     // vis is the vector which stores the visited nodes of the graph
        return dfs(start,adj,vis,end);      // return the dfs
    }
};

Find if path exits in a graph in java using bfs   // time complexity O(N+E) and space complexity O(N+E)

class Solution {
    public boolean validPath(int n, int[][] edges, int source, int destination) {     // n is the number of nodes in the graph, edges is the vector which stores the edges of the graph, source is the starting node and destination is the ending node
        List<List<Integer>> adj = new ArrayList<>();      // adj is the adjacency list of the graph   
        for(int i=0;i<n;i++) adj.add(new ArrayList<>());      // add the empty list into the adj
        for(int[] edge:edges){      // for each edge in the edges
            adj.get(edge[0]).add(edge[1]);      // add the edge[1] into the adj[edge[0]]
            adj.get(edge[1]).add(edge[0]);      // add the edge[0] into the adj[edge[1]]
        }
        boolean[] vis = new boolean[n];     // vis is the vector which stores the visited nodes of the graph
        Queue<Integer> q = new LinkedList<>();      // q is the queue which stores the nodes of the graph
        q.add(source);      // add the source into the queue
        vis[source] = true;     // mark the source as visited
        while(!q.isEmpty()){        // while the queue is not empty
            int node = q.poll();        // node is the frontmost node of the queue
            if(node==destination) return true;      // if the node is equal to the destination then return true
            for(int child:adj.get(node)){       // for each child of the node
                if(!vis[child]){        // if the child is not visited
                    q.add(child);       // add the child into the queue
                    vis[child] = true;      // mark the child as visited
                }
            }
        }
        return false;       // return false
    }
};


1443. Minimum Time to Collect All Apples in a Tree  in c++ best  Solution using map
class Solution { 
public:
    int dfs(vector<vector<int>>& g , int curr, int parent , vector<bool>& hasApple){
        int time = 0;
        for(auto child:g[curr]){
            if(child == parent){
                continue;
            }
            int time_from_my_child = dfs(g,child,curr,hasApple);  // time taken by my child to collect all apples
            if(time_from_my_child > 0 || hasApple[child]){  // Time complexity O(N+E) and Space Complexity O(N+E)
                time += time_from_my_child+2;
            }
        }
        return time;
    }
    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {
        vector<vector<int>> g(n);
        for(auto edge : edges){
            // int u = edge[0];
            // int v = edge[1];
            g[edge[0]].push_back(edge[1]);
            g[edge[1]].push_back(edge[0]);
        }
        return dfs(g , 0 , -1 , hasApple);
    }
};



1443. Minimum Time to Collect All Apples in a Tree  in java best  Solution 

class Solution { // Time Complexity O(N+E) and Space Complexity O(N+E)
    public int dfs(List<List<Integer>> map, List<Boolean> hasApple, int node, int parent) {
        int time = 0;
        for (int child : map.get(node)) {
            if (child == parent) {
                continue;
            }
            int timeFromMyChild = dfs(map, hasApple, child, node);
            if (timeFromMyChild > 0 || hasApple.get(child)) {
                time += timeFromMyChild + 2;
            }
        }
        return time;
    }
    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {
        List<List<Integer>> map = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            map.add(new ArrayList<>());
        }
        for (int[] edge : edges) {
            map.get(edge[0]).add(edge[1]);
            map.get(edge[1]).add(edge[0]);
        }

        return dfs(map, hasApple, 0, -1);
    }
   
};



Number of Nodes in the Sub-Tree With the Same Label in c++ best  Solution using map


class Solution {   
public:  //Time Complexity O(N+E) and Space Complexity O(N+E)
    vector<int> dfs(unordered_map<int , vector<int>>& g , int node , int parent ,vector<int>& result , string &labels){ // dfs function to find the number of nodes in the subtree with the same label
        vector<int> my_count(26,0);   // my_count is the vector which stores the count of the nodes in the subtree with the same label   
        my_count[labels[node]-'a']++;  // increment the count of the labels[node] by 1
        for(auto child:g[node]){  // for each child of the node
            if(child == parent){  // if the child is equal to the parent
                continue;  // continue
            }
            vector<int> child_count = dfs(g,child,node,result,labels);  // child_count is the vector which stores the count of the nodes in the subtree with the same label of the child
            for(int i=0;i<26;i++){  // for each character
                my_count[i] += child_count[i];  // increment the count of the character by the count of the character in the child_count
            }
        }
        result[node] = my_count[labels[node]-'a'];  // result[node] is the number of nodes in the subtree with the same label of the node
        return my_count;  // return the my_count
    }
    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {
        unordered_map<int , vector<int>> g;  // g is the graph
        for(auto edge:edges){  // for each edge in the edges
            g[edge[0]].push_back(edge[1]);  // add the edge[1] into the g[edge[0]]
            g[edge[1]].push_back(edge[0]);  // add the edge[0] into the g[edge[1]]
        }
        vector<int> result(n,0);  // result is the vector which stores the number of nodes in the subtree with the same label
        dfs(g,0,-1,result,labels);  // call the dfs function
        return result;  // return the result
    }
};


Number of Nodes in the Sub-Tree With the Same Label in java best  Solution

class Solution {  // Time Complexity O(N+E) and Space Complexity O(N+E)
    public int[] dfs(List<List<Integer>> map, int node, int parent, int[] result, String labels) { // dfs function to find the number of nodes in the subtree with the same label
        int[] myCount = new int[26];  // myCount is the array which stores the count of the nodes in the subtree with the same label
        myCount[labels.charAt(node) - 'a']++;  // increment the count of the labels.charAt(node) by 1
        for (int child : map.get(node)) {  // for each child of the node
            if (child == parent) {  // if the child is equal to the parent
                continue;  // continue
            }
            int[] childCount = dfs(map, child, node, result, labels);  // childCount is the array which stores the count of the nodes in the subtree with the same label of the child
            for (int i = 0; i < 26; i++) {  // for each character
                myCount[i] += childCount[i];  // increment the count of the character by the count of the character in the childCount
            }
        }
        result[node] = myCount[labels.charAt(node) - 'a'];  // result[node] is the number of nodes in the subtree with the same label of the node
        return myCount;  // return the myCount
    }
    public int[] countSubTrees(int n, int[][] edges, String labels) {
        List<List<Integer>> map = new ArrayList<>();  // map is the graph
        for (int i = 0; i < n; i++) {
            map.add(new ArrayList<>());
        }
        for (int[] edge : edges) {
            map.get(edge[0]).add(edge[1]);
            map.get(edge[1]).add(edge[0]);
        }
        int[] result = new int[n];  // result is the array which stores the number of nodes in the subtree with the same label
        dfs(map, 0, -1, result, labels);  // call the dfs function
        return result;  // return the result
    }

}

 Longest Path With Different Adjacent Characters in c++ best  Solution
Ist Approach
class Solution {    
    public:   // Time Complexity O(N+E) and Space Complexity O(N+E)
    vector<int> child[100001]; // child is the array which stores the child of the node
    int ans = 0;  // ans is the answer
    int dfs(int curr_node , string &s){  // dfs function to find the longest path with different adjacent characters
        int max1 = 0 , max2 = 0;  // max1 and max2 are the maximum length of the path with different adjacent characters
        for(auto child_node:child[curr_node]){  // for each child of the curr_node
            int len = dfs(child_node,s);  // len is the length of the path with different adjacent characters of the child_node
            if(len > max1){  // if the len is greater than the max1
                max2 = max1;  // update the max2
                max1 = len;  // update the max1
            }
            else if(len > max2){  // if the len is greater than the max2
                max2 = len;  // update the max2
            }
        }
        if(s[curr_node] != s[child[curr_node][0]]){  // if the curr_node is not equal to the child of the curr_node
            ans = max(ans , max1 + max2 + 1);  // update the ans
        }
        return max1 + 1;  // return the max1 + 1


    }
    int longestPath(vector<int>& parent , string &s){
        int n = parent.size();  // n is the number of nodes
        for(int i = 1 ; i < n ; i++){  // for each node
            child[parent[i]].push_back(i);  // add the i into the child[parent[i]]
        }

        dfs(0,s);  // call the dfs function
        return ans;  // return the ans

        
    }
};

2nd Approach 
class Solution{
    public:
    int longestPath(vector<int>& parent , string &s){
        int n = parent.size();  // n is the number of nodes
        vector<vector<int>> child(n);  // child is the array which stores the child of the node
        for(int i = 1 ; i < n ; i++){  // for each node
            child[parent[i]].push_back(i);  // add the i into the child[parent[i]]
        }
        int ans = 0;  // ans is the answer
        dfs(0,child,s,ans);  // call the dfs function
        return ans;  // return the ans


    }
    int dfs(int curr_node , vector<vector<int>> &child , string &s , int &ans){
        int max1 = 0 , max2 = 0;  // max1 and max2 are the maximum length of the path with different adjacent characters
        for(auto child_node:child[curr_node]){  // for each child of the curr_node
            int len = dfs(child_node,child,s,ans);  // len is the length of the path with different adjacent characters of the child_node
            if(s[curr_node] == s[child_node]) continue;  // if the curr_node is equal to the child_node then continue
            if(len > max2) max2 = len;  // update the max2
            if(max2 > max1) swap(max1,max2);  // if the max2 is greater than the max1 then swap the max1 and max2

           
    }
        ans = max(ans , max1 + max2 + 1);  // update the ans
        return max1 + 1;  // return the max1 + 1
 }
};
    
3rd Approach in C++ best Solution
class Solution{
    public:
    int ans;
    int dfs(unordered_map<int , vector<int>>& g , int curr_node , int parent , string& s){
        int longest = 0;
        int second_longest = 0;
        for(auto child : g[curr_node]){
            if(child == parent) continue;
            int child_longest_length = dfs(g , child  , curr_node , s);
            if(s[child] == s[curr_node]) continue;
            if(child_longest_length > second_longest) second_longest  = child_longest_length;
            if(second_longest > longest) swap(longest , second_longest);
            
        }
        int koi_ek_acha = max(longest , second_longest) + 1;
        int only_root_acha = 1;
        int niche_hi_milgya_answer = 1+longest+second_longest;
        ans = max({ans ,koi_ek_acha , only_root_acha , niche_hi_milgya_answer});
        return max(koi_ek_acha , only_root_acha);


    }
    int longestPath(vector<int>& parent , string s){
        int n = parent.size();
        unordered_map<int , vector<int>> g;
           ans = 0;
        for(int i=1; i<n; i++){
            g[parent[i]].push_back(i);
        }
     
        dfs(g , 0  , -1 , s);
        return ans;
    }
};

Longest Path With Different Adjacent Characters in java best  Solution

class Solution {  
    public int ans = 0;  // ans is the answer
    public int dfs(int curr_node, List<List<Integer>> map, String s) {  // dfs function to find the longest path with different adjacent characters
        int max1 = 0, max2 = 0;  // max1 and max2 are the maximum length of the path with different adjacent characters
        for (int child_node : map.get(curr_node)) {  // for each child of the curr_node
            int len = dfs(child_node, map, s);  // len is the length of the path with different adjacent characters of the child_node
            if (len > max1) {  // if the len is greater than the max1
                max2 = max1;  // update the max2
                max1 = len;  // update the max1
            } else if (len > max2) {  // if the len is greater than the max2
                max2 = len;  // update the max2
            }
        }
        if (s.charAt(curr_node) != s.charAt(map.get(curr_node).get(0))) {  // if the curr_node is not equal to the child of the curr_node
            ans = Math.max(ans, max1 + max2 + 1);  // update the ans
        }
        return max1 + 1;  // return the max1 + 1
    }
    public int longestPath(String s, int[][] edges) {
        List<List<Integer>> map = new ArrayList<>();  // map is the graph
        for (int i = 0; i < s.length(); i++) {
            map.add(new ArrayList<>());
        }
        for (int[] edge : edges) {
            map.get(edge[0]).add(edge[1]);
            map.get(edge[1]).add(edge[0]);
        }
        dfs(0, map, s);  // call the dfs function
        return ans;  // return the ans
        // Time Complexity O(N+E) and Space Complexity O(N+E)
    }
};

2nd Approach
class Solution {  
    public int ans = 0;  // ans is the answer
    public int dfs(int curr_node, List<List<Integer>> map, String s) {  // dfs function to find the longest path with different adjacent characters
        int max1 = 0, max2 = 0;  // max1 and max2 are the maximum length of the path with different adjacent characters
        for (int child_node : map.get(curr_node)) {  // for each child of the curr_node
            int len = dfs(child_node, map, s);  // len is the length of the path with different adjacent characters of the child_node
            if (s.charAt(curr_node) == s.charAt(child_node)) continue;  // if the curr_node is equal to the child_node then continue
            if (len > max2) max2 = len;  // update the max2
            if (max2 > max1) {  // if the max2 is greater than the max1
                int temp = max1;  // swap the max1 and max2
                max1 = max2;
                max2 = temp;
            }
        }
        ans = Math.max(ans, max1 + max2 + 1);  // update the ans
        return max1 + 1;  // return the max1 + 1
    }

    }
    public int longestPath(String s, int[] parent) {
        int n = parent.length;  // n is the number of nodes
        List<List<Integer>> map = new ArrayList<>();  // map is the graph
        for (int i = 1; i < n; i++) {  // for each node
            map.get(parent[i]).add(i);  // add the i into the map[parent[i]]
        }
        dfs(0, map, s);  // call the dfs function
        return ans;  // return the ans
        // Time Complexity O(N+E) and Space Complexity O(N+E)
    }
}

3rd Approach in java best Solution
class Solution{
    public int ans = 0; 
    public int dfs(int curr_node , List<List<Integer>> map , String s){
        int max1 = 0 , max2 = 0;  // max1 and max2 are the maximum length of the path with different adjacent characters
        for(int child_node : map.get(curr_node)){  // for each child of the curr_node
            int len = dfs(child_node, map, s);  // len is the length of the path with different adjacent characters of the child_node
            if(s.charAt(child_node) == s.charAt(curr_node)) continue;  // if the curr_node is equal to the child_node then continue
            if(len > max2) max2 = len;  // update the max2
            if(max2 > max1) {  // if the max2 is greater than the max1 then swap the max1 and max2
                int temp = max1;
                max1 = max2;
                max2 = temp;
            }
           
    }
        int koi_ek_acha = Math.max(max1 , max2) + 1;
        int only_root_acha = 1;
        int niche_hi_milgya_answer = 1+max1+max2;
        ans = Math.max(ans , Math.max(koi_ek_acha , Math.max(only_root_acha , niche_hi_milgya_answer)));  // update the ans
        return Math.max(koi_ek_acha , only_root_acha);  // return the max1 + 1
    }
    public int longestPath(int[] parent , String s){
        int n = parent.length;
        List<List<Integer>> map = new ArrayList<>();
        for(int i=0; i<n; i++){
            map.add(new ArrayList<>());
        }
        for(int i=1; i<n; i++){
            map.get(parent[i]).add(i);
        }
        dfs(0,s);
        return ans;
    }
};






Lexicographically Smallest Equivalent String in c++ using  Disjoint Set Union (DSU) and Path Compression Technique 
class Solution { 
public:  // Time Complexity O(N) and Space Complexity O(1)
    int find(vector<int>& parent, int x){ // find the parent of the node x and also do the path compression 
        if(parent[x] == x){  // if the parent of the node x is equal to the node x then return the node x
            return x;       
        }
        return parent[x] = find(parent, parent[x]); // else return the parent of the node x
    }
      

    string smallestEquivalentString(string s1, string s2, string baseStr) {  // function to find the lexicographically smallest equivalent string
        vector<int> parent(26);   // parent is the parent of the node i 
        for(int i=0; i<26; i++){  // initialize the parent of the node i to the node i 
            parent[i] = i;   // parent of the node i is the node i 
        }
        for(int i=0; i<s1.size(); i++){  // for each edge in the graph 
            int p1 = find(parent, s1[i]-'a');  // find the parent of the node s1[i]-'a' // what is the parent of the node s1[i]-'a'  // find the parent of the node s1[i]-'a' and also do the path compression
            int p2 = find(parent, s2[i]-'a'); // find the parent of the node s2[i]-'a'
            if(p1 < p2){   // if the parent of the node s1[i]-'a' is less than the parent of the node s2[i]-'a' then make the parent of the node s2[i]-'a' as the parent of the node s1[i]-'a' 
                parent[p2] = p1;  // parent of the node s2[i]-'a' is the parent of the node s1[i]-'a'
            }else{
                parent[p1] = p2;  // parent of the node s1[i]-'a' is the parent of the node s2[i]-'a'
            }
        }
        for(int i=0; i<baseStr.size(); i++){ // for each character in the baseStr 
            baseStr[i] = find(parent, baseStr[i]-'a') + 'a'; // find the parent of the node baseStr[i]-'a' and add 'a' to it to get the character
        }
        return baseStr;  // return the baseStr

        
    }

};


Lexicographically Smallest Equivalent String in c++ usind DFS

class Solution { // Time Complexity O(N+E) and Space Complexity O(N+E)
public:
    char dfs(vector<vector<int>>& adj, int node, vector<bool>& visited){
        visited[node] = true;
        char ch = node + 'a';
        for(int i=0; i<adj[node].size(); i++){
            if(!visited[adj[node][i]]){
                ch = min(ch, dfs(adj, adj[node][i], visited));
            }
        }
        return ch;
    }

    string smallestEquivalentString(string s1, string s2, string baseStr){
        int  n = s1.size();
        int m = baseStr.size();
        vector<vector<int>> adj(26);
        for(int i=0; i<n; i++){
            adj[s1[i]-'a'].push_back(s2[i]-'a');
            adj[s2[i]-'a'].push_back(s1[i]-'a');
        }
        string result;
        for(int i=0; i<m; i++){
            vector<bool> visited(26, false);
            char ch = dfs(adj, baseStr[i]-'a', visited);
            result += ch;
        }
        return result;
    }
};


    

Lexicographically Smallest Equivalent String in java
class Solution { // Time Complexity O(N) and Space Complexity O(1)
    public int find(int[] parent, int x){ // find the parent of the node x and also do the path compression 
        if(parent[x] == x){  // if the parent of the node x is equal to the node x then return the node x
            return x;       
        }
        return parent[x] = find(parent, parent[x]); // else return the parent of the node x   
    }
    public String smallestEquivalentString(String s1, String s2, String baseStr) {  // function to find the lexicographically smallest equivalent string
        int[] parent = new int[26];   // parent is the parent of the node i 
        for(int i=0; i<26; i++){  // initialize the parent of the node i to the node i 
            parent[i] = i;   // parent of the node i is the node i 
        }
        for(int i=0; i<s1.length(); i++){  // for each edge in the graph 
            int p1 = find(parent, s1.charAt(i)-'a');  // find the parent of the node s1[i]-'a'
            int p2 = find(parent, s2.charAt(i)-'a'); // find the parent of the node s2[i]-'a'
            if(p1 < p2){   // if the parent of the node s1[i]-'a' is less than the parent of the node s2[i]-'a' then make the parent of the node s2[i]-'a' as the parent of the node s1[i]-'a'      
                parent[p2] = p1;  // parent of the node s2[i]-'a' is the parent of the node s1[i]-'a'
            }else{
                parent[p1] = p2;  // parent of the node s1[i]-'a' is the parent of the node s2[i]-'a'
            }
        }
        StringBuilder sb = new StringBuilder();  // sb is the string builder
        for(int i=0; i<baseStr.length(); i++){ // for each character in the baseStr 
            sb.append((char)(find(parent, baseStr.charAt(i)-'a') + 'a')); // find the parent of the node baseStr[i]-'a' and add 'a' to it to get the character
        }
        return sb.toString();  // return the baseStr    
    }
};


Lexicographically Smallest Equivalent String in java using DFS

class Solution { // Time Complexity O(N+E) and Space Complexity O(N+E)
    public char dfs(List<Integer>[] adj, int node, boolean[] visited){
        visited[node] = true;
        char ch = (char)(node + 'a');
        for(int i=0; i<adj[node].size(); i++){
            if(!visited[adj[node].get(i)]){
                ch = (char)Math.min(ch, dfs(adj, adj[node].get(i), visited));
            }
        }
        return ch;
    }

    public String smallestEquivalentString(String s1, String s2, String baseStr){
        int  n = s1.length();
        int m = baseStr.length();
        List<Integer>[] adj = new ArrayList[26];
        for(int i=0; i<26; i++){
            adj[i] = new ArrayList<>();
        }
        for(int i=0; i<n; i++){
            adj[s1.charAt(i)-'a'].add(s2.charAt(i)-'a');
            adj[s2.charAt(i)-'a'].add(s1.charAt(i)-'a');b
        }
        StringBuilder sb = new StringBuilder();
        for(int i=0; i<m; i++){
            boolean[] visited = new boolean[26];
            char ch = dfs(adj, baseStr.charAt(i)-'a', visited);
            sb.append(ch);
        }
        return sb.toString();
    }
} 

        





Insert Interval in c++ using binary search

class Solution { // Time Complexity O(N) and Space Complexity O(1)
public:  // function to insert the interval in the vector of intervals
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {  // function to insert the interval in the vector of intervals
        int n = intervals.size();  // n is the size of the vector of intervals
        int start = newInterval[0]; // start is the start of the interval
        int end = newInterval[1]; // end is the end of the interval
        int i = 0; // i is the index of the interval
        vector<vector<int>> result;  // result is the vector of intervals after inserting the interval
        while(i<n && intervals[i][1] < start){  // while the end of the interval is less than the start of the interval
            result.push_back(intervals[i]);   // push the interval in the result    
            i++;                      // increment the index of the interval
        }
        while(i<n && intervals[i][0] <= end){       // while the start of the interval is less than or equal to the end of the interval
            start = min(start, intervals[i][0]);        // update the start of the interval
            end = max(end, intervals[i][1]);        // update the end of the interval
            i++;              // increment the in interval
        }
        result.push_back({start, end});     // push the interval in the result
        while(i<n){                         // while the index of the interval is less than the size of the vector of intervals
            result.push_back(intervals[i]);     // push the interval in the result
            i++;          // increment the index of the interval
        }
        return result;      // return the result
    }
};



Insert Interval in java using binary search 

1st approach
class Solution {  // Time Complexity O(N) and Space Complexity O(N)
    public int[][] insert(int[][] intervals, int[] newInterval) {  // function to insert the interval in the vector of intervals
        int n = intervals.length;  // n is the size of the vector of intervals
        int start  = newInterval[0];  // start is the start of the interval
        int end = newInterval[1];       // end is the end of the interval
        int i=0;
        List<int[]> result = new ArrayList<>();     // result is the vector of intervals after inserting the interval
        while(i<n && intervals[i][1]<start){        // while the end of the interval is less than the start of the interval     
            result.add(intervals[i]);       // push the interval in the result
            i++;
        }
        while(i<n && intervals[i][0]<=end){     // while the start of the interval is less than or equal to the end of the interval
            start = Math.min(start , intervals[i][0]);      // update the start of the interval
            end = Math.max(end , intervals[i][1]);      // update the end of the interval
            i++;        // increment the index of the interval
        }   
          result.add(new int[]{start, end});        // push the interval in the result  
        while(i<n){                 // while the index of the interval is less than the size of the vector of intervals
            result.add(intervals[i]);       // push the interval in the result
            i++;            // increment the index of the interval

        }
       int[][] ans = new int[result.size()][2];     // ans is the vector of intervals after inserting the interval
        for(int j=0; j<result.size(); j++){     // for each interval in the result
            ans[j] = result.get(j);     // push the interval in the ans
        }
        return ans;     // return the ans
    }
}


2nd approach
class Solution { // Time Complexity O(N) and Space Complexity O(1)
    public int[][] insert(int[][] intervals, int[] newInterval) { // function to insert the interval in the vector of intervals
       }
        while(i<n && intervals[i][0] <= end){ // while the start of the interval is less than or equal to the end of the interval
            start = Math.min(start, intervals[i][0]); // update the start of the interval
            end = Math.max(end, intervals[i][1]); // update the end of the interval
            i++; // increment the index of the interval
        }
        result.add(new int[]{start, end}); // push the interval in the result
        while(i<n){ // while the index of the interval is less than the size of the vector of intervals
            result.add(intervals[i]); // push the interval in the result
            i++; // increment the index of the interval
        }
          int n = intervals.length; // n is the size of the vector of intervals
        int start = newInterval[0]; // start is the start of the interval
        int end = newInterval[1]; // end is the end of the interval
        int i = 0; // i is the index of the interval
        List<int[]> result = new ArrayList<>(); // result is the vector of intervals after inserting the interval
        while(i<n && intervals[i][1] < start){ // while the end of the interval is less than the start of the interval
            result.add(intervals[i]); // push the interval in the result
            i++; // increment the index of the interval
       return result.toArray(new int[result.size()][]); // return the result
    }
}


Number of good paths in c++ using find , union and rank in c++


// Time Complexity : O(nlogn)  // n is the number of nodes in the graph

// Space Complexity : O(n)  // n is the number of nodes in the graph

// Did this code successfully run on Leetcode : Yes

// Any problem you faced while coding this : No

// Your code here along with comments explaining your approach


Intuition





// Approach

// 1. We will use the union find algorithm to find the number of good paths

// 2. We will use the adjacency list to store the graph

// 3. We will use the map of values to the nodes having that value to store the nodes having the same value

// 4. We will use the vector of boolean values to check if the node is active or not

// 5. We will use the vector of parents of the nodes having the value to store the parents of the nodes having the same value

// 6. We will use the rank to store the rank of the node


// 7. We will use the find function to find the parent of the node

// 8. We will use the union function to union the nodes

// 9. We will use the numberOfGoodPaths function to find the number of good paths





Number of good paths in c++ using find , union and rank in c++ 
class Solution {  // Time Complexity O(NlogN) and Space Complexity O(N)
public:  // function to find the number of good paths
    vector<int> parent;  // parent is the vector of parent of each node in the graph    
    vector<int> rank;   // rank is the vector of rank of each node in the graph 
    int find(int x){        // function to find the parent of the node  
        if(x == parent[x]){     // if the node is the parent of itself 
            return x;  // return the node 
        }
        return parent[x] = find(parent[x]);  // return the parent of the node 
    }
    void Union(int x ,int y){  // function to union the two nodes 
        int x_parent = find(x); // x_parent is the parent of the node x 
        int y_parent = find(y); // y_parent is the parent of the node y
        if(x_parent == y_parent){  // if the parent of the node x is equal to the parent of the node y
            return;         // return
        }
        if(rank[x_parent] > rank[y_parent]){   // if the rank of the parent of the node x is greater than the rank of the parent of the node y      
            parent[y_parent] = x_parent;  // make the parent of the node y as the parent of the node x
        }
        else if(rank[x_parent] < rank[y_parent]){  // if the rank of the parent of the node x is less than the rank of the parent of the node y
            parent[x_parent] = y_parent; // make the parent of the node x as the parent of the node y 
        }
        else{
            parent[x_parent] = y_parent;  // make the parent of the node x as the parent of the node y 
            rank[y_parent] += 1;  // increment the rank of the parent of the node y by 1 
        }

    }
    int numberOfGoodPaths(vector<int>& vals, vector<vector<int>>& edges) {  // function to find the number of good paths
        int n = vals.size();  // n is the size of the vector of values 
        parent.resize(n); // resize the parent vector to the size of the vector of values
        rank.resize(n , 1);  // resize the rank vector to the size of the vector of values and initialize all the ranks to 1 
        for(int i=0; i<n; i++){ // for each node in the graph 
            parent[i] = i; // make the parent of the node as itself
        }
        unordered_map<int , vector<int>> adj;  // adj is the adjacency list of the graph 
        for(vector<int> &vec: edges){ // for each edge in the graph 
            int u = vec[0];  // u is the source of the edge 
            int v = vec[1]; // v is the destination of the edge
            adj[u].push_back(v);  // push the destination of the edge in the adjacency list of the source of the edge
            adj[v].push_back(u); // push the source of the edge in the adjacency list of the destination of the edge
        }
        // val -> {nodes}
        map<int , vector<int>> val_to_nodes; // val_to_nodes is the map of values to the nodes having that value
        for(int i=0; i<n; i++){ // for each node in the graph 
            int value = vals[i];  // value is the value of the node     
            val_to_nodes[value].push_back(i); // push the node in the map of values to the nodes having that value
        }
        int result = n;  // result is the number of good paths
        vector<bool> is_active(n , false); // staring me saare nodes inactive hain  // is_active is the vector of boolean values to check if the node is active or not
        for(auto& it : val_to_nodes){ //   // for each value in the map of values to the nodes having that value
           vector<int> nodes = it.second; // nodes is the vector of nodes having the value 
             for(int &u : nodes){  // for each node in the vector of nodes having the value
                 for(int &v : adj[u]){  // for each node in the adjacency list of the node
                     if(is_active[v]){  // if the node is active
                         Union(u , v);  // union the node with the active node
                     }
                 }
                is_active[u] = true;  // make the node active
             }
           vector<int> tumhare_parents;  // tumhare_parents is the vector of parents of the nodes having the value
              for(int &u : nodes){   // for each node in the vector of nodes having the value
                int parent_kaun_hai = find(u);  // parent_kaun_hai is the parent of the node
                tumhare_parents.push_back(parent_kaun_hai); // push the parent of the node in the vector of parents of the nodes having the value
              }
            sort(tumhare_parents.begin() , tumhare_parents.end());  // sort the vector of pare nts of the nodes having the value
            int sz = tumhare_parents.size();  // sz is the size of the vector of parents of the nodes having the value
            for(int j=0; j<sz; j++){  // for each parent in the vector of parents of the nodes having the value
                long long count = 0;  // count is the number of nodes having the value
                int current_parent = tumhare_parents[j];  // current_parent is the parent of the node 
                while(j<sz && tumhare_parents[j] == current_parent){  // while the parent of the node is equal to the current parent
                    count++;  // increment the count by 1   
                    j++;        // increment the j by 1
                }
                j--;    // decrement the j by 1
                int formula_wala_ans = (count * (count - 1)) / 2;       // formula_wala_ans is the number of good paths
                result += formula_wala_ans;     // increment the result by the number of good paths
            }
        }
        return result;      // return the number of good paths
    }
};


2nd Solution

class UnionFind {
private:
    vector<int> parent, rank;

public:
    UnionFind(int size) {
        parent.resize(size);
        rank.resize(size, 0);
        for (int i = 0; i < size; i++) {
            parent[i] = i;
        }
    }
    int find(int x) {
        if (parent[x] != x) parent[x] = find(parent[x]);
        return parent[x];
    }
    void union_set(int x, int y) {
        int xset = find(x), yset = find(y);
        if (xset == yset) {
            return;
        } else if (rank[xset] < rank[yset]) {
            parent[xset] = yset;
        } else if (rank[xset] > rank[yset]) {
            parent[yset] = xset;
        } else {
            parent[yset] = xset;
            rank[xset]++;
        }
    }
};

class Solution {
public:
    int numberOfGoodPaths(vector<int>& vals, vector<vector<int>>& edges) {
        int n = vals.size();
        vector<vector<int>> adj(n);
        for (auto& edge : edges) {
            adj[edge[0]].push_back(edge[1]);
            adj[edge[1]].push_back(edge[0]);
        }
        // Mapping from value to all the nodes having the same value in non-descending order of values.
        map<int, vector<int>> valuesToNodes;
        for (int node = 0; node < n; node++) {
            valuesToNodes[vals[node]].push_back(node);
        }

        UnionFind dsu(n);
        int goodPaths = 0;

        // Iterate over all the nodes with the same value in sorted order, starting from the lowest
        // value.
        for (auto& [value, nodes] : valuesToNodes) {
            // For every node in nodes, combine the sets of the node and its neighbors into one set.
            for (int node : nodes) {
                for (int neighbor : adj[node]) {
                    // Only choose neighbors with a smaller value, as there is no point in
                    // traversing to other neighbors.
                    if (vals[node] >= vals[neighbor]) {
                        dsu.union_set(node, neighbor);
                    }
                }
            }
            // Map to compute the number of nodes under observation (with the same values) in each
            // of the sets.
            unordered_map<int, int> group;
            // Iterate over all the nodes. Get the set of each node and increase the count of the
            // set by 1.
            for (int u : nodes) {
                group[dsu.find(u)]++;
            }
            // For each set of "size", add size * (size + 1) / 2 to the number of goodPaths.
            for (auto& [_, size] : group) {
                goodPaths += (size * (size + 1) / 2);
            }
        }
        return goodPaths;
    }
};


3rd Solution

class Solution {
public:
    int findParent(vector<int>& parent, int x) {
        
        if(parent[x] == -1) return x;
        return parent[x] = findParent(parent, parent[x]);
    }
    
    int numberOfGoodPaths(vector<int>& vals, vector<vector<int>>& edges) {
        
        /*
        We first consider all n nodes as n separate trees. Any edge joins exactly 2 of these subtrees. 
        First of all, we need to sort edges vector based on the maximum value of vertices that it connects.
        Once sorted, we start looking at the edges one by one. At every iteration, we will connect 2 subtrees.
        Suppose the max elements in these 2 subtrees is a& b respectively and there frequency is 
        a_freq & b_freq respectively.
        
        If a==b, we have found a_freq*b_freq new paths. These paths have starting nodes in 1 subtree and ending
        nodes in the other subtree. Now we merge these two subtrees. 
        We set parent[b]=a, so a_freq=a_freq + b_freq.
        Suppose a!=b. In this case we have found no new paths. Assign parent of subtree with smaller max element
        to parent of subtree with larger max element.
        Continue this until we have covered all the edges.
        
        Why are we sorting the edges ?
        Suppose we have this structure: vals- [2,4,2] and edges- [[0,1],[0,2]]. If we don't sort in increasing
        order, we will first merge the nodes 2 & 4. This subtree will have max_element as 4 and count as 1. 
        Next we will consider the 2nd edge - [0,2]. This will now merge our spreviously formed subtree with 
        the node - 2. While merging, it will see that our previously formed subtree has maxelement 4. 
        Since the new node 2 has maxelement as 2, it will think that there are no new possible paths from one
        subtree to the other, but this is not true. 
        The 1st subtree has a 2 that can form a new path with this new node 2.
        Thus, we are sorting to ensure that whenever we are joining 2 subtrees, we have already taken into
        account all the possible paths starting and ending with a smaller maxelement
        */
        
        int n = vals.size();
        int m = edges.size();
        vector<int> parent(n, -1);
       
        sort(edges.begin(), edges.end(), [&](vector<int>& a, vector<int>& b) {
            int x = max(vals[a[0]], vals[a[1]]);
            int y = max(vals[b[0]], vals[b[1]]);
            return x < y;
        });
        
        int result = n;
        vector<int> paths(n, 1);
        
        for(int i=0 ; i<m ; i++) {
            
            int x = findParent(parent, edges[i][0]);
            int y = findParent(parent, edges[i][1]);
            
            if(vals[x] == vals[y]) {
                parent[x] = y;
                result += paths[x] * paths[y];
                paths[y] += paths[x];
            }
            else {
                if(vals[x] > vals[y]) parent[y] = x;
                else parent[x] = y;
            }
            
        }
       
        return result;
    }
};





Number of good paths in c++ using find , union and rank in Java

class UnionFind {
    int[] parent;
    int[] rank;

    public UnionFind(int size) {ss
        parent = new int[size];
        for (int i = 0; i < size; i++)
            parent[i] = i;
        rank = new int[size];
    }

    public int find(int x) {
        if (parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    }

    public void union_set(int x, int y) {
        int xset = find(x), yset = find(y);
        if (xset == yset) {
            return;
        } else if (rank[xset] < rank[yset]) {
            parent[xset] = yset;
        } else if (rank[xset] > rank[yset]) {
            parent[yset] = xset;
        } else {
            parent[yset] = xset;
            rank[xset]++;
        }
    }
}

class Solution {
    public int numberOfGoodPaths(int[] vals, int[][] edges) {
        Map<Integer, List<Integer>> adj = new HashMap<>();
        for (int[] edge : edges) {
            int a = edge[0], b = edge[1];
            adj.computeIfAbsent(a, value -> new ArrayList<Integer>()).add(b);
            adj.computeIfAbsent(b, value -> new ArrayList<Integer>()).add(a);
        }

        int n = vals.length;
        // Mapping from value to all the nodes having the same value in sorted order of
        // values.
        TreeMap<Integer, List<Integer>> valuesToNodes = new TreeMap<>();
        for (int i = 0; i < n; i++) {
            valuesToNodes.computeIfAbsent(vals[i], value -> new ArrayList<Integer>()).add(i);
        }

        UnionFind dsu = new UnionFind(n);
        int goodPaths = 0;

        // Iterate over all the nodes with the same value in sorted order, starting from
        // the lowest value.
        for (int value : valuesToNodes.keySet()) {
            // For every node in nodes, combine the sets of the node and its neighbors into
            // one set.
            for (int node : valuesToNodes.get(value)) {
                if (!adj.containsKey(node))
                    continue;
                for (int neighbor : adj.get(node)) {
                    // Only choose neighbors with a smaller value, as there is no point in
                    // traversing to other neighbors.
                    if (vals[node] >= vals[neighbor]) {
                        dsu.union_set(node, neighbor);
                    }
                }
            }
            // Map to compute the number of nodes under observation (with the same values)
            // in each of the sets.
            Map<Integer, Integer> group = new HashMap<>();
            // Iterate over all the nodes. Get the set of each node and increase the count
            // of the set by 1.
            for (int u : valuesToNodes.get(value)) {
                group.put(dsu.find(u), group.getOrDefault(dsu.find(u), 0) + 1);
            }
            // For each set of "size", add size * (size + 1) / 2 to the number of goodPaths.
            for (int key : group.keySet()) {
                int size = group.get(key);
                goodPaths += size * (size + 1) / 2;
            }
        }
        return goodPaths;
    }
}

2nd Solution


class Solution {
    public int numberOfGoodPaths(int[] vals, int[][] edges) {
        int n = vals.length;
        int m = edges.length;
        int[] parent = new int[n];
        Arrays.fill(parent, -1);
        Arrays.sort(edges, (a, b) -> {
            int x = Math.max(vals[a[0]], vals[a[1]]);
            int y = Math.max(vals[b[0]], vals[b[1]]);
            return x - y;
        });
        int result = n;
        int[] paths = new int[n];
        Arrays.fill(paths, 1);
        for(int i = 0; i < m; i++) {
            int x = findParent(parent, edges[i][0]);
            int y = findParent(parent, edges[i][1]);
            if(vals[x] == vals[y]) {
                parent[x] = y;
                result += paths[x] * paths[y];
                paths[y] += paths[x];
            }
            else {
                if(vals[x] > vals[y]) parent[y] = x;
                else parent[x] = y;
            }
        }
        return result;
    }
    public int findParent(int[] parent, int x) {
        if(parent[x] == -1) return x;
        return parent[x] = findParent(parent, parent[x]);
    }
}

926. Flip String to Monotone Increasing in c++

2 Approaches

// Time Complexity : O(n) where n is the length of the string and space complexity is O(1)

1st Approach
class Solution {
public:
    int minFlipsMonoIncr(string s) {        //  function to find the minimum number of flips to make the string monotone increasing
        int ans = 0 ,num = 0; // ans is the minimum number of flips to make the string monotone increasing and num is the number of 1's in the string
        for(char c:s){    // for each character in the string
            if(c == '0'){    // if the character is 0 
                ans = min(num , ans+1); // ans is the minimum of the number of 1's in the string and the number of flips to make the string monotone increasing
            }
            else{
                num++;      // increment the number of 1's in the string by 1
            }
        }
        return ans;

        
    }
};

2nd Approach
class Solution {

class Solution {
public:
    int minFlipsMonoIncr(string s) {    //  function to find the minimum number of flips to make the string monotone increasing
        int m = 0;    // m is the number of 0's in the string
        for(char c : s){   // for each character in the string
            if(c == '0'){       // if the character is 0
                m++;        // increment the number of 0's in the string by 1
            }
        }
        int ans  = m;       // ans is the minimum number of flips to make the string monotone increasing
        for(char c:s){          // for each character in the string
            if(c == '0'){           // if the character is 0
                ans = min(ans , --m);   // ans is the minimum of the number of 0's in the string and the number of flips to make the string monotone increasing
            }   
            else{       // if the character is 1
                m++;        // increment the number of 0's in the string by 1
            }
        }
        return ans;
    }
};

Flip String to Monotone Increasing in c++ using min in Java

2 Approaches

// Time Complexity : O(n) where n is the length of the string and space complexity is O(1)

1st Approach

class Solution {
    public int minFlipsMonoIncr(String s) {
       int ans = 0 , num = 0;  // ans is the minimum number of flips to make the string monotone increasing and num is the number of 1's in the string
        for(char c : s.toCharArray()){  // for each character in the string
            if(c == '0'){
                ans = Math.min(num , ans+1);  // ans is the minimum of the number of 1's in the string and the number of flips to make the string monotone increasing
            }
            else{
                num++;
            }
        }
        return ans;
    }
}

2nd Approach

class Solution {
    public int minFlipsMonoIncr(String s) {  // function to find the minimum number of flips to make the string monotone increasing
        int m= 0;
        for(int i=0; i<s.length(); i++){ // for each character in the string
            if(s.charAt(i) == '0'){  // if the character is 0
                m++;  // increment the number of 0's in the string 
            }
        }
        int ans = m;
        for(int i=0 ; i<s.length(); i++){       // for each character in the string
            if(s.charAt(i) == '0'){     // if the character is 0
                ans = Math.min(ans , --m);   // ans is the minimum of the number of 0's in the string and the number of flips to make the string monotone increasing
            }
            else{
                m++;        // increment the number of 0's in the string by 1
            }

        return  ans;
    }
}

918. Maximum Sum Circular Subarray in c++

// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)
class Solution {
public:
    int maxSubarraySumCircular(vector<int>& nums) {  // function to find the maximum sum of the circular subarray
        int n = nums.size();  // n is the length of the array
        int max_sum = INT_MIN;  // max_sum is the maximum sum of the circular subarray
        int min_sum = INT_MAX;  // min_sum is the minimum sum of the circular subarray
        int total_sum = 0;  // total_sum is the total sum of the array
        int curr_max = 0;  // curr_max is the current maximum sum of the subarray
        int curr_min = 0;  // curr_min is the current minimum sum of the subarray
        for(int i=0; i<n; i++){  // for each element in the array
            total_sum += nums[i];  // increment the total sum by the element
            curr_max = max(curr_max + nums[i] , nums[i]);  // curr_max is the maximum of the current maximum sum of the subarray and the element
            max_sum = max(max_sum , curr_max);  // max_sum is the maximum of the maximum sum of the circular subarray and the current maximum sum of the subarray  
            curr_min = min(curr_min + nums[i] , nums[i]);  // curr_min is the minimum of the current minimum sum of the subarray and the element
            min_sum = min(min_sum , curr_min);  // min_sum is the minimum of the minimum sum of the circular subarray and the current minimum sum of the subarray
        }
        if(max_sum < 0){  // if the maximum sum of the circular subarray is less than 0
            return max_sum;  // return the maximum sum of the circular subarray
        }
        return max(max_sum , total_sum - min_sum);  // return the maximum of the maximum sum of the circular subarray and the total sum of the array - the minimum sum of the circular subarray
    }
};

Maximum Sum Circular Subarray in c++ using max in Java

// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)
class Solution {
    public int maxSubarraySumCircular(int[] nums) {  // function to find the maximum sum of the circular subarray
        int n = nums.length;  // n is the length of the array
        int max_sum = Integer.MIN_VALUE;  // max_sum is the maximum sum of the circular subarray
        int min_sum = Integer.MAX_VALUE;  // min_sum is the minimum sum of the circular subarray
        int total_sum = 0;  // total_sum is the total sum of the array
        int curr_max = 0;  // curr_max is the current maximum sum of the subarray
        int curr_min = 0;  // curr_min is the current minimum sum of the subarray
        for(int i=0; i<n; i++){  // for each element in the array
            total_sum += nums[i];  // increment the total sum by the element
            curr_max = Math.max(curr_max + nums[i] , nums[i]);  // curr_max is the maximum of the current maximum sum of the subarray and the element
            max_sum = Math.max(max_sum , curr_max);  // max_sum is the maximum of the maximum sum of the circular subarray and the current maximum sum of the subarray
            curr_min = Math.min(curr_min + nums[i] , nums[i]);  // curr_min is the minimum of the current minimum sum of the subarray and the element
            min_sum = Math.min(min_sum , curr_min);  // min_sum is the minimum of the minimum sum of the circular subarray and the current minimum sum of the subarray
        }
        if(max_sum < 0){  // if the maximum sum of the circular subarray is less than 0
            return max_sum;  // return the maximum sum of the circular subarray
        }
        return Math.max(max_sum , total_sum - min_sum);  // return the maximum of the maximum sum of the circular subarray and the total sum of the array - the minimum sum of the circular subarray
    }
}


974. Subarray Sums Divisible by K


class Solution {
public:
    int subarraysDivByK(vector<int>& nums, int k) {
      int prefixMod = 0 , result = 0;
      int n = nums.size();
      vector<int> modgroups(k);
      modgroups[0] = 1;
      for(int num : nums){
          prefixMod = (prefixMod + num%k +k) % k;
          result +=  modgroups[prefixMod];
          modgroups[prefixMod]++;
      } 
        return result;
    }
};

974. Subarray Sums Divisible by K in java

class Solution {
    public int subarraysDivByK(int[] nums, int k) {
        int n = nums.length;
        int prefixMod = 0 , result = 0;
        int[] modgroups = new int[k];
        modgroups[0] = 1;
        for(int num : nums){
            prefixMod = (prefixMod + num%k + k)%k;
            result += modgroups[prefixMod];
            modgroups[prefixMod]++;

        }
        return result;
    }
}

491. Non-decreasing Subsequences in  c++ another  Solution

// Time Complexity : O(n^2) where n is the length of the array and space complexity is O(n)
class Solution {
    public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {  // function to find the non-decreasing subsequences
        int n = nums.size();  // n is the length of the array
        vector<vector<int>> ans;  // ans is the vector of vectors to store the non-decreasing subsequences
        vector<int> temp;  // temp is the vector to store the current non-decreasing subsequence
        findSubsequences(nums , ans , temp , 0);  // function call to find the non-decreasing subsequences
        return ans;  // return the vector of vectors of the non-decreasing subsequences
    }
    void findSubsequences(vector<int>& nums , vector<vector<int>>& ans , vector<int>& temp , int index){  // function to find the non-decreasing subsequences
        if(temp.size() >= 2){  // if the size of the current non-decreasing subsequence is greater than or equal to 2
            ans.push_back(temp);  // push the current non-decreasing subsequence into the vector of vectors of the non-decreasing subsequences
        }
        unordered_set<int> s;  // s is the set to store the elements of the current non-decreasing subsequence
        for(int i=index; i<nums.size(); i++){  // for each element in the array
            if(s.find(nums[i]) != s.end()){  // if the element is already present in the set
                continue;  // continue
            }
            if(temp.size() == 0 || nums[i] >= temp.back()){  // if the size of the current non-decreasing subsequence is 0 or the element is greater than or equal to the last element of the current non-decreasing subsequence
                temp.push_back(nums[i]);  // push the element into the current non-decreasing subsequence
                s.insert(nums[i]);  // insert the element into the set
                findSubsequences(nums , ans , temp , i+1);  // function call to find the non-decreasing subsequences
                temp.pop_back();  // pop the last element from the current non-decreasing subsequence
            }
        }
    }
};

491. Non-decreasing Subsequences in Java

class Solution {
    public List<List<Integer>> findSubsequences(int[] nums) {  // function to find the non-decreasing subsequences
        int n = nums.length;  // n is the length of the array
        List<List<Integer>> ans = new ArrayList<>();  // ans is the list of lists to store the non-decreasing subsequences
        List<Integer> temp = new ArrayList<>();  // temp is the list to store the current non-decreasing subsequence
        findSubsequences(nums , ans , temp , 0);  // function call to find the non-decreasing subsequences
        return ans;  // return the list of lists of the non-decreasing subsequences
    }
    void findSubsequences(int[] nums , List<List<Integer>> ans , List<Integer> temp , int index){  // function to find the non-decreasing subsequences
        if(temp.size() >= 2){  // if the size of the current non-decreasing subsequence is greater than or equal to 2
            ans.add(new ArrayList<>(temp));  // add the current non-decreasing subsequence into the list of lists of the non-decreasing subsequences
        }
        Set<Integer> s = new HashSet<>();  // s is the set to store the elements of the current non-decreasing subsequence
        for(int i=index; i<nums.length; i++){  // for each element in the array
            if(s.contains(nums[i])){  // if the element is already present in the set
                continue;  // continue
            }
            if(temp.size() == 0 || nums[i] >= temp.get(temp.size()-1)){  // if the size of the current non-decreasing subsequence is 0 or the element is greater than or equal to the last element of the current non-decreasing subsequence
                temp.add(nums[i]);  // add the element into the current non-decreasing subsequence
                s.add(nums[i]);  // add the element into the set
                findSubsequences(nums , ans , temp , i+1);  // function call to find the non-decreasing subsequences
                temp.remove(temp.size()-1);  // remove the last element from the current non-decreasing subsequence
            }
        }
    }

}

93. Restore IP Addresses in C++

// Time Complexity : O(3^4) where n is the length of the string and space complexity is O(n)
class Solution {
public:
    vector<string> restoreIpAddresses(string s) {  // function to restore the IP addresses
        vector<string> ans;  // ans is the vector to store the IP addresses
        restoreIpAddresses(s , ans , "" , 0 , 0);  // function call to restore the IP addresses
        return ans;  // return the vector of IP addresses
    }
    void restoreIpAddresses(string s , vector<string>& ans , string temp , int index , int count){  // function to restore the IP addresses
        if(count > 4){  // if the count is greater than 4
            return;  // return
        }
        if(count == 4 && index == s.length()){  // if the count is 4 and the index is equal to the length of the string
            ans.push_back(temp);  // push the current IP address into the vector of IP addresses
        }
        for(int i=1; i<=3; i++){  // for each length of the substring
            if(index+i > s.length()){  // if the index is greater than the length of the string
                break;  // break
            }
            string sub = s.substr(index , i);  // sub is the substring
            if((sub[0] == '0' && sub.length() > 1) || (i == 3 && stoi(sub) > 255)){  // if the substring is 0 or the length of the substring is 3 and the substring is greater than 255
                continue;  // continue
            }
            restoreIpAddresses(s , ans , temp + sub + (count == 3 ? "" : ".") , index+i , count+1);  // function call to restore the IP addresses
        }
    }
};





93. Restore IP Addresses in Java another  Solution

// Time Complexity : O(3^4) where n is the length of the string and space complexity is O(n)

class Solution {
    public List<String> restoreIpAddresses(String s) {  // function to restore the IP addresses
        List<String> ans = new ArrayList<>();  // ans is the list to store the IP addresses
        restoreIpAddresses(s , ans , "" , 0 , 0);  // function call to restore the IP addresses
        return ans;  // return the list of IP addresses
    }
    void restoreIpAddresses(String s , List<String> ans , String temp , int index , int count){  // function to restore the IP addresses
        if(count > 4){  // if the count is greater than 4
            return;  // return
        }
        if(count == 4 && index == s.length()){  // if the count is 4 and the index is equal to the length of the string
            ans.add(temp);  // add the current IP address into the list of IP addresses
        }
        for(int i=1; i<=3; i++){  // for each length of the substring
            if(index+i > s.length()){  // if the index is greater than the length of the string
                break;  // break
            }
            String sub = s.substring(index , index+i);  // sub is the substring
            if((sub.charAt(0) == '0' && sub.length() > 1) || (i == 3 && Integer.parseInt(sub) > 255)){  // if the substring is 0 or the length of the substring is 3 and the substring is greater than 255
                continue;  // continue
            }
            restoreIpAddresses(s , ans , temp + sub + (count == 3 ? "" : ".") , index+i , count+1);  // function call to restore the IP addresses
        }
    }
}

131. Palindrome Partitioning in c++

// Time Complexity : O(2^n) where n is the length of the string and space complexity is O(n)

class Solution {
public:
    vector<vector<string>> partition(string s) {  // function to partition the string into palindrome partitions
        vector<vector<string>> ans;  // ans is the vector to store the palindrome partitions
        partition(s , ans , 0 , {});  // function call to partition the string into palindrome partitio
        return ans;  // return the vector of palindrome partitions
    }
    void partition(string s , vector<vector<string>>& ans , int index , vector<string> temp){  // function to partition the string into palindrome partitions
        if(index == s.length()){  // if the index is equal to the length of the string
            ans.push_back(temp);  // push the current palindrome partition into the vector of palindrome partitions
            return;  // return
        }
        for(int i=index; i<s.length(); i++){  // for each length of the substring
            if(isPalindrome(s , index , i)){  // if the substring is a palindrome
                temp.push_back(s.substr(index , i-index+1));  // push the substring into the current palindrome partition
                partition(s , ans , i+1 , temp);  // function call to partition the string into palindrome partitions
                temp.pop_back();  // pop the last element from the current palindrome partition
            }
        }
    }
    bool isPalindrome(string s , int start , int end){  // function to check if the substring is a palindrome
        while(start < end){  // while the start is less than the end
            if(s[start] != s[end]){  // if the characters at the start and end are not equal
                return false;  // return false
            }
            start++;  // increment the start
            end--;  // decrement the end
        }
        return true;  // return true
    }
};

131. Palindrome Partitioning  in  java

// Time Complexity : O(2^n) where n is the length of the string and space complexity is O(n)

class Solution {
    public List<List<String>> partition(String s) {  // function to partition the string into palindrome partitions
        List<List<String>> ans = new ArrayList<>();  // ans is the list to store the palindrome partitions
        partition(s , ans , 0 , new ArrayList<>());  // function call to partition the string into palindrome partitions
        return ans;  // return the list of palindrome partitions
    }
    void partition(String s , List<List<String>> ans , int index , List<String> temp){  // function to partition the string into palindrome partitions  
        if(index == s.length()){  // if the index is equal to the length of the string
            ans.add(new ArrayList<>(temp));  // add the current palindrome partition into the list of palindrome partitions
            return;  // return
        }
        for(int i=index; i<s.length(); i++){  // for each length of the substring
            if(isPalindrome(s , index , i)){  // if the substring is a palindrome
                temp.add(s.substring(index , i+1));  // add the substring into the current palindrome partition
                partition(s , ans , i+1 , temp);  // function call to partition the string into palindrome partitions
                temp.remove(temp.size()-1);  // remove the last element from the current palindrome partition
            }
        }
    }
    boolean isPalindrome(String s , int start , int end){  // function to check if the substring is a palindrome
        while(start < end){  // while the start is less than the end
            if(s.charAt(start) != s.charAt(end)){  // if the characters at the start and end are not equal
                return false;  // return false
            }
            start++;  // increment the start
            end--;  // decrement the end
        }
        return true;  // return true
    }
}



997. Find the Town Judge in c++

// Time Complexity : O(n) where n is the number of trust relations and space complexity is O(n)
class Solution {
public:
    int findJudge(int N, vector<vector<int>>& trust) {  // function to find the town judge
        vector<int> indegree(N+1) , outdegree(N+1);  // indegree and outdegree vectors to store the indegree and outdegree of each person
        for(auto t : trust){  // for each trust relation
            outdegree[t[0]]++;  // increment the outdegree of the person who trusts
            indegree[t[1]]++;  // increment the indegree of the person who is trusted
        }
        for(int i=1; i<=N; i++){  // for each person
            if(indegree[i] == N-1 && outdegree[i] == 0){  // if the indegree of the person is N-1 and the outdegree of the person is 0
                return i;  // return the person
            }
        }
        return -1;  // return -1 if the town judge is not found
    }
};

Another Solution in C++
class Solution {
public:
    int findJudge(int n, vector<vector<int>>& trust) {
        vector<int> trustCount(n+1);
        for(auto t:trust){
            trustCount[t[0]]--;
            trustCount[t[1]]++;
        }
        for(int i=1; i<=n; i++){
            if(trustCount[i] == n-1){
                return i;
            }
        }
        return -1;
    }
};



997. Find the Town Judge in Java

class Solution {
    public int findJudge(int N, int[][] trust) {  // function to find the town judge
        int[] indegree = new int[N+1];  // indegree array to store the indegree of each person
        int[] outdegree = new int[N+1];  // outdegree array to store the outdegree of each person
        for(int[] t : trust){  // for each trust relation
            outdegree[t[0]]++;  // increment the outdegree of the person who trusts
            indegree[t[1]]++;  // increment the indegree of the person who is trusted
        }
        for(int i=1; i<=N; i++){  // for each person
            if(indegree[i] == N-1 && outdegree[i] == 0){  // if the indegree of the person is N-1 and the outdegree of the person is 0
                return i;  // return the person
            }
        }
        return -1;  // return -1 if the town judge is not found
    }
}
Another Solution in Java
class Solution {
    public int findJudge(int N, int[][] trust) {
        int[] trustCount = new int[N+1];
        for(int[] t : trust){
            trustCount[t[0]]--;
            trustCount[t[1]]++;
        }
        for(int i=1; i<=N; i++){
            if(trustCount[i] == N-1){
                return i;
            }
        }
        return -1;
    }

}


909. Snakes and Ladders in C++

// Time Complexity : O(n^2) where n is the number of rows and columns and space complexity is O(n^2)\


class Solution {
public:
    int snakesAndLadders(vector<vector<int>>& board) {  // function to find the minimum number of moves to reach the last square
        int n = board.size();  // n is the number of rows and columns
        vector<int> moves(n*n+1);  // moves vector to store the moves
        int i = n-1 , j = 0 , even = 0;  // i and j are the row and column indices and even is the variable to check if the row is even or odd
        for(int k=1; k<=n*n; k++){  // for each square
            moves[k] = board[i][j];  // store the value of the square in the moves vector
            if(even % 2 == 0){  // if the row is even
                j++;  // increment the column index
            }
            else{  // if the row is odd
                j--;  // decrement the column index
            }
            if(j == n){  // if the column index is equal to the number of rows and columns
                i--;  // decrement the row index
                j--;  // decrement the column index
                even++;  // increment the even variable
            }
            else if(j == -1){  // if the column index is -1
                i--;  // decrement the row index
                j++;  // increment the column index
                even++;  // increment the even variable
            }
        }
        queue<int> q;  // queue to store the moves
        q.push(1);  // push the first square into the queue
        vector<bool> visited(n*n+1);  // visited vector to check if the square is visited or not
        visited[1] = true;  // mark the first square as visited
        int count = 0;  // count is the variable to store the number of moves
        while(!q.empty()){  // while the queue is not empty
            int size = q.size();  // size is the size of the queue
            for(int k=0; k<size; k++){  // for each square in the queue
                int curr = q.front();  // curr is the current square
                q.pop();  // pop the current square from the queue
                if(curr == n*n){  // if the current square is the last square
                    return count;  // return the count
                }
                for(int i=1; i<=6; i++){  // for each dice roll
                    int next = curr + i;  // next is the next square
                    if(next > n*n){  // if the next square is greater than the last square
                        break;  // break
                    }
                    if(moves[next] != -1){  // if the next square is not a snake or ladder
                        next = moves[next];  // next is the next square
                    }
                    if(!visited[next]){  // if the next square is not visited
                        visited[next] = true;  // mark the next square as visited
                        q.push(next);  // push the next square into the queue
                    }
                }
            }
            count++;  // increment the count
        }
        return -1;  // return -1 if the last square is not reached
    }
};


909. Snakes and Ladders in Java

// Time Complexity : O(n^2) where n is the number of rows and columns and space complexity is O(n^2)

class Solution {
    public int snakesAndLadders(int[][] board) {  // function to find the minimum number of moves to reach the last square
        int n = board.length;  // n is the number of rows and columns
        int[] moves = new int[n*n+1];  // moves array to store the moves
        int i = n-1 , j = 0 , even = 0;  // i and j are the row and column indices and even is the variable to check if the row is even or odd
        for(int k=1; k<=n*n; k++){  // for each square
            moves[k] = board[i][j];  // store the value of the square in the moves array
            if(even % 2 == 0){  // if the row is even
                j++;  // increment the column index
            }
            else{  // if the row is odd
                j--;  // decrement the column index
            }
            if(j == n){  // if the column index is equal to the number of rows and columns
                i--;  // decrement the row index
                j--;  // decrement the column index
                even++;  // increment the even variable
            }
            else if(j == -1){  // if the column index is -1
                i--;  // decrement the row index
                j++;  // increment the column index
                even++;  // increment the even variable
            }
        }
        Queue<Integer> q = new LinkedList<>();  // queue to store the moves
        q.add(1);  // add the first square into the queue
        boolean[] visited = new boolean[n*n+1];  // visited array to check if the square is visited or not
        visited[1] = true;  // mark the first square as visited
        int count = 0;  // count is the variable to store the number of moves
        while(!q.isEmpty()){  // while the queue is not empty
            int size = q.size();  // size is the size of the queue
            for(int k=0; k<size; k++){  // for each square in the queue
                int curr = q.poll();  // curr is the current square
                if(curr == n*n){  // if the current square is the last square
                    return count;  // return the count
                }
                for(int l=1; l<=6; l++){  // for each dice roll
                    int next = curr + l;  // next is the next square
                    if(next > n*n){  // if the next square is greater than the last square
                        break;  // break
                    }
                    if(moves[next] != -1){  // if the next square is not a snake or ladder
                        next = moves[next];  // next is the next square
                    }
                    if(!visited[next]){  // if the next square is not visited
                        visited[next] = true;  // mark the next square as visited
                        q.add(next);  // add the next square into the queue
                    }
                }
            }
            count++;  // increment the count
        }
        return -1;  // return -1 if the last square is not reached
    }
}

2359. Find Closest Node to Given Two Nodes best Solution  USING DFS in c++

// Time Complexity : O(n) where n is the number of nodes and space complexity is O(n)

class Solution {
public:
    void dfs(int node, vector<int>& edges, vector<int>& dist, vector<bool>& visit) { 
        visit[node] = true; 
        int neighbor = edges[node];
        if (neighbor != -1 && !visit[neighbor]) {
            dist[neighbor] = 1 + dist[node];
            dfs(neighbor, edges, dist, visit);
        }
    }

    int closestMeetingNode(vector<int>& edges, int node1, int node2) {
        int n = edges.size();
        int ans = -1;
        int minDist = INT_MAX;
        vector<int> dist1(n, 0), dist2(n, 0);
        vector<bool> visit1(n), visit2(n);
        dist1[node1] = 0, dist2[node2] = 0;

        dfs(node1, edges, dist1, visit1);
        dfs(node2, edges, dist2, visit2);
    
          for(int currNode = 0; currNode < n; currNode++){
            if(visit1[currNode] == true && visit2[currNode] == true && minDist > max(dist1[currNode], dist2[currNode])){
                minDist = max(dist1[currNode], dist2[currNode]);
                ans = currNode;
            }
        }
        return ans;
    }
};


2359. Find Closest Node to Given Two Nodes best Solution  USING BFS in c++

// Time Complexity : O(n) where n is the number of nodes and space complexity is O(n)

class Solution {
public:
    void bfs(int startNode, vector<int>& edges, vector<int>& dist ,  vector<bool>& visit) {
        int n = edges.size();
        queue<int> q;
        q.push(startNode);

       
        dist[startNode] = 0;

        while (!q.empty()) {
            int node = q.front();
            q.pop();

            if (visit[node]) {
                continue;
            }

            visit[node] = true;
            int neighbor = edges[node];
            if (neighbor != -1 && !visit[neighbor]) {
                dist[neighbor] = 1 + dist[node];
                q.push(neighbor);
            }
        }
    }
        int closestMeetingNode(vector<int>& edges, int node1, int node2) {
        int n = edges.size();
        int ans = -1;
        int minDist = INT_MAX;
        vector<int> dist1(n, 0), dist2(n, 0);
        vector<bool> visit1(n), visit2(n);
        dist1[node1] = 0;
        dist2[node2] = 0;
        bfs(node1, edges, dist1, visit1);
        bfs(node2, edges, dist2, visit2);
        for(int currNode = 0; currNode<n; currNode++){
            if(visit1[currNode] ==  true && visit2[currNode] == true && minDist > max(dist1[currNode] , dist2[currNode])){
                minDist = max(dist1[currNode] , dist2[currNode]);
                ans = currNode;
            }
        }
        return ans;
    }
};

2359. Find Closest Node to Given Two Nodes best Solution  USING DFS in Java

// Time Complexity : O(n) where n is the number of nodes and space complexity is O(n)

class Solution {
    public int closestMeetingNode(int[] edges, int node1, int node2) {
        int n = edges.length;
        int ans = -1;
        int minDist = Integer.MAX_VALUE;
        int[] dist1 = new int[n];
        int[] dist2 = new int[n];
        boolean[] visit1 = new boolean[n];
        boolean[] visit2 = new boolean[n];
        dist1[node1] = 0;
        dist2[node2] = 0;
        dfs(node1, edges, dist1, visit1);
        dfs(node2, edges, dist2, visit2);
        for(int currNode = 0; currNode<n; currNode++){
            if(visit1[currNode] ==  true && visit2[currNode] == true && minDist > Math.max(dist1[currNode] , dist2[currNode])){
                minDist = Math.max(dist1[currNode] , dist2[currNode]);
                ans = currNode;
            }
        }
        return ans;
    }
    public void dfs(int node, int[] edges, int[] dist, boolean[] visit) { 
        visit[node] = true; 
        int neighbor = edges[node];
        if (neighbor != -1 && !visit[neighbor]) {
            dist[neighbor] = 1 + dist[node];
            dfs(neighbor, edges, dist, visit);
        }
    }
}


2359. Find Closest Node to Given Two Nodes best Solution  USING BFS in Java

// Time Complexity : O(n) where n is the number of nodes and space complexity is O(n)

class Solution {
    public int closestMeetingNode(int[] edges, int node1, int node2) {
        int n = edges.length; 
        int ans = -1;
        int minDist = Integer.MAX_VALUE;
        int[] dist1 = new int[n];
        int[] dist2 = new int[n];
        boolean[] visit1 = new boolean[n];
        boolean[] visit2 = new boolean[n];
        dist1[node1] = 0;
        dist2[node2] = 0;
        bfs(node1, edges, dist1, visit1);
        bfs(node2, edges, dist2, visit2);
        for(int currNode = 0; currNode<n; currNode++){
            if(visit1[currNode] ==  true && visit2[currNode] == true && minDist > Math.max(dist1[currNode] , dist2[currNode])){
                minDist = Math.max(dist1[currNode] , dist2[currNode]);
                ans = currNode;
            }
        }
        return ans;
    }
    public void bfs(int startNode, int[] edges, int[] dist ,  boolean[] visit) {
        int n = edges.length;
        Queue<Integer> q = new LinkedList<>();
        q.add(startNode);

       
        dist[startNode] = 0;

        while (!q.isEmpty()) {
            int node = q.poll();

            if (visit[node]) {
                continue;
            }

            visit[node] = true;
            int neighbor = edges[node];
            if (neighbor != -1 && !visit[neighbor]) {
                dist[neighbor] = 1 + dist[node];
                q.add(neighbor);
            }
        }
    }
}

787. Cheapest Flights Within K Stops in c++ Using BFS

// Time Complexity : O(n^2) where n is the number of flights and space complexity is O(n)

class Solution {
public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        vector<vector<pair< int , int>>> g(n);
        for(auto& e : flights){
           g[e[0]].push_back({e[1], e[2]});
        }
        vector<int> dist(n , INT_MAX);
        queue<pair<int , int>> q;
        q.push({src , 0});
        int stops = 0;
        while(stops <=k && !q.empty()){
            int sz = q.size();
            while(sz--){
            auto [node,distance] = q.front();
            q.pop();
            for(auto[child , price] : g[node]){
                if(price + distance >= dist[child]) continue;
                dist[child] = price + distance;
                q.push({child, dist[child]});
            }
            }
            stops++;
        }
        return dist[dst] == INT_MAX ? -1 : dist[dst];

    }
};


787. Cheapest Flights Within K Stops in java  using BFS

// Time Complexity : O(n^2) where n is the number of flights and space complexity is O(n)

class Solution {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
        int[] dist = new int[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[src] = 0;
        for (int i = 0; i <= K; i++) {
            int[] temp = new int[n];
            System.arraycopy(dist, 0, temp, 0, n);
            for (int[] flight : flights) {
                int u = flight[0], v = flight[1], w = flight[2];
                if (dist[u] != Integer.MAX_VALUE) {
                    temp[v] = Math.min(temp[v], dist[u] + w);
                }
            }
            dist = temp;
        }
        return dist[dst] == Integer.MAX_VALUE ? -1 : dist[dst];
    }
}



472. Concatenated Words in c++

// Time complexity: O(M^3.N) and Space complexity : O(N.M)

class Solution {
public:
    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
        unordered_set<string> dictionary(words.begin() , words.end());
        vector<string> answer;
        for(const auto word : words){
            const int length = word.length();
            vector<bool> dp(length + 1);
            dp[0] = true;
            for(int i=1; i<=length; i++){
                for(int j = (i == length ? 1 : 0) ; !dp[i] && j<i; j++){
                    dp[i] = dp[j] && dictionary.count(word.substr(j , i-j));
                }
            }
            if(dp[length]){
                answer.push_back(word);
            }
        }
        return answer;
    }
};

472. Concatenated Words in java

// Time complexity: O(M^3.N) and Space complexity : O(N.M)
class Solution {
    public List<String> findAllConcatenatedWordsInADict(String[] words) {
        Set<String> dictionary = new HashSet<>(Arrays.asList(words));
        List<String> answer = new ArrayList<>();
        for(String word : words){
            int length = word.length();
            boolean[] dp = new boolean[length + 1];
            dp[0] = true;
            for(int i=1; i<=length; i++){
                for(int j = (i == length ? 1:0) ; !dp[i] && j<i; j++){
                    dp[i] = dp[j] && dictionary.contains(word.substring(j , i));
                }
            } 
            if(dp[length]){
                answer.add(word);
            }
       }
       return answer;
    }
}


352. Data Stream as Disjoint Intervals in C++

Time Comlexity : O(log(N)) for addNum, O(N) for getIntervals.
Space Complexity : O(n)

class SummaryRanges {
    set<int> values;

public:
    SummaryRanges() {}

    void addNum(int value) { values.insert(value); }

    vector<vector<int>> getIntervals() {
        if (values.empty()) {
            return {};
        }
        vector<vector<int>> intervals;
        int left = -1, right = -1;
        for (int value : values) {
            if (left < 0) {
                left = right = value;
            } else if (value == right + 1) {
                right = value;
            } else {
                intervals.push_back({left, right});
                left = right = value;
            }
        }
        intervals.push_back({left, right});
        return intervals;
    }
};

352. Data Stream as Disjoint Intervals in Java

Time Comlexity : O(log(N)) for addNum, O(N) for getIntervals.
Space Complexity : O(n)

1st Method

class SummaryRanges {
    private TreeMap<Integer, Integer> intervals;

    public SummaryRanges() {
        intervals = new TreeMap<>(); 
    }
    
    public void addNum(int value) {
        final Map.Entry<Integer, Integer> smallEntry = intervals.floorEntry(value); 
        int left = value, right = value;
        if (smallEntry != null) {
            final int previous = smallEntry.getValue();
            if (previous >= value) {
                return;
            }
            if (previous == value - 1) {
                left = smallEntry.getKey();
            }
        }
        final Map.Entry<Integer, Integer> maxEntry = intervals.higherEntry(value); 
        if (maxEntry != null && maxEntry.getKey() == value + 1) {
            right = maxEntry.getValue();
            intervals.remove(value + 1);
        }
        intervals.put(left, right);
    }
    
    public int[][] getIntervals() {
        final int[][] answer = new int[intervals.size()][2];
        int ind = 0;
        for (Map.Entry<Integer, Integer> entry : intervals.entrySet()) {
            answer[ind][0] = entry.getKey();
            answer[ind++][1] = entry.getValue();
        }
        return answer; 
    }
}



2nd Method
class SummaryRanges {
    List<int[]> intervals;
    
    /** Initialize your data structure here. */
    public SummaryRanges() {
        intervals = new ArrayList<>();
    }
    
    public void addNum(int val) {
        int n = intervals.size();
        int[] newInterval = new int[] {val, val};
        int i = 0;
        while (i < n && intervals.get(i)[1] + 1 < val) {
            i++;
        }
        if (i == n) {
            intervals.add(newInterval);
            return;
        }
        int[] cur = intervals.get(i);
        if (val >= cur[0] && val <= cur[1]) {
            return;
        }
        if (cur[0] == val + 1) {
            cur[0] = val;
        } else if (cur[1] + 1 == val) {
            cur[1] = val;
        } else {
            intervals.add(i, newInterval);
            n++;
        }
        i++;
        while (i < n && val + 1 >= intervals.get(i)[0] && val + 1 <= intervals.get(i)[1]) {
            int[] interval = intervals.get(i);
            intervals.remove(i);
            n--;
            cur[1] = Math.max(cur[1], interval[1]);
        }
    }
    
    public int[][] getIntervals() {
        int[][] res = new int[intervals.size()][2];
        for (int i = 0; i < intervals.size(); i++) {
            res[i] = intervals.get(i);
        }
        return res;
    }
}



460. LFU Cache in c++


// Time Complexity : O(1) for all the operations and space complexity is O(n) where n is the capacity of the cache

class LFUCache {
public:
    int capacity;  // variable to store the capacity of the cache
    int minFreq;  // variable to store the minimum frequency of the cache
    unordered_map<int, pair<int, int>> cache;  // unordered map to store the key, value and frequency of the cache
    unordered_map<int, list<int>> freq;  // unordered map to store the frequency and the list of keys of the cache
    unordered_map<int, list<int>::iterator> pos;  // unordered map to store the key and the position of the key in the list of keys of the cache
    LFUCache(int capacity) {
        this->capacity = capacity;  // initialize the capacity of the cache
        minFreq = 0;  // initialize the minimum frequency of the cache
    }
    
    int get(int key) {
        if(cache.find(key) == cache.end()){  // if the key is not present in the cache
            return -1;  // return -1
        }
        int value = cache[key].first;  // get the value of the key
        int frequency = cache[key].second;  // get the frequency of the key
        freq[frequency].erase(pos[key]);  // erase the key from the list of keys of the cache
        if(freq[frequency].size() == 0){  // if the list of keys of the cache is empty
            freq.erase(frequency);  // erase the frequency from the unordered map
            if(minFreq == frequency){  // if the minimum frequency of the cache is equal to the frequency of the key
                minFreq++;  // increment the minimum frequency of the cache
            }
        }
        freq[frequency + 1].push_front(key);  // push the key to the list of keys of the cache
        pos[key] = freq[frequency + 1].begin();  // update the position of the key in the list of keys of the cache
        cache[key].second++;  // increment the frequency of the key
        return value;  // return the value of the key
    }
    
    void put(int key, int value) {
        if(capacity == 0){  // if the capacity of the cache is 0
            return;  // return
        }
        if(cache.find(key) != cache.end()){  // if the key is present in the  
            cache[key].first = value;  // update the value of the key
            get(key);  // call the get function
            return;  // return
        }
        if(cache.size() == capacity){  // if the size of the cache is equal to the capacity of the cache
            int lastKey = freq[minFreq].back();  // get the last key of the list of keys of the cache
            freq[minFreq].pop_back();  // pop the last key from the list of keys of the cache
            cache.erase(lastKey);  // erase the key from the cache
            pos.erase(lastKey);  // erase the key from the unordered map
        }
        cache[key] = {value, 1};  // insert the key, value and frequency to the cache
        freq[1].push_front(key);  // push the key to the list of keys of the cache
        pos[key] = freq[1].begin();  // update the position of the key in the list of keys of the cache
        minFreq = 1;  // update the minimum frequency of the cache
    }
};

2nd Solution

class LFUCache {
private:
    int cap;
    int size;
    unordered_map<int, list<vector<int>>::iterator> mp; //key -> address of list of vector{key, value, freq}
    map<int, list<vector<int>>> freq; //freq -> list of vector{key, value, freq}
    
public:
    LFUCache(int capacity) {
        cap = capacity;
        size = 0;
    }
    
    void makeMostFrequentlyUsed(int key) {
        auto &vec = *(mp[key]);
        
        int value = vec[1];
        
        int f     = vec[2];
        
        freq[f].erase(mp[key]);
        
        if(freq[f].empty())
            freq.erase(f);
        
        f++;
        
        freq[f].push_front(vector<int>({key, value, f}));
        
        mp[key] = freq[f].begin();
    }
    
    int get(int key) {
        if(mp.find(key) == mp.end())
            return -1;
        
        auto &vec = (*(mp[key]));
        
        int value = vec[1];
        
        makeMostFrequentlyUsed(key);
        
        return value;
    }
    
    void put(int key, int value) {
        if(cap == 0)
            return;
        
        if(mp.find(key) != mp.end()) {
            auto &vec = (*(mp[key]));
            vec[1] = value;
            makeMostFrequentlyUsed(key);
        }
        else if(size < cap) {
            size++;
            freq[1].push_front(vector<int>({key, value, 1}));
            mp[key] = freq[1].begin();
        }
        else { //Time to remove LFU or LRU if tie
            
            auto &kaun_sa_list = freq.begin()->second;
            
            int key_delete = (kaun_sa_list.back())[0]; //ordered_map ensures that the begin() will be th eleast frequency
            
            kaun_sa_list.pop_back();
            
            if(kaun_sa_list.empty())
                freq.erase(freq.begin()->first);
            
            freq[1].push_front(vector<int>({key, value, 1}));
            
            mp.erase(key_delete);
            mp[key] = freq[1].begin();
        }
    }
};

460. LFU Cache in Java 

// Time Complexity : O(1) for all the operations and space complexity is O(n) where n is the capacity of the cache


class LFUCache {
    int capacity;  // variable to store the capacity of the cache
    int minFreq;  // variable to store the minimum frequency of the cache
    HashMap<Integer, Integer> cache;  // unordered map to store the key, value and frequency of the cache
    HashMap<Integer, Integer> freq;  // unordered map to store the frequency and the list of keys of the cache
    HashMap<Integer, LinkedHashSet<Integer>> pos;  // unordered map to store the frequency and the list of keys of the cache
    public LFUCache(int capacity) {
        this.capacity = capacity;  // initialize the capacity of the cache
        minFreq = 0;  // initialize the minimum frequency of the cache
        cache = new HashMap<>();  // initialize the unordered map to store the key, value and frequency of the cache
        freq = new HashMap<>();  // initialize the unordered map to store the frequency and the list of keys of the cache
        pos = new HashMap<>();  // initialize the unordered map to store the frequency and the list of keys of the cache
    }
    
    public int get(int key) {
        if(!cache.containsKey(key)){  // if the key is not present in the cache
            return -1;  // return -1
        }
        int value = cache.get(key);  // get the value of the key
        int frequency = freq.get(key);  // get the frequency of the key
        freq.put(key, frequency + 1);  // increment the frequency of the key
        pos.get(frequency).remove(key);  // remove the key from the list of keys of the cache
        if(pos.get(frequency).size() == 0){  // if the list of keys of the cache is empty
            pos.remove(frequency);  // remove the frequency from the unordered map
            if(minFreq == frequency){  // if the minimum frequency of the cache is equal to the frequency of the key
                minFreq++;  // increment the minimum frequency of the cache
            }
        }
        if(!pos.containsKey(frequency + 1)){  // if the frequency is not present in the unordered map
            pos.put(frequency + 1, new LinkedHashSet<>());  // insert the frequency and the list of keys of the cache to the unordered map
        }
        pos.get(frequency + 1).add(key);  // add the key to the list of keys of the cache
        return value;  // return the value of the key
    }

    public void put(int key, int value) {
        if(capacity == 0){  // if the capacity of the cache is 0
            return;  // return
        }
        if(cache.containsKey(key)){  // if the key is present in the cache
            cache.put(key, value);  // update the value of the key
            get(key);  // call the get function
            return;  // return
        }
        if(cache.size() == capacity){  // if the size of the cache is equal to the capacity of the cache
            int lastKey = pos.get(minFreq).iterator().next();  // get the last key of the list of keys of the cache
            pos.get(minFreq).remove(lastKey);  // remove the last key from the list of keys of the cache
            if(pos.get(minFreq).size() == 0){  // if the list of keys of the cache is empty
                pos.remove(minFreq);  // remove the frequency from the unordered map
            }
            cache.remove(lastKey);  // remove the key from the cache
            freq.remove(lastKey);  // remove the key from the unordered map
        }
        cache.put(key, value);  // insert the key, value and frequency to the cache
        freq.put(key, 1);  // insert the key and frequency to the unordered map
        minFreq = 1;  // update the minimum frequency of the cache
        if(!pos.containsKey(1)){  // if the frequency is not present in the unordered map
            pos.put(1, new LinkedHashSet<>());  // insert the frequency and the list of keys of the cache to the unordered map
        }
        pos.get(1).add(key);  // add the key to the list of keys of the cache
    }
}


2nd Method


class LFUCache {
    int capacity;
    int min;
    Map<Integer, Integer> keyToVal;
    Map<Integer, Integer> keyToCount;
    Map<Integer, LinkedHashSet<Integer>> countToLRUKeys;
    
    public LFUCache(int capacity) {
        this.capacity = capacity;
        this.min = -1;
        keyToVal = new HashMap<>();
        keyToCount = new HashMap<>();
        countToLRUKeys = new HashMap<>();
        countToLRUKeys.put(1, new LinkedHashSet<>());
    }
    
    public int get(int key) {
        if (!keyToVal.containsKey(key)) {
            return -1;
        }
        int count = keyToCount.get(key);
        keyToCount.put(key, count + 1);
        countToLRUKeys.get(count).remove(key);
        if (count == min && countToLRUKeys.get(count).size() == 0) {
            min++;
        }
        if (!countToLRUKeys.containsKey(count + 1)) {
            countToLRUKeys.put(count + 1, new LinkedHashSet<>());
        }
        countToLRUKeys.get(count + 1).add(key);
        return keyToVal.get(key);
    }
    
    public void put(int key, int value) {
        if (capacity <= 0) {
            return;
        }
        if (keyToVal.containsKey(key)) {
            keyToVal.put(key, value);
            get(key);
            return;
        }
        if (keyToVal.size() >= capacity) {
            int evit = countToLRUKeys.get(min).iterator().next();
            countToLRUKeys.get(min).remove(evit);
            keyToVal.remove(evit);
            keyToCount.remove(evit);
        }
        keyToVal.put(key, value);
        keyToCount.put(key, 1);
        min = 1;
        countToLRUKeys.get(1).add(key);
    }
}





1137. N-th Tribonacci Number

30 Jan 2023

Easy

2 Approaches

C++:

1st :

// Time Complexity : O(n) where n is the number and space complexity is O(1)

class Solution {
public:
    int tribonacci(int n) {
        if(n == 0){  // if n is 0
            return 0;  // return 0
        }
        if(n == 1 || n == 2){  // if n is 1 or 2
            return 1;  // return 1
        }
        int a = 0;  // a is the first number
        int b = 1;  // b is the second number
        int c = 1;  // c is the third number
        int d = 0;  // d is the fourth number
        for(int i=3; i<=n; i++){  // for each number
            d = a + b + c;  // d is the sum of the first three numbers
            a = b;  // update the first number
            b = c;  // update the second number
            c = d;  // update the third number
        }
        return d;  // return the fourth number
    }
};




2nd:

class Solution {
public:
    int tribonacci(int n) {
        vector<int> dp(n+1);  // dp vector to store the tribonacci numbers
        dp[0] = 0;  // first number is 0
        if(n >= 1){  // if n is greater than or equal to 1
            dp[1] = 1;  // second number is 1
        }
        if(n >= 2){  // if n is greater than or equal to 2
            dp[2] = 1;  // third number is 1
        }
        for(int i=3; i<=n; i++){  // for each number
            dp[i] = dp[i-1] + dp[i-2] + dp[i-3];  // update the tribonacci number
        }
        return dp[n];  // return the tribonacci number
    }
};

              OR
              
class Solution {
public:
    int tribonacci(int n) {
        if(n == 0 || n == 1) return n;
        vector<int> dp(n+1);
        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 1;
        for(int i=3; i<=n; i++){
            dp[i] = dp[i-1] + dp[i-2] + dp[i-3];
          
        }
          return dp[n];
    }
};



Java:

class Solution {
    public int tribonacci(int n) {
        if(n == 0 || n == 1) return n;
        int[] dp = new int[n+1];
        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 1;
        for(int i=3; i<=n; i++){
            dp[i] = dp[i-1] + dp[i-2] + dp[i-3];
        }
        return dp[n];
    }
}



1626. Best Team With No Conflicts in c++

// Time Complexity : O(n^2) where n is the number of players and space complexity is O(n)

class Solution {
public:
    int bestTeamScore(vector<int>& scores, vector<int>& ages) {
        vector<pair<int, int>> v;  // vector to store the pair of age and score
        for(int i=0; i<scores.size(); i++){  // for each player
            v.push_back({ages[i], scores[i]});  // push the pair of age and score into the vector
        }
        sort(v.begin(), v.end());  // sort the vector based on the age
        vector<int> dp(v.size());  // dp vector to store the maximum score
        for(int i=0; i<v.size(); i++){  // for each player
            dp[i] = v[i].second;  // update the maximum score
            for(int j=0; j<i; j++){  // for each player
                if(v[i].second >= v[j].second){  // if the score of the current player is greater than or equal to the score of the previous player
                    dp[i] = max(dp[i], dp[j] + v[i].second);  // update the maximum score
                }
            }
        }
        return *max_element(dp.begin(), dp.end());  // return the maximum score
    }
};


1626. Best Team With No Conflicts in Java

// Time Complexity : O(n^2) where n is the number of players and space complexity is O(n)

class Solution {
    public int bestTeamScore(int[] scores, int[] ages) {
        int[][] v = new int[scores.length][2];  // array to store the pair of age and score
        for(int i=0; i<scores.length; i++){  // for each player
            v[i][0] = ages[i];  // update the age
            v[i][1] = scores[i];  // update the score
        }
        Arrays.sort(v, (a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);  // sort the array based on the age
        int[] dp = new int[v.length];  // dp array to store the maximum score
        for(int i=0; i<v.length; i++){  // for each player
            dp[i] = v[i][1];  // update the maximum score
            for(int j=0; j<i; j++){  // for each player
                if(v[i][1] >= v[j][1]){  // if the score of the current player is greater than or equal to the score of the previous player
                    dp[i] = Math.max(dp[i], dp[j] + v[i][1]);  // update the maximum score
                }
            }
        }
        return Arrays.stream(dp).max().getAsInt();  // return the maximum score
    }
}

class Solution {
    public int bestTeamScore(int[] scores, int[] ages) {
        int l = scores.length;
        int m[][] = new int[l][2];
        for(int i  = 0;i < l ; i++){
            m[i][0] = ages[i];
            m[i][1] = scores[i];
        }
        Arrays.sort(m, (a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);
        int dp[] = new int[l];
        dp[0] = m[0][1];
        for(int i = 1; i < l ; i++){
            int max = m[i][1];
            for(int j = 0; j < i;j++){
                if( m[i][1] >= m[j][1] ){
                    max = Math.max( max , m[i][1] + dp[j]);
                }
            }
            dp[i] = max;
        }
        int res = 0;
        for (int num : dp) {
            res = Math.max(res, num);
        }
    
        return res;
    }
}

Another Solution


class Solution {
    public int bestTeamScore(int[] scores, int[] ages) {
        int n = scores.length;
        int[][] arr = new int[n][2];
        for(int i = 0; i < n; i++){
            arr[i][0] = ages[i];
            arr[i][1] = scores[i];
        }
        Arrays.sort(arr, (a, b) -> {
            if(a[0] == b[0]){
                return a[1] - b[1];
            }
            return a[0] - b[0];
        });
        int[] dp = new int[n];
        for(int i = 0; i < n; i++){
            dp[i] = arr[i][1];
            for(int j = 0; j < i; j++){
                if(arr[i][1] >= arr[j][1]){
                    dp[i] = Math.max(dp[i], dp[j] + arr[i][1]);
                }
            }
        }
        int max = 0;
        for(int i = 0; i < n; i++){
            max = Math.max(max, dp[i]);
        }
        return max;
    }
}

1071. Greatest Common Divisor of Strings in c++

// Time Complexity : O(n) where n is the length of the strings and space complexity is O(1)

class Solution {
public:
    string gcdOfStrings(string str1, string str2) {
        if(str1 + str2 != str2 + str1){  // if the concatenation of the strings is not equal to the concatenation of the strings in reverse order
            return "";  // return empty string
        }
        return str1.substr(0, __gcd(str1.size(), str2.size()));  // return the gcd of the strings
    }
};

2nd 
class Solution {
public:
    string gcdOfStrings(string str1, string str2) {
        if(str1 + str2 != str2 + str1){
            return "";
        }
        int gcdLength = gcd(str1.size() , str2.size());
        return str1.substr(0 , gcdLength);
    }
};

1071. Greatest Common Divisor of String in Java

// Time Complexity : O(n) where n is the length of the strings and space complexity is O(1)

class Solution {
    public String gcdOfStrings(String str1, String str2) {
        if(!(str1 + str2).equals(str2 + str1)){
            return "";
        }
        return str1.substring(0, gcd(str1.length(), str2.length()));
    }
    public int gcd(int a, int b){
        if(b == 0){
            return a;
        }
        return gcd(b, a % b);
    }
}

953. Verifying an Alien Dictionary in c++  best Solution

// Time Complexity : O(n) where n is the length of the strings and space complexity is O(1)

class Solution {
public:
    bool isAlienSorted(vector<string>& words, string order) {
        vector<int> v(26);  // vector to store the order of the characters
        for(int i=0; i<order.size(); i++){  // for each character of the string order
            v[order[i] - 'a'] = i;  // update the order of the character
        }
        for(int i=0; i<words.size() - 1; i++){  // for each word
            for(int j=0; j<words[i].size(); j++){  // for each character of the word
                if(j >= words[i + 1].size()){  // if the length of the word is greater than the length of the next word
                    return false;  // return false
                }
                if(words[i][j] != words[i + 1][j]){  // if the characters are not equal
                    if(v[words[i][j] - 'a'] > v[words[i + 1][j] - 'a']){  // if the order of the first character is greater than the order of the second character
                        return false;  // return false
                    }
                    break;  // break
                }
            }
        }
        return true;  // return true
    }
}

2nd Method

class Solution {
public:
        bool isAlienSorted(vector<string> words, string order) {
        int mapping[26];
        for (int i = 0; i < 26; i++)
            mapping[order[i] - 'a'] = i;
        for (string &w : words)
            for (char &c : w)
                c = mapping[c - 'a'];
        return is_sorted(words.begin(), words.end());
    }
};


953. Verifying an Alien Dictionary in Java

// Time Complexity : O(n) where n is the length of the strings and space complexity is O(1)

class Solution {
    public boolean isAlienSorted(String[] words, String order) {
        int[] map = new int[26];
        for(int i = 0; i < order.length(); i++){
            map[order.charAt(i) - 'a'] = i;
        }
        for(int i = 0; i < words.length - 1; i++){
            for(int j = 0; j < words[i].length(); j++){
                if(j >= words[i + 1].length()){
                    return false;
                }
                if(words[i].charAt(j) != words[i + 1].charAt(j)){
                    if(map[words[i].charAt(j) - 'a'] > map[words[i + 1].charAt(j) - 'a']){
                        return false;
                    }
                    break;
                }
            }
        }
        return true;
    }
}

6. Zigzag Conversion in C++

// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)

class Solution {
public:
    string convert(string s, int numRows) {
        if(numRows == 1){  // if the number of rows is 1
            return s;  // return the string
        }
        vector<string> v(numRows);  // vector to store the string in zigzag order
        int i = 0;  // variable to store the index of the vector
        int j = 0;  // variable to store the index of the string
        while(j < s.size()){  // while the index of the string is less than the length of the string
            while(i < numRows && j < s.size()){  // while the index of the vector is less than the number of rows and the index of the string is less than the length of the string
                v[i] += s[j];  // append the character to the string
                i++;  // increment the index of the vector
                j++;  // increment the index of the string
            }
            i -= 2;  // decrement the index of the vector by 2
            while(i >= 1 && j < s.size()){  // while the index of the vector is greater than or equal to 1 and the index of the string is less than the length of the string
                v[i] += s[j];  // append the character to the string
                i--;  // decrement the index of the vector
                j++;  // increment the index of the string
            }
        }
        string ans = "";  // variable to store the final string
        for(int i=0; i<numRows; i++){  // for each string in the vector
            ans += v[i];  // append the string to the final string
        }
        return ans;  // return the final string
    }
};

6. Zigzag Conversion in Java

// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)

class Solution {
    public String convert(String s, int numRows) {  
        if(numRows == 1){
            return s;
        }
        StringBuilder[] v = new StringBuilder[numRows];
        for(int i=0; i<numRows; i++){
            v[i] = new StringBuilder();
        }
        int i = 0;
        int j = 0;
        while(j < s.length()){
            while(i < numRows && j < s.length()){
                v[i].append(s.charAt(j));
                i++;
                j++;
            }
            i -= 2;
            while(i >= 1 && j < s.length()){
                v[i].append(s.charAt(j));
                i--;
                j++;
            }
        }
        String ans = "";
        for(int k=0; k<numRows; k++){
            ans += v[k].toString();
        }
        return ans;
    }
}

567. Permutation in String in c++


// Time Complexity : O(n) where n is the length of the string s2 and space complexity is O(1)
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        vector<int> v1(26);  // vector to store the frequency of the characters of the string s1
        vector<int> v2(26);  // vector to store the frequency of the characters of the string s2
        for(int i=0; i<s1.size(); i++){  // for each character of the string s1
            v1[s1[i] - 'a']++;  // update the frequency of the character
        }
        for(int i=0; i<s2.size(); i++){  // for each character of the string s2
            v2[s2[i] - 'a']++;  // update the frequency of the character
            if(i >= s1.size()){  // if the window size is greater than the length of the string s1
                v2[s2[i - s1.size()] - 'a']--;  // decrement the frequency of the character
            }
            if(v1 == v2){  // if the frequency of the characters of the string s1 and the string s2 are equal
                return true;  // return true
            }
        }
        return false;  // return false
    }
};


567. Permutation in String in Java


// Time Complexity : O(n) where n is the length of the string s2 and space complexity is O(1)

class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int[] v1 = new int[26];  // vector to store the frequency of the characters of the string s1
        int[] v2 = new int[26];  // vector to store the frequency of the characters of the string s2
        for(int i=0; i<s1.length(); i++){  // for each character of the string s1
            v1[s1.charAt(i) - 'a']++;  // update the frequency of the character
        }
        for(int i=0; i<s2.length(); i++){  // for each character of the string s2
            v2[s2.charAt(i) - 'a']++;  // update the frequency of the character
            if(i >= s1.length()){  // if the window size is greater than the length of the string s1
                v2[s2.charAt(i - s1.length()) - 'a']--;  // decrement the frequency of the character
            }
            if(Arrays.equals(v1, v2)){  // if the frequency of the characters of the string s1 and the string s2 are equal
                return true;  // return true
            }
        }
        return false;  // return false
    }
};
 







438. Find All Anagrams in a String in c++

// Time Complexity : O(n) where n is the length of the string s and space complexity is O(1)

class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> v1(26);  // vector to store the frequency of the characters of the string p
        vector<int> v2(26);  // vector to store the frequency of the characters of the string s
        vector<int> res;  // vector to store the result
        for(int i=0; i<p.size(); i++){  // for each character of the string p
            v1[p[i] - 'a']++;  // update the frequency of the character
        }
        for(int i=0; i<s.size(); i++){  // for each character of the string s
            v2[s[i] - 'a']++;  // update the frequency of the character
            if(i >= p.size()){  // if the window size is greater than the length of the string p
                v2[s[i - p.size()] - 'a']--;  // decrement the frequency of the character
            }
            if(v1 == v2){  // if the frequency of the characters of the string p and the string s are equal
                res.push_back(i - p.size() + 1);  // push the index to the result vector
            }
        }
        return res;  // return the result vector
    }
};


438. Find All Anagrams in a String in Java


// Time Complexity : O(n) where n is the length of the string s and space complexity is O(1)

class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int[] v1 = new int[26];  // vector to store the frequency of the characters of the string p
        int[] v2 = new int[26];  // vector to store the frequency of the characters of the string s
        List<Integer> res = new ArrayList<>();  // vector to store the result
        for(int i=0; i<p.length(); i++){  // for each character of the string p
            v1[p.charAt(i) - 'a']++;  // update the frequency of the character
        }
        for(int i=0; i<s.length(); i++){  // for each character of the string s
            v2[s.charAt(i) - 'a']++;  // update the frequency of the character
            if(i >= p.length()){  // if the window size is greater than the length of the string p
                v2[s.charAt(i - p.length()) - 'a']--;  // decrement the frequency of the character
            }
            if(Arrays.equals(v1, v2)){  // if the frequency of the characters of the string p and the string s are equal
                res.add(i - p.length() + 1);  // push the index to the result vector
            }
        }
        return res;  // return the result vector
    }
};


1470. Shuffle the Array in c++

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(n)

class Solution {
public:
    vector<int> shuffle(vector<int>& nums, int n) {
        vector<int> res;  // vector to store the result
        for(int i=0; i<n; i++){  // for each element of the vector nums
            res.push_back(nums[i]);  // push the element to the result vector
            res.push_back(nums[i + n]);  // push the element to the result vector
        }
        return res;  // return the result vector
    }
};


1470. Shuffle the Array in Java


// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(n)

class Solution {
    public int[] shuffle(int[] nums, int n) {
        int[] res = new int[2 * n];  // vector to store the result
        for(int i=0; i<n; i++){  // for each element of the vector nums
            res[2 * i] = nums[i];  // push the element to the result vector
            res[2 * i + 1] = nums[i + n];  // push the element to the result vector
        }
        return res;  // return the result vector
    }
}



904. Fruit Into Baskets in C++


// Time Complexity : O(n) where n is the length of the vector tree and space complexity is O(1)


class Solution {
public:
    int totalFruit(vector<int>& fruits){
        int res = 0;  // variable to store the result
        int i = 0;  // variable to store the start index of the window
        int j = 0;  // variable to store the end index of the window
        int n = fruits.size();  // variable to store the length of the vector tree
        unordered_map<int, int> m;  // unordered map to store the type of the fruit and the frequency of the fruit
        while(j < n){  // while the end index of the window is less than the length of the vector tree
            m[fruits[j]]++;  // update the frequency of the fruit
            while(m.size() > 2){  // while the size of the unordered map is greater than 2
                m[fruits[i]]--;  // decrement the frequency of the fruit
                if(m[fruits[i]] == 0){  // if the frequency of the fruit is 0
                    m.erase(fruits[i]);  // erase the fruit from the unordered map
                }
                i++;  // increment the start index of the window
            }
            res = max(res, j - i + 1);  // update the result
            j++;  // increment the end index of the window
        }
        return res;  // return the result

    }
};




904. Fruit Into Baskets in Java

// Time Complexity : O(n) where n is the length of the vector tree and space complexity is O(1)


class Solution {
    public int totalFruit(int[] fruits){
        int res = 0;  // variable to store the result
        int i = 0;  // variable to store the start index of the window
        int j = 0;  // variable to store the end index of the window
        int n = fruits.length;  // variable to store the length of the vector tree
        HashMap<Integer, Integer> m = new HashMap<>();  // unordered map to store the type of the fruit and the frequency of the fruit
        while(j < n){  // while the end index of the window is less than the length of the vector tree
            m.put(fruits[j], m.getOrDefault(fruits[j], 0) + 1);  // update the frequency of the fruit
            while(m.size() > 2){  // while the size of the unordered map is greater than 2
                m.put(fruits[i], m.get(fruits[i]) - 1);  // decrement the frequency of the fruit
                if(m.get(fruits[i]) == 0){  // if the frequency of the fruit is 0
                    m.remove(fruits[i]);  // erase the fruit from the unordered map
                }
                i++;  // increment the start index of the window
            }
            res = Math.max(res, j - i + 1);  // update the result
            j++;  // increment the end index of the window
        }
        return res;  // return the result
    }
}

45. Jump Game II in c++

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size();  // variable to store the length of the vector nums
        int res = 0;  // variable to store the result
        int i = 0;  // variable to store the start index of the window
        int j = 0;  // variable to store the end index of the window
        while(j < n - 1){  // while the end index of the window is less than the length of the vector nums
            int maxIndex = j;  // variable to store the maximum index
            for(int k=i; k<=j; k++){  // for each element in the window
                maxIndex = max(maxIndex, k + nums[k]);  // update the maximum index 
            }
            i = j + 1;  // update the start index of the window
            j = maxIndex;  // update the end index of the window
            res++;  // increment the result
        }
        return res;  // return the result
    }
};

45. Jump Game II in Java

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
    public int jump(int[] nums) {
        int n = nums.length;  // variable to store the length of the vector nums
        int res = 0;  // variable to store the result
        int i = 0;  // variable to store the start index of the window
        int j = 0;  // variable to store the end index of the window
        while(j < n - 1){  // while the end index of the window is less than the length of the vector nums
            int maxIndex = j;  // variable to store the maximum index
            for(int k=i; k<=j; k++){  // for each element in the window
                maxIndex = Math.max(maxIndex, k + nums[k]);  // update the maximum index
            }
            i = j + 1;  // update the start index of the window
            j = maxIndex;  // update the end index of the window
            res++;  // increment the result
        }
        return res;  // return the result
    }
}



2306. Naming a Company in C++ best Solution

// Time Complexity : O(n) where n is the length of the string s and space complexity is O(1)

class Solution {
public:
    long long distinctNames(vector<string>& ideas) {
        unordered_set<string> count[26];
        for(auto& s : ideas){
            count[s[0] - 'a'].insert(s.substr(1));
        }
        long long res = 0;
        for(int i=0; i<26; i++){
            for(int j=i+1; j<26; j++){
                long long c1 = 0L , c2  = 0L;
                for(auto& c : count[i]){
                    if(! count[j].count(c)) c1++;
                }
                for(auto& c : count[j]){
                    if(!count[i].count(c)) c2++;
                }
                res += c1*c2;
            }
        }
        return res*2;
    }
};

2306. Naming a Company in Java best Solution

// Time Complexity : O(n) where n is the length of the string s and space complexity is O(1)

class Solution {
    public long distinctNames(String[] ideas) {
        Set<String>[] count = new HashSet[26];
        for(int i=0; i<26; i++){
            count[i] = new HashSet<>();
        }
        for(String s : ideas){
            count[s.charAt(0) - 'a'].add(s.substring(1));
        }
        long res = 0;
        for(int i=0; i<26; i++){
            for(int j=i+1; j<26; j++){
                long c1 = 0L, c2 = 0L;
                for(String c : count[i]){
                    if(!count[j].contains(c)) c1++;
                }
                for(String c : count[j]){
                    if(!count[i].contains(c)) c2++;
                }
                res += c1*c2;
            }
        }
        return res*2;
    }
} 

1162. As Far from Land as Possible in c++

// Time Complexity : O(n*m) where n is the number of rows and m is the number of columns and space complexity is O(n*m)

class Solution {
public:
    int maxDistance(vector<vector<int>>& grid) {
        int n = grid.size();  // variable to store the number of rows
        int m = grid[0].size();  // variable to store the number of columns
        queue<pair<int, int>> q;  // queue to store the indices of the land
        for(int i=0; i<n; i++){  // for each row
            for(int j=0; j<m; j++){  // for each column
                if(grid[i][j] == 1){  // if the current cell is land
                    q.push({i, j});  // push the indices of the land into the queue
                }
            }
        }
        if(q.size() == n*m || q.empty()) return -1;  // if all the cells are land or all the cells are water
        int res = -1;  // variable to store the result
        while(!q.empty()){  // while the queue is not empty
            int size = q.size();  // variable to store the size of the queue
            for(int i=0; i<size; i++){  // for each element in the queue
                pair<int, int> p = q.front();  // variable to store the indices of the land
                q.pop();  // pop the indices of the land from the queue
                int x = p.first;  // variable to store the row index of the land
                int y = p.second;  // variable to store the column index of the land
                if(x > 0 && grid[x - 1][y] == 0){  // if the cell above the current cell is water
                    grid[x - 1][y] = 1;  // make the cell above the current cell as land
                    q.push({x - 1, y});  // push the indices of the land into the queue
                }
                if(x < n - 1 && grid[x + 1][y] == 0){  // if the cell below the current cell is water
                    grid[x + 1][y] = 1;  // make the cell below the current cell as land
                    q.push({x + 1, y});  // push the indices of the land into the queue
                }
                if(y > 0 && grid[x][y - 1] == 0){  // if the cell to the left of the current cell is water
                    grid[x][y - 1] = 1;  // make the cell to the left of the current cell as land
                    q.push({x, y - 1});  // push the indices of the land into the queue
                }
                if(y < m - 1 && grid[x][y + 1] == 0){  // if the cell to the right of the current cell is water
                    grid[x][y + 1] = 1;  // make the cell to the right of the current cell as land
                    q.push({x, y + 1});  // push the indices of the land into the queue
                }
            }
            res++;  // increment the result
        }
        return res;  // return the result
    }
};

1162. As Far from Land as Possible in Java best Solution

// Time Complexity : O(n*m) where n is the number of rows and m is the number of columns and space complexity is O(n*m)

class Solution {
    public int maxDistance(int[][] grid) {
        int n = grid.length;  // variable to store the number of rows
        int m = grid[0].length;  // variable to store the number of columns
        Queue<int[]> q = new LinkedList<>();  // queue to store the indices of the land
        for(int i=0; i<n; i++){  // for each row
            for(int j=0; j<m; j++){  // for each column
                if(grid[i][j] == 1){  // if the current cell is land
                    q.add(new int[]{i, j});  // push the indices of the land into the queue
                }
            }
        }
        if(q.size() == n*m || q.isEmpty()) return -1;  // if all the cells are land or all the cells are water
        int res = -1;  // variable to store the result
        while(!q.isEmpty()){  // while the queue is not empty
            int size = q.size();  // variable to store the size of the queue
            for(int i=0; i<size; i++){  // for each element in the queue
                int[] p = q.poll();  // variable to store the indices of the land
                int x = p[0];  // variable to store the row index of the land
                int y = p[1];  // variable to store the column index of the land
                if(x > 0 && grid[x - 1][y] == 0){  // if the cell above the current cell is water
                    grid[x - 1][y] = 1;  // make the cell above the current cell as land
                    q.add(new int[]{x - 1, y});  // push the indices of the land into the queue
                }
                if(x < n - 1 && grid[x + 1][y] == 0){  // if the cell below the current cell is water
                    grid[x + 1][y] = 1;  // make the cell below the current cell as land
                    q.add(new int[]{x + 1, y});  // push the indices of the land into the queue
                }
                if(y > 0 && grid[x][y - 1] == 0){  // if the cell to the left of the current cell is water
                    grid[x][y - 1] = 1;  // make the cell to the left of the current cell as land
                    q.add(new int[]{x, y - 1});  // push the indices of the land into the queue
                }
                if(y < m - 1 && grid[x][y + 1] == 0){  // if the cell to the right of the current cell is water
                    grid[x][y + 1] = 1;  // make the cell to the right of the current cell as land
                    q.add(new int[]{x, y + 1});  // push the indices of the land into the queue
                }
            }
            res++;  // increment the result
        }
        return res;  // return the result
    }
}







        


1706. Where Will the Ball Fall in C++ Another Solution

// Time Complexity : O(n*m) where n is the number of rows and m is the number of columns and space complexity is O(1)

class Solution {
public:
    vector<int> findBall(vector<vector<int>>& grid) {
        int n = grid.size();  // variable to store the number of rows
        int m = grid[0].size();  // variable to store the number of columns
        vector<int> res(m, -1);  // vector to store the result
        for(int i=0; i<m; i++){  // for each column
            int j = i;  // variable to store the current column
            for(int k=0; k<n; k++){  // for each row
                if(grid[k][j] == 1){  // if the ball is moving in the right direction
                    if(j == m - 1 || grid[k][j + 1] == -1){  // if the ball is at the last column or the ball is moving in the opposite direction
                        j = -1;  // update the current column
                        break;  // break the loop
                    }
                    j++;  // increment the current column
                }
                else{  // if the ball is moving in the left direction
                    if(j == 0 || grid[k][j - 1] == 1){  // if the ball is at the first column or the ball is moving in the opposite direction
                        j = -1;  // update the current column
                        break;  // break the loop
                    }
                    j--;  // decrement the current column
                }
            }
            res[i] = j;  // update the result
        }
        return res;  // return the result
    }
};

2nd Method:

class Solution {
public:
    vector<int> findBall(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<int> res;
        for(int i=0; i<n; i++){
            int i1 = i;
            for(int j=0; j<m; j++){
                int i2 = i1 + grid[j][i1];
                if(i2<0 || i2>=n  || grid[j][i2] != grid[j][i1]){
                    i1 = -1;
                    break;
                }
                  i1 = i2;
            }
            res.push_back(i1);
          
        }
        return res;
    }
};



1706. Where Will the Ball Fall in Java Another Solution

// Time Complexity : O(n*m) where n is the number of rows and m is the number of columns and space complexity is O(1)

class Solution {
    public int[] findBall(int[][] grid) {
        int n = grid.length;  // variable to store the number of rows
        int m = grid[0].length;  // variable to store the number of columns
        int[] res = new int[m];  // array to store the result
        Arrays.fill(res, -1);  // fill the array with -1
        for(int i=0; i<m; i++){  // for each column
            int j = i;  // variable to store the current column
            for(int k=0; k<n; k++){  // for each row
                if(grid[k][j] == 1){  // if the ball is moving in the right direction
                    if(j == m - 1 || grid[k][j + 1] == -1){  // if the ball is at the last column or the ball is moving in the opposite direction
                        j = -1;  // update the current column
                        break;  // break the loop
                    }
                    j++;  // increment the current column
                }
                else{  // if the ball is moving in the left direction
                    if(j == 0 || grid[k][j - 1] == 1){  // if the ball is at the first column or the ball is moving in the opposite direction
                        j = -1;  // update the current column
                        break;  // break the loop
                    }
                    j--;  // decrement the current column
                }
            }
            res[i] = j;  // update the result
        }
        return res;  // return the result
    }
}

2nd Method:


class Solution {
    public int[] findBall(int[][] grid) {
        int n = grid[0].length;
        int m = grid.length;
        int[] res = new int[n];
        for(int i=0; i<n; i++){
            int i1 = i;
            for(int j=0; j<m; j++){
                int i2 = i1 + grid[j][i1];
                if(i2<0 || i2>=n || grid[j][i2] != grid[j][i1]){
                    i1 = -1;
                    break;
                }
                i1 = i2;
            }
            res[i] = i1;
        }
        return res;
    }
}




219. Contains Duplicate II in c++

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(n)

class Solution {

public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        unordered_map<int, int> m;  // unordered map to store the number and the index of the number
        for(int i=0; i<nums.size(); i++){  // for each element in the vector nums
            if(m.find(nums[i]) != m.end() && i - m[nums[i]] <= k){  // if the number is present in the unordered map and the difference between the current index and the index of the number is less than or equal to k
                return true;  // return true
            }
            m[nums[i]] = i;  // update the index of the current element
        }
        return false;  // return false
    }
};

219. Contains Duplicate II in Java

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(n)

class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        Map<Integer, Integer> m = new HashMap<>();  // unordered map to store the number and the index of the number
        for(int i=0; i<nums.length; i++){  // for each element in the vector nums
            if(m.containsKey(nums[i]) && i - m.get(nums[i]) <= k){  // if the number is present in the unordered map and the difference between the current index and the index of the number is less than or equal to k
                return true;  // return true
            }
            m.put(nums[i], i);  // update the index of the current element
        }
        return false;  // return false
    }
}


76. Minimum Window Substring in c++

// Time Complexity : O(n) where n is the length of the string s and space complexity is O(n)

class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char, int> m;  // unordered map to store the character and the count of the character
        for(auto& c : t){  // for each character in the string t
            m[c]++;  // increment the count of the character
        }
        int i = 0;  // variable to store the start index of the window
        int j = 0;  // variable to store the end index of the window
        int minLen = INT_MAX;  // variable to store the minimum length of the window
        int minStart = 0;  // variable to store the start index of the minimum window
        int count = t.size();  // variable to store the count of the characters in the string t
        while(j < s.size()){  // while the end index of the window is less than the length of the string s
            if(m.find(s[j]) != m.end()){  // if the character is present in the unordered map
                if(m[s[j]] > 0){  // if the count of the character is greater than 0
                    count--;  // decrement the count
                }
                m[s[j]]--;  // decrement the count of the character
            }
            while(count == 0){  // while the count is 0
                if(j - i + 1 < minLen){  // if the length of the window is less than the minimum length
                    minLen = j - i + 1;  // update the minimum length
                    minStart = i;  // update the start index of the minimum window
                }
                if(m.find(s[i]) != m.end()){  // if the character is present in the unordered map
                    m[s[i]]++;  // increment the count of the character
                    if(m[s[i]] > 0){  // if the count of the character is greater than 0
                        count++;  // increment the count
                    }
                }
                i++;  // increment the start index of the window
            }
            j++;  // increment the end index of the window
        }
        return minLen == INT_MAX ? "" : s.substr(minStart, minLen);  // return the minimum window
    }
};

2nd Method 

class Solution {
public:
    string minWindow(string s, string t) {
        vector<int> v(128,0);
        for(auto& c : t) v[c]++;
        int counter = t.size() ,  start = 0 , end = 0 , l = INT_MAX , head = 0;
        while(end<s.size()){
            if(v[s[end++]] --> 0) counter--;
            while(counter == 0){
                if(end-start < l) l = end -(head = start);
                if(v[s[start++]]++ == 0 ) counter++; 
            }
        }   
        return l == INT_MAX ? "" : s.substr(head , l);

    }
};

76. Minimum Window Substring in Java

// Time Complexity : O(n) where n is the length of the string s and space complexity is O(n)

class Solution {
    public String minWindow(String s, String t) {
        Map<Character, Integer> m = new HashMap<>();  // unordered map to store the character and the count of the character
        for(char c : t.toCharArray()){  // for each character in the string t
            m.put(c, m.getOrDefault(c, 0) + 1);  // increment the count of the character
        }
        int i = 0;  // variable to store the start index of the window
        int j = 0;  // variable to store the end index of the window
        int minLen = Integer.MAX_VALUE;  // variable to store the minimum length of the window
        int minStart = 0;  // variable to store the start index of the minimum window
        int count = t.length();  // variable to store the count of the characters in the string t
        while(j < s.length()){  // while the end index of the window is less than the length of the string s
            if(m.containsKey(s.charAt(j))){  // if the character is present in the unordered map
                if(m.get(s.charAt(j)) > 0){  // if the count of the character is greater than 0
                    count--;  // decrement the count
                }
                m.put(s.charAt(j), m.get(s.charAt(j)) - 1);  // decrement the count of the character
            }
            while(count == 0){  // while the count is 0
                if(j - i + 1 < minLen){  // if the length of the window is less than the minimum length
                    minLen = j - i + 1;  // update the minimum length
                    minStart = i;  // update the start index of the minimum window
                }
                if(m.containsKey(s.charAt(i))){  // if the character is present in the unordered map
                    m.put(s.charAt(i), m.get(s.charAt(i)) + 1);  // increment the count of the character
                    if(m.get(s.charAt(i)) > 0){  // if the count of the character is greater than 0
                        count++;  // increment the count
                    }
                }
                i++;  // increment the start index of the window
            }
            j++;  // increment the end index of the window
        }
        return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);  // return the minimum window
    }
}

2nd Method 

class Solution {
    public String minWindow(String s, String t) {
        int[] v = new int[128];
        for(char c : t.toCharArray()) v[c]++;
        int counter = t.length() ,  start = 0 , end = 0 , l = Integer.MAX_VALUE , head = 0;
        while(end<s.length()){
            if(v[s.charAt(end++)]-- > 0) counter--;
            while(counter == 0){
                if(end-start < l) l = end -(head = start);
                if(v[s.charAt(start++)]++ == 0 ) counter++; 
            }
        }   
        return l == Integer.MAX_VALUE ? "" : s.substring(head , head+l);

    }
}








1. Two Sum in C++

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(n)

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> m;  // unordered map to store the number and the index of the number
        for(int i=0; i<nums.size(); i++){  // for each element in the vector nums
            if(m.find(target - nums[i]) != m.end()){  // if the target - nums[i] is present in the unordered map
                return {m[target - nums[i]], i};  // return the index of the target - nums[i] and the index of the current element
            }
            m[nums[i]] = i;  // update the index of the current element
        }
        return {};  // return empty vector
    }
};

2nd Method

class Solution{
    public:
    vector<int> twoSum(vector<int> arr , int target){
        vector<int> v;
        for(int i=0;i<arr.size();i++){
            for(int j=i+1;j<arr.size();j++){
                if(arr[i]+arr[j]==target){
                    v.push_back(i);
                    v.push_back(j);
                }
            }
            
        }
        return v;
    }
};





3rd Method

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> v;
        for(int i=0;i<nums.size();i++)
        {
            for(int j=i+1;j<nums.size();j++)
            {
                if(nums[i]+nums[j]==target)
                {
                    v.push_back(i);
                    v.push_back(j);
                }
            }
        }
        return v;
        
    }
};





4th Method

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(n)

class Solution {

public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> m;  // unordered map to store the number and the index of the number
        for(int i=0; i<nums.size(); i++){  // for each element in the vector nums
            if(m.find(nums[i]) != m.end()){  // if the nums[i] is present in the unordered map
                return {m[nums[i]], i};  // return the index of the nums[i] and the index of the current element
            }
            m[target - nums[i]] = i;  // update the index of the target - nums[i]
        }
        return {};  // return empty vector
    }
};


1. Two Sum in Java

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(n)

class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> m = new HashMap<>();  // unordered map to store the number and the index of the number
        for(int i=0; i<nums.length; i++){  // for each element in the vector nums
            if(m.containsKey(target - nums[i])){  // if the target - nums[i] is present in the unordered map
                return new int[]{m.get(target - nums[i]), i};  // return the index of the target - nums[i] and the index of the current element
            }
            m.put(nums[i], i);  // update the index of the current element
        }
        return new int[]{};  // return empty vector
    }
};

2nd Method

class Solution{
    public int[] twoSum(int[] nums , int target){
        for(int i=0 ; i<nums.length;i++){
            for(int j=i+1;j<nums.length;j++){
                if(nums[i]+nums[j]==target){
                    return new int[]{i,j};
                }
            }
        }
        return null;
    }
}

3rd Method

class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] == target - nums[i]) {
                    return new int[] { i, j };
                }
            }
        }
        // In case there is no solution, we'll just return null
        return null;
    }
}

4th Method

class Solution {
    public int[] twoSum(int[] nums, int target) {
        int n= nums.length;
        HashMap<Integer , Integer> m = new HashMap<>();
        for(int i=0; i<n; i++){
            if(m.containsKey(nums[i])){
                return new int[] {m.get(nums[i]) , i};
            }
            m.put(target - nums[i] , i);
        }
        return new int[]{};
    }
}


7. Reverse Integer in C++

// Time Complexity : O(log(x)) where x is the input and space complexity is O(1)

class Solution {
public:
    int reverse(int x) {
        long long int rev = 0;  // variable to store the reverse of the input
        while(x != 0){  // while the input is not equal to 0
            rev = rev * 10 + x % 10;  // update the reverse of the input
            x /= 10;  // update the input
        }
        if(rev > INT_MAX || rev < INT_MIN){  // if the reverse of the input is greater than INT_MAX or less than INT_MIN
            return 0;  // return 0
        }
        return rev;  // return the reverse of the input
    }
};

7. Reverse Integer in Java

// Time Complexity : O(log(x)) where x is the input and space complexity is O(1)

class Solution {
    public int reverse(int x) {
        long rev = 0;  // variable to store the reverse of the input
        while(x != 0){  // while the input is not equal to 0
            rev = rev * 10 + x % 10;  // update the reverse of the input
            x /= 10;  // update the input
        }
        if(rev > Integer.MAX_VALUE || rev < Integer.MIN_VALUE){  // if the reverse of the input is greater than Integer.MAX_VALUE or less than Integer.MIN_VALUE
            return 0;  // return 0
        }
        return (int)rev;  // return the reverse of the input
    }
};







4. Median of Two Sorted Arrays in C++

// Time Complexity : O(log(min(m,n))) where m and n are the lengths of the two arrays and space complexity is O(1)

class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int n1 = nums1.size();  // length of the first array
        int n2 = nums2.size();  // length of the second array
        if(n1 > n2){  // if the length of the first array is greater than the length of the second array
            return findMedianSortedArrays(nums2, nums1);  // call the function with the second array as the first array and the first array as the second array
        }
        int low = 0;  // variable to store the low index
        int high = n1;  // variable to store the high index
        while(low <= high){  // while the low index is less than or equal to the high index
            int cut1 = (low + high) / 2;  // variable to store the cut1
            int cut2 = (n1 + n2 + 1) / 2 - cut1;  // variable to store the cut2
            int left1 = cut1 == 0 ? INT_MIN : nums1[cut1 - 1];  // variable to store the left1
            int left2 = cut2 == 0 ? INT_MIN : nums2[cut2 - 1];  // variable to store the left2
            int right1 = cut1 == n1 ? INT_MAX : nums1[cut1];  // variable to store the right1
            int right2 = cut2 == n2 ? INT_MAX : nums2[cut2];  // variable to store the right2
            if(left1 <= right2 && left2 <= right1){  // if the left1 is less than or equal to the right2 and the left2 is less than or equal to the right1 
                if((n1 + n2) % 2 == 0){  // if the sum of the lengths of the two arrays is even
                    return (max(left1, left2) + min(right1, right2)) / 2.0;  // return the average of the max of the left1 and left2 and the min of the right1 and right2
                }
                else{  // if the sum of the lengths of the two arrays is odd
                    return max(left1, left2);  // return the max of the left1 and left2
                }
            }

            else if(left1 > right2){  // if the left1 is greater than the right2
                high = cut1 - 1;  // update the high index
            }
            else{  // if the left2 is greater than the right1
                low = cut1 + 1;  // update the low index
            }

        }
        return 0.0;  // return 0.0
    }
};

2nd Method 

class Solution {
    public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        vector<int> v;  // vector
        int i=0,j=0;    // initialize i and j with zero
        while(i<nums1.size() && j<nums2.size()){    // loop for i and j
            if(nums1[i]<nums2[j]){  // if condition is true
                v.push_back(nums1[i]);  // push nums1[i] in vector  
                i++;
            }
            else{
                v.push_back(nums2[j]);      // push nums2[j] in vector
                j++;
            }
        }
        while(i<nums1.size()){  // loop for i
            v.push_back(nums1[i]);  // push nums1[i] in vector
            i++;
        }
        while(j<nums2.size()){  // loop for j
            v.push_back(nums2[j]);  // push nums2[j] in vector
            j++;
        }
        int n=v.size(); // size of vector
        if(n%2==0){ // if condition is true
            return (v[n/2]+v[n/2-1])/2.0;   // return median
        }   
        else{
            return v[n/2];      // return median
        }
    }
};






4. Median of Two Sorted Arrays in Java

// Time Complexity : O(log(min(m,n))) where m and n are the lengths of the two arrays and space complexity is O(1)

class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int n1 = nums1.length;  // length of the first array
        int n2 = nums2.length;  // length of the second array
        if(n1 > n2){  // if the length of the first array is greater than the length of the second array
            return findMedianSortedArrays(nums2, nums1);  // call the function with the second array as the first array and the first array as the second array
        }
        int low = 0;  // variable to store the low index
        int high = n1;  // variable to store the high index
        while(low <= high){  // while the low index is less than or equal to the high index
            int cut1 = (low + high) / 2;  // variable to store the cut1
            int cut2 = (n1 + n2 + 1) / 2 - cut1;  // variable to store the cut2
            int left1 = cut1 == 0 ? Integer.MIN_VALUE : nums1[cut1 - 1];  // variable to store the left1
            int left2 = cut2 == 0 ? Integer.MIN_VALUE : nums2[cut2 - 1];  // variable to store the left2
            int right1 = cut1 == n1 ? Integer.MAX_VALUE : nums1[cut1];  // variable to store the right1
            int right2 = cut2 == n2 ? Integer.MAX_VALUE : nums2[cut2];  // variable to store the right2
            if(left1 <= right2 && left2 <= right1){  // if the left1 is less than or equal to the right2 and the left2 is less than or equal to the right1
                if((n1 + n2) % 2 == 0){  // if the sum of the lengths of the two arrays is even
                    return (Math.max(left1, left2) + Math.min(right1, right2)) / 2.0;  // return the average of the max of the left1 and left2 and the min of the right1 and right2
                }
                else{  // if the sum of the lengths of the two arrays is odd
                    return Math.max(left1, left2);  // return the max of the left1 and left2
                }
            }
                
                else if(left1 > right2){  // if the left1 is greater than the right2
                    high = cut1 - 1;  // update the high index
                }
                else{  // if the left2 is greater than the right1
                    low = cut1 + 1;  // update the low index
                }

        }
        return 0.0;  // return 0.0
    }
}


1832. Check if the Sentence Is Pangram in c++

// Time Complexity : O(n) where n is the length of the string and space complexity is O(1)

class Solution {
public:
    bool checkIfPangram(string sentence) {
        vector<int> count(26, 0);  // vector to store the count of the alphabets
        for(int i = 0; i < sentence.length(); i++){  // iterate over the string
            count[sentence[i] - 'a']++;  // increment the count of the current character
        }
        for(int i = 0; i < 26; i++){  // iterate over the vector
            if(count[i] == 0){  // if the count of the current character is 0
                return false;  // return false
            }
        }
        return true;  // return true
    }
};

1832. Check if the Sentence Is Pangram in Java

// Time Complexity : O(n) where n is the length of the string and space complexity is O(1)

class Solution {
    public boolean checkIfPangram(String sentence) {
        int[] count = new int[26];  // array to store the count of the alphabets
        for(int i = 0; i < sentence.length(); i++){  // iterate over the string
            count[sentence.charAt(i) - 'a']++;  // increment the count of the current character
        }
        for(int i = 0; i < 26; i++){  // iterate over the array
            if(count[i] == 0){  // if the count of the current character is 0
                return false;  // return false
            }
        }
        return true;  // return true
    }
}

692. Top K Frequent Words beest solution in c++

// Time Complexity : O(nlogk) where n is the number of words and k is the number of words to be returned and space complexity is O(n)

class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        unordered_map<string, int> count;  // map to store the count of the words
        for(int i = 0; i < words.size(); i++){  // iterate over the words
            count[words[i]]++;  // increment the count of the current word
        }
            priority_queue<pair<int, string>, vector<pair<int, string>>, MyComp> pq; // min heap to store the count and the word
        for(auto it = count.begin(); it != count.end(); it++){  // iterate over the map
            pq.push({it->second, it->first});  // push the count and the word into the min heap
            if(pq.size() > k){  // if the size of the min heap is greater than k
                pq.pop();  // pop the top element
            }
        }
        vector<string> result;  // vector to store the result
        while(!pq.empty()){  // while the min heap is not empty
            result.push_back(pq.top().second);  // push the word into the result
            pq.pop();  // pop the top element
        }
        reverse(result.begin(), result.end());  // reverse the result
        return result;  // return the result
    }
private:
    struct MyComp{  // comparator class
        bool operator()(pair<int, string> a, pair<int, string> b){  // operator overloading
            if(a.first != b.first){
                return a.first > b.first;  // if the count of the first word is greater than the count of the second word

            }
            else{
                return a.second < b.second;  // if the count of the first word is less than the count of the second word
            }

        }
    };
};

692. Top K Frequent Words in Java

// Time Complexity : O(nlogk) where n is the number of words and k is the number of words to be returned and space complexity is O(n)

class Solution {
    public List<String> topKFrequent(String[] words, int k) {
        HashMap<String, Integer> count = new HashMap<>();  // map to store the count of the words
        for(int i = 0; i < words.length; i++){  // iterate over the words
            count.put(words[i], count.getOrDefault(words[i], 0) + 1);  // increment the count of the current word
        }
        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>((a, b) -> a.getValue() == b.getValue() ? b.getKey().compareTo(a.getKey()) : a.getValue() - b.getValue());  // min heap to store the count and the word
        for(Map.Entry<String, Integer> entry : count.entrySet()){  // iterate over the map
            pq.add(entry);  // add the entry into the min heap
            if(pq.size() > k){  // if the size of the min heap is greater than k
                pq.poll();  // poll the top element
            }
        }
        List<String> result = new ArrayList<>();  // list to store the result
        while(!pq.isEmpty()){  // while the min heap is not empty
            result.add(pq.poll().getKey());  // add the word into the result
        }
        Collections.reverse(result);  // reverse the result
        return result;  // return the result
    }
}







Decode Ways  in c++ 

// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)

class Solution {
public:
    int numDecodings(string s) {
        int n = s.length();  // get the length of the string
        vector<int> dp(n + 1, 0);  // vector to store the number of ways to decode the string
        dp[0] = 1;  // initialize the first element of the vector to 1
        dp[1] = s[0] == '0' ? 0 : 1;  // initialize the second element of the vector to 1 if the first character is not 0
        for(int i = 2; i <= n; i++){  // iterate over the vector
            int first = stoi(s.substr(i - 1, 1));  // get the first character
            int second = stoi(s.substr(i - 2, 2));  // get the second character
            if(first >= 1){  // if the first character is greater than or equal to 1
                dp[i] += dp[i - 1];  // add the number of ways to decode the string till the previous character
            }
            if(second >= 10 && second <= 26){  // if the second character is greater than or equal to 10 and less than or equal to 26
                dp[i] += dp[i - 2];  // add the number of ways to decode the string till the previous character
            }
        }
        return dp[n];  // return the number of ways to decode the string
    }
};

2nd Method 

class Solution {
    public:
    int numDecodings(string s) { // decode ways
        int n=s.size();     // size of string
        vector<int> dp(n+1,0);      // vector
        dp[0]=1;        // dp[0]=1
        dp[1]=s[0]=='0'?0:1;        // dp[1]=s[0]=='0'?0:1
        for(int i=2;i<=n;i++){      // loop for i
            int first=s[i-1]-'0';       // first=s[i-1]-'0'
            int second=(s[i-2]-'0')*10+(s[i-1]-'0');     // second=(s[i-2]-'0')*10+(s[i-1]-'0')
            if(first>=1 && first<=9){       // if condition is true
                dp[i]+=dp[i-1];     // dp[i]+=dp[i-1]
            }
            if(second>=10 && second<=26){       // if condition is true
                dp[i]+=dp[i-2];     // dp[i]+=dp[i-2]
            }
        }
        return dp[n];       // return dp[n]
    }
};

 
Decode Ways  in Java

// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)

class Solution {
    public int numDecodings(String s) {
        int n = s.length();  // get the length of the string
        int[] dp = new int[n + 1];  // array to store the number of ways to decode the string
        dp[0] = 1;  // initialize the first element of the array to 1
        dp[1] = s.charAt(0) == '0' ? 0 : 1;  // initialize the second element of the array to 1 if the first character is not 0
        for(int i = 2; i <= n; i++){  // iterate over the array
            int first = Integer.parseInt(s.substring(i - 1, i));  // get the first character
            int second = Integer.parseInt(s.substring(i - 2, i));  // get the second character
            if(first >= 1){  // if the first character is greater than or equal to 1
                dp[i] += dp[i - 1];  // add the number of ways to decode the string till the previous character
            }
            if(second >= 10 && second <= 26){  // if the second character is greater than or equal to 10 and less than or equal to 26
                dp[i] += dp[i - 2];  // add the number of ways to decode the string till the previous character
            }
        }
        return dp[n];  // return the number of ways to decode the string
    }
};
        
2nd Method


class Solution {
    public int numDecodings(String s) { // decode ways
        int n=s.length();       // length of string
        int[] dp=new int[n+1];      // dp array
        dp[0]=1;        // dp[0]=1
        dp[1]=s.charAt(0)=='0'?0:1;     // dp[1]=s.charAt(0)=='0'?0:1
        for(int i=2;i<=n;i++){      // loop for i
            int first=s.charAt(i-1)-'0';        // first=s.charAt(i-1)-'0'
            int second=(s.charAt(i-2)-'0')*10+(s.charAt(i-1)-'0');      // second=(s.charAt(i-2)-'0')*10+(s.charAt(i-1)-'0')
            if(first>=1 && first<=9){       // if condition is true
                dp[i]+=dp[i-1];     // dp[i]+=dp[i-1]
            }
            if(second>=10 && second<=26){       // if condition is true
                dp[i]+=dp[i-2];     // dp[i]+=dp[i-2]
            }
        }
        return dp[n];       // return dp[n]
    }
}







146 LRU cache in c++

// Time Complexity : O(1) for all the operations and space complexity is O(n) where n is the capacity of the cache

class LRUCache {
    int capacity;  // variable to store the capacity of the cache
    list<pair<int, int>> cache;  // list to store the key, value and frequency of the cache
    unordered_map<int, list<pair<int, int>>::iterator> pos;  // map to store the key and the position of the key in the list of keys of the cache
public:
    LRUCache(int capacity) {
        this->capacity = capacity;  // initialize the capacity of the cache
    }
    
    int get(int key) {
        if(pos.find(key) == pos.end()){  // if the key is not present in the cache
            return -1;  // return -1
        }
        int value = pos[key]->second;  // get the value of the key
        cache.erase(pos[key]);  // erase the key from the list of keys of the cache
        cache.push_front({key, value});  // push the key to the list of keys of the cache
        pos[key] = cache.begin();  // update the position of the key in the list of keys of the cache
        return value;  // return the value of the key
    }
    
    void put(int key, int value) {
        if(capacity == 0){  // if the capacity of the cache is 0
            return;  // return
        }
        if(pos.find(key) != pos.end()){  // if the key is present in the cache
            cache.erase(pos[key]);  // erase the key from the list of keys of the cache
        }
        else if(cache.size() == capacity){  // if the size of the cache is equal to the capacity of the cache
            int lastKey = cache.back().first;  // get the last key of the list of keys of the cache
            cache.pop_back();  // pop the last key from the list of keys of the cache
            pos.erase(lastKey);  // erase the key from the map
        }
        cache.push_front({key, value});  // push the key to the list of keys of the cache
        pos[key] = cache.begin();  // update the position of the key in the list of keys of the cache
    }
};


146 LRU cache in java

4 Approaches

1st Method

// Time Complexity : O(1) for all the operations and space complexity is O(n) where n is the capacity of the cache

class LRUCache {
    int capacity;  // variable to store the capacity of the cache
    HashMap<Integer, Node> map;  // map to store the key and the node of the key in the double linked list of keys of the cache
    Node head;  // head of the double lid list of keys of the cache
    Node tail;  // tail of the double linked list of keys of the cache
    public LRUCache(int capacity) {
        this.capacity = capacity;  // initialize the capacity of the cache
        map = new HashMap<>();  // initialize the map
        head = new Node();  // initialize the head of the double linked list of keys of the cache
        tail = new Node();  // initialize the tail of the double linked list of keys of the cache
        head.next = tail;  // connect the head and the tail of the double linked list of keys of the cache
        tail.prev = head;  // connect the head and the tail of the double linked list of keys of the cache
    }
    
    public int get(int key) {
        if(!map.containsKey(key)){  // if the key is not present in the cache
            return -1;  // return -1
        }
        Node node = map.get(key);  // get the node of the key in the double linked list of keys of the cache
        remove(node);  // remove the node from the double linked list of keys of the cache
        add(node);  // add the node to the double linked list of keys of the cache
        return node.value;  // return the value of the key
    }
    
    public void put(int key, int value) {
        if(capacity == 0){  // if the capacity of the cache is 0
            return;  // return
        }
        if(map.containsKey(key)){  // if the key is present in the cache
            remove(map.get(key));  // remove the node of the key from the double linked list of keys of the cache
        }
        else if(map.size() == capacity){  // if the size of the cache is equal to the capacity of the cache
            map.remove(tail.prev.key);  // remove the last key from the map
            remove(tail.prev);  // remove the last node from the double linked list of keys of the cache
        }
        Node node = new Node(key, value);  // create a new node for the key
        map.put(key, node);  // add the key and the node of the key to the map
        add(node);  // add the node to the double linked list of keys of the cache
    }

    // function to remove the node from the double linked list of keys of the cache
    public void remove(Node node){
        node.prev.next = node.next;  // connect the previous node of the node to the next node of the node
        node.next.prev = node.prev;  // connect the next node of the node to the previous node of the node
    }

    // function to add the node to the double linked list of keys of the cache
    public void add(Node node){
        node.next = head.next;  // connect the next node of the node to the next node of the head
        node.prev = head;  // connect the previous node of the node to the head
        head.next.prev = node;  // connect the previous node of the next node of the head to the node
        head.next = node;  // connect the next node of the head to the node
    }

    // class to represent the node of the double linked list of keys of the cache
    class Node{
        int key;  // variable to store the key
        int value;  // variable to store the value of the key
        Node prev;  // variable to store the previous node of the node
        Node next;  // variable to store the next node of the node
        public Node(int key, int value){
            this.key = key;  // initialize the key
            this.value = value;  // initialize the value of the key
        }
        public Node(){
        }
    }
}


2nd Method

// Time Complexity : O(1) for all the operations and space complexity is O(n) where n is the capacity of the cache


class LRUCache {
    int capacity;  // variable to store the capacity of the cache
    HashMap<Integer, Node> map;  // map to store the key and the node of the key in the double linked list of keys of the cache
    Node head;  // head of the double linked list of keys of the cache
    Node tail;  // tail of the double linked list of keys of the cache
    public LRUCache(int capacity) {
        this.capacity = capacity;  // initialize the capacity of the cache
        map = new HashMap<>();  // initialize the map
        head = new Node();  // initialize the head of the double linked list of keys of the cache
        tail = new Node();  // initialize the tail of the double linked list of keys of the cache
        head.next = tail;  // connect the head and the tail of the double linked list of keys of the cache
        tail.prev = head;  // connect the head and the tail of the double linked list of keys of the cache
    }
    
    public int get(int key) {
        if(!map.containsKey(key)){  // if the key is not present in the cache
            return -1;  // return -1
        }
        Node node = map.get(key);  // get the node of the key in the double linked list of keys of the cache
        remove(node);  // remove the node from the double linked list of keys of the cache
        add(node);  // add the node to the double linked list of keys of the cache
        return node.value;  // return the value of the key
    }
    
    public void put(int key, int value) {
        if(capacity == 0){  // if the capacity of the cache is 0
            return;  // return
        }
        if(map.containsKey(key)){  // if the key is present in the cache
            Node node = map.get(key);  // get the node of the key in the double linked list of keys of the cache
            remove(node);  // remove the node from the double linked list of keys of the cache
            node.value = value;  // update the value of the key
            add(node);  // add the node to the double linked list of keys of the cache
        }
        else if(map.size() == capacity){  // if
            Node node = tail.prev;  // get the last node of the double linked list of keys of the cache
            remove(node);  // remove the node from the double linked list of keys of the cache
            map.remove(node.key);  // remove the key from the map
            node.key = key;  // update the key
            node.value = value;  // update the value of the key
            add(node);  // add the node to the double linked list of keys of the cache
            map.put(key, node);  // add the key to the map
        }
        else{
            Node node = new Node(key, value);  // create a new node
            add(node);  // add the node to the double linked list of keys of the cache
            map.put(key, node);  // add the key to the map
        }
    }

    public void remove(Node node){  // function to remove the node from the double linked list of keys of the cache
        node.prev.next = node.next;  // remove the node from the double linked list of keys of the cache
        node.next.prev = node.prev;  // remove the node from the double linked list of keys of the cache
    }

    public void add(Node node){  // function to add the node to the double linked list of keys of the cache
        node.next = head.next;  // add the node to the double linked list of keys of the cache
        node.prev = head;  // add the node to the double linked list of keys of the cache
        head.next.prev = node;  // add the node to the double linked list of keys of the cache
        head.next = node;  // add the node to the double linked list of keys of the cache
    }

    class Node{  // class to represent the node of the double linked list of keys of the cache
        int key;  // variable to store the key
        int value;  // variable to store the value of the key
        Node prev;  // variable to store the previous node of the current node
        Node next;  // variable to store the next node of the current node
        public Node(int key, int value){  // constructor to initialize the key and the value of the key
            this.key = key;  // initialize the key
            this.value = value;  // initialize the value of the key
        }
        public Node(){  // constructor to initialize the key and the value of the key
        }
    }
}


3rd Method

class LRUCache extends LinkedHashMap<Integer, Integer>{       
    int capacity;
    public LRUCache(int capacity) {
        super(capacity, 1.0f, true);
        this.capacity = capacity;
    }
    
    public int get(int key) {
        return super.getOrDefault(key, -1);
    }
    
    public void put(int key, int value) {
        super.put(key, value);
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer,Integer> eldest){
        return this.size() > this.capacity;

    }
}


4th Method

// Time Complexity : O(1) for all the operations and space complexity is O(n) where n is the capacity of the cache

class LRUCache {
    class Node{
        int key;
        int value;
        Node prev;
        Node next;
        public Node(int key, int value){
            this.key = key;
            this.value = value;
        }
    }
    private void addToHead(Node node){
        node.next = head.next;
        node.prev = head;
        head.next.prev = node;
        head.next = node;
    }
    private void removeNode(Node node){
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    private Node popTail(){
        Node res = tail.prev;
        removeNode(res);
        return res;
    }
    private HashMap<Integer, Node> map;
    private int size;
    private int capacity;
    private Node head, tail;
    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        map = new HashMap<>();
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int key) {
        Node node = map.get(key);
        if(node == null) return -1;
        removeNode(node);
        addToHead(node);
        return node.value;
    }
    
    public void put(int key, int value) {
        Node node = map.get(key);
        if(node == null){
            Node newNode = new Node(key, value);
            map.put(key, newNode);
            addToHead(newNode);
            ++size;
            if(size > capacity){
                Node tail = popTail();
                map.remove(tail.key);
                --size;
            }
        }else{
            node.value = value;
            removeNode(node);
            addToHead(node);
        }
    }
}




1129. Shortest Path with Alternating Colors in c++ best Solution

// Time Complexity : O(n) where n is the number of edges and space complexity is O(n)

class Solution {
public:
    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& red_edges, vector<vector<int>>& blue_edges) {
        vector<vector<int>> red(n), blue(n);  // vector to store the red and blue edges
        for(auto edge : red_edges){  // iterate over the red edges
            red[edge[0]].push_back(edge[1]);  // add the edge to the red vector
        }
        for(auto edge : blue_edges){  // iterate over the blue edges
            blue[edge[0]].push_back(edge[1]);  // add the edge to the blue vector
        }
        vector<vector<int>> dist(n, vector<int>(2, INT_MAX));  // vector to store the distance of the nodes from the source node
        dist[0][0] = dist[0][1] = 0;  // initialize the distance of the source node to 0
        queue<pair<int, int>> q;  // queue to store the node and the color of the node
        q.push({0, 0});  // push the source node and the color of the node
        q.push({0, 1});  // push the source node and the color of the node
        while(!q.empty()){  // iterate over the queue
            auto [node, color] = q.front();  // get the node and the color of the node
            q.pop();  // pop the node and the color of the node
            for(auto next : (color ? red[node] : blue[node])){  // iterate over the edges of the node
                if(dist[next][color] == INT_MAX){  // if the distance of the node is INT_MAX
                    dist[next][color] = dist[node][!color] + 1;  // update the distance of the node
                    q.push({next, !color});  // push the node and the color of the node
                }
            }
        }
        vector<int> ans(n);  // vector to store the distance of the nodes from the source node
        for(int i = 0; i < n; i++){  // iterate over the vector
            ans[i] = min(dist[i][0], dist[i][1]);  // update the distance of the node
            if(ans[i] == INT_MAX){  // if the distance of the node is INT_MAX
                ans[i] = -1;  // update the distance of the node to -1
            }
        }
        return ans;  // return the distance of the nodes from the source node
    }
};


2nd Method 

class Solution {

public:
    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& red_edges, vector<vector<int>>& blue_edges) {
        vector<vector<int>> red(n);
        vector<vector<int>> blue(n);
        for(auto& edge : red_edges){
            red[edge[0]].push_back(edge[1]);
        }
        for(auto& edge : blue_edges){
            blue[edge[0]].push_back(edge[1]);
        }
        vector<vector<int>> dist(n , vector<int>(2 , INT_MAX));
        dist[0][0] = 0;
        dist[0][1] = 0;
        queue<pair<int , int>> q;
        q.push({0 , 0});
        q.push({0 , 1});
        while(!q.empty()){
            auto [node , color] = q.front();
            q.pop();
            if(color == 0){
                for(auto child : blue[node]){
                    if(dist[child][1] == INT_MAX){
                        dist[child][1] = dist[node][0] + 1;
                        q.push({child , 1});
                    }
                }
            }
            else{
                for(auto child : red[node]){
                    if(dist[child][0] == INT_MAX){
                        dist[child][0] = dist[node][1] + 1;
                        q.push({child , 0});
                    }
                }
            }
        }
        vector<int> ans(n);
        for(int i = 0 ; i < n ; i++){
            ans[i] = min(dist[i][0] , dist[i][1]);
            if(ans[i] == INT_MAX) ans[i] = -1;
        }
        return ans;
    }
};

1129. Shortest Path with Alternating Colors in java

// Time Complexity : O(n) where n is the number of edges and space complexity is O(n)

class Solution {
    public int[] shortestAlternatingPaths(int n, int[][] red_edges, int[][] blue_edges) {
        List<Integer>[] red = new List[n];  // list to store the red edges
        List<Integer>[] blue = new List[n];  // list to store the blue edges
        for(int i = 0; i < n; i++){  // iterate over the list
            red[i] = new ArrayList<>();  // initialize the list
            blue[i] = new ArrayList<>();  // initialize the list
        }
        for(int[] edge : red_edges){  // iterate over the red edges
            red[edge[0]].add(edge[1]);  // add the edge to the red list
        }
        for(int[] edge : blue_edges){  // iterate over the blue edges
            blue[edge[0]].add(edge[1]);  // add the edge to the blue list
        }
        int[][] dist = new int[n][2];  // array to store the distance of the nodes from the source node
        for(int i = 0; i < n; i++){  // iterate over the array
            Arrays.fill(dist[i], Integer.MAX_VALUE);  // fill the array with INT_MAX
        }
        dist[0][0] = dist[0][1] = 0;  // initialize the distance of the source node to 0
        Queue<int[]> q = new LinkedList<>();  // queue to store the node and the color of the node
        q.offer(new int[]{0, 0});  // push the source node and the color of the node
        q.offer(new int[]{0, 1});  // push the source node and the color of the node
        while(!q.isEmpty()){  // iterate over the queue
            int[] node = q.poll();  // get the node and the color of the node
            int color = node[1];  // get the color of the node
            for(int next : (color == 0 ? blue[node[0]] : red[node[0]])){  // iterate over the edges of the node
                if(dist[next][color] == Integer.MAX_VALUE){  // if the distance of the node is INT_MAX
                    dist[next][color] = dist[node[0]][1 - color] + 1;  // update the distance
                    q.offer(new int[]{next, 1 - color});  // push the node and the color of the node
                }
            }
        }
        int[] ans = new int[n];  // array to store the distance of the nodes from the source node
        for(int i = 0; i < n; i++){  // iterate over the array
            ans[i] = Math.min(dist[i][0], dist[i][1]);  // update the distance of the node
            if(ans[i] == Integer.MAX_VALUE){  // if the distance of the node is INT_MAX
                ans[i] = -1;  // update the distance of the node to -1
            }
        }
        return ans;  // return the distance of the nodes from the source node
    }
}


2nd Method 
class Solution {
    public int[] shortestAlternatingPaths(int n, int[][] red_edges, int[][] blue_edges) {
        List<Integer>[] red = new ArrayList[n];
        List<Integer>[] blue = new ArrayList[n];
        for(int i = 0 ; i < n ; i++){
            red[i] = new ArrayList<>();
            blue[i] = new ArrayList<>();
        }
        for(int[] edge : red_edges){
            red[edge[0]].add(edge[1]);
        }
        for(int[] edge : blue_edges){
            blue[edge[0]].add(edge[1]);
        }
        int[][] dist = new int[n][2];
        for(int i = 0 ; i < n ; i++){
            dist[i][0] = dist[i][1] = Integer.MAX_VALUE;
        }
        dist[0][0] = 0;
        dist[0][1] = 0;
        Queue<int[]> q = new LinkedList<>();
        q.add(new int[]{0 , 0});
        q.add(new int[]{0 , 1});
        while(!q.isEmpty()){
            int[] node = q.poll();
            if(node[1] == 0){
                for(int child : blue[node[0]]){
                    if(dist[child][1] == Integer.MAX_VALUE){
                        dist[child][1] = dist[node[0]][0] + 1;
                        q.add(new int[]{child , 1});
                    }
                }
            }
            else{
                for(int child : red[node[0]]){
                    if(dist[child][0] == Integer.MAX_VALUE){
                        dist[child][0] = dist[node[0]][1] + 1;
                        q.add(new int[]{child , 0});
                    }
                }
            }
        }
        int[] ans = new int[n];
        for(int i = 0 ; i < n ; i++){
            ans[i] = Math.min(dist[i][0] , dist[i][1]);
            if(ans[i] == Integer.MAX_VALUE) ans[i] = -1;
        }
        return ans;
    }
}




2477. Minimum Fuel Cost to Report to the Capital in c++ another Solution 

// Time Complexity : O(n) where n is the number of cities and space complexity is O(n) where n is the number of cities


class Solution {
public:
long long fuel;
int dfs(int node , int parent , vector<vector<int>>& g , int &seats){
    int representative = 1;
    for(auto child : g[node]){
        if(child == parent) continue;
        representative += dfs(child , node , g , seats);

    }
    if(node != 0){
        fuel += (representative + seats - 1) / seats;
    }
    return representative;
}
    

    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {
        int n = roads.size()+1;
        vector<vector<int>> g(n);
        for(auto& road : roads){
            g[road[0]].push_back(road[1]);
            g[road[1]].push_back(road[0]);
        }
        dfs(0 , -1 , g , seats);
        return fuel;

    }
};


  


2477. Minimum Fuel Cost to Report to the Capital in java

// Time Complexity : O(n) where n is the number of cities and space complexity is O(n) where n is the number of cities

class Solution {
    long fuel;
    public int dfs(int node , int parent , List<List<Integer>> g , int seats){
        int representative = 1;
        for(int child : g.get(node)){
            if(child == parent) continue;
            representative += dfs(child , node , g , seats);

        }
        if(node != 0){
            fuel += (representative + seats - 1) / seats;
        }
        return representative;
    }
    public long minimumFuelCost(int[][] roads, int seats) {
        int n = roads.length+1;
        List<List<Integer>> g = new ArrayList<>();
        for(int i = 0 ; i < n ; i++){
            g.add(new ArrayList<>());
        }
        for(int[] road : roads){
            g.get(road[0]).add(road[1]);
            g.get(road[1]).add(road[0]);
        }
        dfs(0 , -1 , g , seats);
        return fuel;

    }
}


433. Minimum Genetic Mutation in c++ another Solution

// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)

class Solution {
public:
    int minMutation(string start, string end, vector<string>& bank) {
        vector<int> vis(bank.size() , 0);
        queue<string> q;
        q.push(start);
        int ans = 0;
        while(!q.empty()){
            int size = q.size();
            while(size--){
                string node = q.front();
                q.pop();
                if(node == end) return ans;
                for(int i = 0 ; i < bank.size() ; i++){
                    if(vis[i]) continue;
                    int count = 0;
                    for(int j = 0 ; j < 8 ; j++){
                        if(node[j] != bank[i][j]) count++;
                    }
                    if(count == 1){
                        vis[i] = 1;
                        q.push(bank[i]);
                    }
                }
            }
            ans++;
        }
        return -1;
    }
};

433. Minimum Genetic Mutation in java

// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
    public int minMutation(String start, String end, String[] bank) {
        int n = bank.length;
        boolean[] vis = new boolean[n];
        Queue<String> q = new LinkedList<>();
        q.add(start);
        int ans = 0;
        while(!q.isEmpty()){
            int size = q.size();
            while(size-- > 0){
                String node = q.poll();
                if(node.equals(end)) return ans;
                for(int i = 0 ; i < n ; i++){
                    if(vis[i]) continue;
                    int count = 0;
                    for(int j = 0 ; j < 8 ; j++){
                        if(node.charAt(j) != bank[i].charAt(j)) count++;
                    }
                    if(count == 1){
                        vis[i] = true;
                        q.add(bank[i]);
                    }
                }
            }
            ans++;
        }
        return -1;
    }
}


1523. Count Odd Numbers in an Interval Range in c++

// Time Complexity : O(1) and space complexity is O(1)

class Solution {
public:
    int countOdds(int low, int high) {
        int count = 0;  // initialize the count to 0
        if(low % 2 == 0){  // if the low is even
            low++;  // increment the low
        }
        if(high % 2 == 0){  // if the high is even
            high--;  // decrement the high
        }
        if(low <= high){  // if the low is less than or equal to high
            count = (high - low) / 2 + 1;  // calculate the count
        }
        return count;  // return the count
    }
};



1523. Count Odd Numbers in an Interval Range in java

// Time Complexity : O(1) and space complexity is O(1)

class Solution {
    public int countOdds(int low, int high) {
        int count = 0;  // initialize the count to 0
        if(low % 2 == 0){  // if the low is even
            low++;  // increment the low
        }
        if(high % 2 == 0){  // if the high is even
            high--;  // decrement the high
        }
        if(low <= high){  // if the low is less than or equal to high
            count = (high - low) / 2 + 1;  // calculate the count
        }
        return count;  // return the count
    }
}


1531. String Compression II in c++

// Time Complexity : O(n^2) where n is the length of the string and space complexity is O(n^2)

class Solution {
public:
    int dp[101][101];      // dp array
    int dfs(string &s, int left, int K) {   // dfs function
        int k = K;    // k=K
        if(s.size() - left <= k) return 0;    // if condition is true
        if(dp[left][k] >= 0) return dp[left][k];    // if condition is true
        int res = k ? dfs(s, left + 1, k - 1) : 10000, c = 1;   // initialize res
        for(int i = left + 1; i <= s.size(); ++i) {   // loop for i                             
            res = min(res, dfs(s, i, k) + 1 + (c >= 100 ? 3 : (c >= 10 ? 2 : (c > 1 ? 1 :0))));  // res=min(res,dfs(s,i,k)+1+(c>=100?3:(c>=10?2:(c>1?1:0))))
            if(i == s.size()) break;    // if condition is true
            if(s[i] == s[left]) ++c;    // if condition is trued
            else if(--k < 0) break;    // else if condition is true
            
        }
        return dp[left][K] = res;   // return dp[left][K]=res
    }
    
    int getLengthOfOptimalCompression(string s, int k) {    // get length of optimal compression
        memset(dp, -1, sizeof(dp));   // memset
        return dfs(s, 0, k);    // return dfs(s,0,k)
    }
};


1531. String Compression II in java best Solution 

// Time Complexity : O(n^2) where n is the length of the string and space complexity is O(n^2)

class Solution {
    int[][] dp;   // dp array
    int dfs(String s, int left, int K) {   // dfs fon
        int k = K;   // k=K
        if(s.length() - left <= k) return 0;   // if condition is true
        if(dp[left][k] >= 0) return dp[left][k];   // if condition is true
        int res = k > 0 ? dfs(s, left + 1, k - 1) : 10000, c = 1;   // initialize res
        for(int i = left + 1; i <= s.length(); ++i) {   // loop for i
            res = Math.min(res, dfs(s, i, k) + 1 + (c >= 100 ? 3 : (c >= 10 ? 2 : (c > 1 ? 1 :0))));   // res=Math.min(res,dfs(s,i,k)+1+(c>=100?3:(c>=10?2:(c>1?1:0))))
            if(i == s.length()) break;   // if condition is true
            if(s.charAt(i) == s.charAt(left)) ++c;   // if condition is true
            else if(--k < 0) break;   // else if condition is true
        }
        return dp[left][K] = res;   // return dp[left][K]=res
    }
    
    public int getLengthOfOptimalCompression(String s, int k) {   // get length of optimal compression
        dp = new int[s.length()][k + 1];   // dp array
        for(int[] row : dp) Arrays.fill(row, -1);   // fill the dp array
        return dfs(s, 0, k);   // return dfs(s,0,k)
    }
}




67. Add Binary in c++

// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)

class Solution {
public:
    string addBinary(string a, string b) {
        int i = a.size() - 1, j = b.size() - 1, carry = 0;   // initialize i,j,carry
        string ans = "";   // initialize ans
        while(i >= 0 || j >= 0 || carry){   // loop for i,j,carry
            if(i >= 0) carry += a[i--] - '0';   // if condition is true
            if(j >= 0) carry += b[j--] - '0';   // if condition is true
            ans = to_string(carry % 2) + ans;   // ans=to_string(carry%2)+ans
            carry /= 2;   // carry/=2
        }
        return ans;   // return ans
    }
};


67. Add Binary in java
// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)

class Solution {
    public String addBinary(String a, String b) {
        int i = a.length() - 1, j = b.length() - 1, carry = 0;   // initialize i,j,carry
        StringBuilder ans = new StringBuilder();   // initialize ans
        while(i >= 0 || j >= 0 || carry > 0){   // loop for i,j,carry
            if(i >= 0) carry += a.charAt(i--) - '0';   // if condition is true
            if(j >= 0) carry += b.charAt(j--) - '0';   // if condition is true
            ans.append(carry % 2);   // ans.append(carry%2)
            carry /= 2;   // carry/=2
        }
        return ans.reverse().toString();   // return ans.reverse().toString()
    }
}


989. Add to Array-Form of Integer in c++


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
public:
    vector<int> addToArrayForm(vector<int>& num , int k){
        int n = num.size();   // initialize n
        vector<int> ans;   // initialize ans
        for(int i = n - 1; i >= 0; --i){   // loop for i
            ans.push_back((num[i] + k) % 10);   // ans.push_back((num[i]+k)%10)
            k = (num[i] + k) / 10;   // k=(num[i]+k)/10
        }
        while(k){   // loop for k
            ans.push_back(k % 10);   // ans.push_back(k%10)
            k /= 10;   // k/=10
        }
        reverse(ans.begin(), ans.end());   // reverse(ans.begin(),ans.end())
        return ans;   // return ans
    }
};

989. Add to Array-Form of Integer in java

// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)

class Solution {
    public List<Integer> addToArrayForm(int[] num, int k) {
        int n = num.length;   // initialize n
        List<Integer> ans = new ArrayList<>();   // initialize ans
        for(int i = n - 1; i >= 0; --i){   // loop for i
            ans.add((num[i] + k) % 10);   // ans.add((num[i]+k)%10)
            k = (num[i] + k) / 10;   // k=(num[i]+k)/10
        }
        while(k > 0){   // loop for k
            ans.add(k % 10);   // ans.add(k%10)
            k /= 10;   // k/=10
        }
        Collections.reverse(ans);   // Collections.reverse(ans)
        return ans;   // return ans
    }
}




2131. Longest Palindrome by Concatenating Two Letter Words in c++

// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)
class Solution {
public:
    int longestPalindrome(vector<string>& words) {
        
       int count[26][26] = {}; 
       int ans =0;
        
			for(auto w : words){
				int a = w[0] - 'a';
				int b = w[1] - 'a'; 

				if(count[b][a]){
					ans+= 4;          
					count[b][a]--;   // decrement the count as we found mirror word
				}else
					count[a][b]++;  //increment the current word count if we not find any mirror word
			}
        
			for(int i=0;i<26;i++){
				if(count[i][i]){
					ans+=2;
					break;
				}
			 }
      
	return ans;

    }
};


In Java


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)

class Solution {
    public int longestPalindrome(String[] words) {
        int[][] count = new int[26][26];   // count array
        int ans = 0;   // initialize ans
        for(String w : words) {   // loop for w
            int a = w.charAt(0) - 'a';   // a=w.charAt(0)-'a'
            int b = w.charAt(1) - 'a';   // b=w.charAt(1)-'a'
            if(count[b][a] > 0) {   // if condition is true
                ans += 4;   // ans+=4
                count[b][a]--;   // decrement the count as we found mirror word
            } else count[a][b]++;   // increment the current word count if we not find any mirror word
        }
        for(int i = 0; i < 26; ++i) if(count[i][i] > 0) {   // loop for i
            ans += 2;   // ans+=2
            break;
        }
        return ans;   // return ans
    }
}



212. Word Search II in c++ Another Solution passes all test cases 

// Time Complexity : O(n*m) where n is the number of rows and m is the number of columns and space complexity is O(n*m)

class Solution {
public:
    bool dfs(int ind , int indi , int indj , vector<vector<char>>& board , string &search , int &row , int &col){
        if(ind == search.size()){
            return true;
        }
        if(indi >= 0 && indi < row && indj>=0 && indj<col){
            if(board[indi][indj] != search[ind]){
                return false;
            }
            char originalchar = board[indi][indj];
            board[indi][indj] = '$';
            bool ans = dfs(ind+1 , indi+1  , indj , board , search , row , col) ||
            dfs(ind+1 , indi-1  , indj , board , search , row , col) ||
            dfs(ind+1 , indi  , indj+1 , board , search , row , col) ||
            dfs(ind+1 , indi  , indj-1 , board , search , row , col);

            board[indi][indj] = originalchar;
            return ans;
        }
        else
            return false;
    }
    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        int row = board.size();
        int col = board[0].size();
        vector<string> ans;
        vector<vector<pair<int , int>>> v(26);
        for(int i=0 ; i<row ; i++){
            for(int j=0; j<col ; j++){
                v[board[i][j] - 'a'].push_back({i , j});
            }
        }
        int start = 0 , end = 0;
        
            for(auto word : words){
                if(word[0] == 'a')
                    start++;
                if(word[word.size()-1] == 'a')
                    end++;     
            }
            bool reversehaikya = false;
            if(start > end){
                for(int i=0 ; i<words.size(); i++){
                    reversehaikya = true;
                    reverse(words[i].begin() , words[i].end());
                }
            }
        for(auto search : words){
            bool flag = false;
            for(auto ele : v[search[0] - 'a']){
                flag = dfs(0 , ele.first , ele.second , board , search , row , col);
                if(flag){
                    if(reversehaikya)
                        reverse(search.begin() , search.end());
                        ans.push_back(search);
                       break;
                }
            }
        }
        return ans;
    }
};


In Java code passes all test cases 

// Time Complexity : O(n*m) where n is the number of rows and m is the number of columns and space complexity is O(n*m)

class Solution {
    public boolean dfs(int ind , int indi , int indj , char[][] board , String search , int row , int col){
        if(ind == search.length()){
            return true;
        }
        if(indi >= 0 && indi < row && indj>=0 && indj<col){
            if(board[indi][indj] != search.charAt(ind)){
                return false;
            }
            char originalchar = board[indi][indj];
            board[indi][indj] = '$';
            boolean ans = dfs(ind+1 , indi+1  , indj , board , search , row , col) ||
            dfs(ind+1 , indi-1  , indj , board , search , row , col) ||
            dfs(ind+1 , indi  , indj+1 , board , search , row , col) ||
            dfs(ind+1 , indi  , indj-1 , board , search , row , col);

            board[indi][indj] = originalchar;
            return ans;
        }
        else
            return false;
    }
    public List<String> findWords(char[][] board, String[] words) {
        int row = board.length;
        int col = board[0].length;
        List<String> ans = new ArrayList<>();
        List<List<Pair<Integer , Integer>>> v = new ArrayList<>();
        for(int i=0 ; i<26 ; i++){
            v.add(new ArrayList<>());
        }
        for(int i=0 ; i<row ; i++){
            for(int j=0; j<col ; j++){
                v.get(board[i][j] - 'a').add(new Pair<>(i , j));
            }
        }
        int start = 0 , end = 0;
        
            for(String word : words){
                if(word.charAt(0) == 'a')
                    start++;
                if(word.charAt(word.length()-1) == 'a')
                    end++;     
            }
            boolean reversehaikya = false;
            if(start > end){
                for(int i=0 ; i<words.length; i++){
                    reversehaikya = true;
                    words[i] = new StringBuilder(words[i]).reverse().toString();
                }
            }
        for(String search : words){
            boolean flag = false;
            for(Pair<Integer , Integer> ele : v.get(search.charAt(0) - 'a')){
                flag = dfs(0 , ele.getKey() , ele.getValue() , board , search , row , col);
                if(flag){
                    if(reversehaikya)
                        search = new StringBuilder(search).reverse().toString();
                        ans.add(search);
                       break;
                }
            }
        }
        return ans;
    }
}



104. Maximum Depth of Binary Tree IN C++

// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(!root) return 0;   // if condition is true
        return 1 + max(maxDepth(root->left), maxDepth(root->right));   // return 1+max(maxDepth(root->left),maxDepth(root->right))
    }
};


104. Maximum Depth of Binary Tree IN JAVA


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;   // if condition is true
        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));   // return 1+Math.max(maxDepth(root.left),maxDepth(root.right))
    }
};


783. Minimum Distance Between BST Nodes in c++

// Time Complexity : O(n) where n is the number of nodes in the tree and space complexity is O(n)


class Solution {
public:
    int minDiffInBST(TreeNode* root) {
        vector<int> v;   // vector<int> v
        inorder(root , v);   // inorder(root,v)
        int ans = INT_MAX;   // int ans=INT_MAX
        for(int i=1 ; i<v.size() ; i++){   // for(int i=1;i<v.size();i++)
            ans = min(ans , v[i] - v[i-1]);   // ans=min(ans,v[i]-v[i-1])
        }
        return ans;   // return ans
    }
    void inorder(TreeNode* root , vector<int>& v){   // void inorder(TreeNode* root,vector<int>& v)
        if(!root) return;   // if condition is true
        inorder(root->left , v);   // inorder(root->left,v)
        v.push_back(root->val);   // v.push_back(root->val)
        inorder(root->right , v);   // inorder(root->right,v)
    }

};


783. Minimum Distance Between BST Nodes in java


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
    public int minDiffInBST(TreeNode root) {
        List<Integer> v = new ArrayList<>();   // List<Integer> v=new ArrayList<>();
        inorder(root , v);   // inorder(root,v)
        int ans = Integer.MAX_VALUE;   // int ans=Integer.MAX_VALUE
        for(int i=1 ; i<v.size() ; i++){   // for(int i=1;i<v.size();i++)
            ans = Math.min(ans , v.get(i) - v.get(i-1));   // ans=Math.min(ans,v.get(i)-v.get(i-1))
        }
        return ans;   // return ans
    }
    public void inorder(TreeNode root , List<Integer> v){   // public void inorder(TreeNode root,List<Integer> v)
        if(root == null) return;   // if condition is true
        inorder(root.left , v);   // inorder(root.left,v)
        v.add(root.val);   // v.add(root.val)
        inorder(root.right , v);   // inorder(root.right,v)
    }
};



226. Invert Binary Tree in c++

// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root) return NULL;   // if condition is true
       invertTree(root->left);   // invertTree(root->left)
         invertTree(root->right);   // invertTree(root->right)
          TreeNode* temp = root->left;   // TreeNode* temp=root->left
          root->left = root->right;   // root->left=root->right
          root->right = temp;   // root->right=temp
          return root;   // return root
};

226. Invert Binary Tree in java


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return null;   // if condition is true
        invertTree(root.left);   // invertTree(root.left)
        invertTree(root.right);   // invertTree(root.right)
        TreeNode temp = root.left;   // TreeNode temp=root.left
        root.left = root.right;   // root.left=root.right
        root.right = temp;   // root.right=temp
        return root;   // return root
    }
};

103. Binary Tree Zigzag Level Order Traversal in c++

// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> ans;   // initialize ans
        if(!root) return ans;   // if condition is true
        queue<TreeNode*> q;   // initialize q
        q.push(root);   // q.push(root)
        int level = 0;   // initialize level
        while(!q.empty()){   // loop for q
            int size = q.size();   // int size=q.size()
            vector<int> temp;   // initialize temp
            for(int i = 0; i < size; ++i){   // loop for i
                TreeNode* node = q.front();   // TreeNode* node=q.front()
                q.pop();   // q.pop()
                temp.push_back(node->val);   // temp.push_back(node->val)
                if(node->left) q.push(node->left);   // if condition is true
                if(node->right) q.push(node->right);   // if condition is true
            }
            if(level % 2 == 1) reverse(temp.begin(), temp.end());   // if condition is true
            ans.push_back(temp);   // ans.push_back(temp)
            level++;   // level++
        }
        return ans;   // return ans
    }
};

2nd Method:


// Time Complexity : O(n) where n is the number of nodes in the tree and space complexity is O(n)

class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        if(root == NULL)
            return ans;
        queue<TreeNode*> q;
        q.push(root);
        bool reversehaikya = false;
        while(!q.empty()){
            int size = q.size();
            vector<int> v;
            for(int i=0 ; i<size ; i++){
                TreeNode* temp = q.front();
                q.pop();
                v.push_back(temp->val);
                if(temp->left)
                    q.push(temp->left);
                if(temp->right)
                    q.push(temp->right);
            }
            if(reversehaikya)
                reverse(v.begin() , v.end());
            reversehaikya = !reversehaikya;
            ans.push_back(v);
        }
        return ans;
        
    }
};




103. Binary Tree Zigzag Level Order Traversal in java


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();   // initialize ans
        if(root == null) return ans;   // if condition is true
        Queue<TreeNode> q = new LinkedList<>();   // initialize q
        q.add(root);   // q.add(root)
        int level = 0;   // initialize level
        while(!q.isEmpty()){   // loop for q
            int size = q.size();   // int size=q.size()
            List<Integer> temp = new ArrayList<>();   // initialize temp
            for(int i = 0; i < size; ++i){   // loop for i
                TreeNode node = q.poll();   // TreeNode node=q.poll()
                temp.add(node.val);   // temp.add(node.val)
                if(node.left != null) q.add(node.left);   // if condition is true
                if(node.right != null) q.add(node.right);   // if condition is true
            }
            if(level % 2 == 1) Collections.reverse(temp);   // if condition is true
            ans.add(temp);   // ans.add(temp)
            level++;   // level++
        }
        return ans;   // return ans
    }
};


2nd Method:

class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if(root == null) return ans;
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        boolean reversehaiKya = false;
        while(!q.isEmpty()){
            int size = q.size();
            List<Integer> temp = new ArrayList<>();
            for(int i=0; i<size ; i++){
                TreeNode node = q.poll();
                temp.add(node.val);
                if(node.left != null) q.add(node.left);
                if(node.right != null) q.add(node.right);
            }
            if(reversehaiKya) Collections.reverse(temp);
            reversehaiKya = !reversehaiKya;
            ans.add(temp);
           
        }
        return ans;
    }
}


35. Search Insert Position in c++

// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();   // int n=nums.size()
        int l = 0, r = n - 1;   // int l=0,r=n-1
        while(l <= r){   // loop for l and r
            int mid = l + (r - l) / 2;   // int mid=l+(r-l)/2
            if(nums[mid] == target) return mid;   // if condition is true
            else if(nums[mid] < target) l = mid + 1;   // else if condition is true
            else r = mid - 1;   // else condition is true
        }
        return l;   // return l
    }
};



35. Search Insert Position in java


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
    public int searchInsert(int[] nums, int target) {
        int n = nums.length;   // int n=nums.length
        int l = 0, r = n - 1;   // int l=0,r=n-1
        while(l <= r){   // loop for l and r
            int mid = l + (r - l) / 2;   // int mid=l+(r-l)/2
            if(nums[mid] == target) return mid;   // if condition is true
            else if(nums[mid] < target) l = mid + 1;   // else if condition is true
            else r = mid - 1;   // else condition is true
        }
        return l;   // return l
    }
};











540. Single Element in a Sorted Array  in c++


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int n = nums.size();   // int n=nums.size()
        int l = 0, r = n - 1;   // int l=0,r=n-1
        while(l < r){   // loop for l and r
            int mid = l + (r - l) / 2;   // int mid=l+(r-l)/2
            if(mid % 2 == 1) mid--;   // if condition is true
            if(nums[mid] == nums[mid + 1]) l = mid + 2;   // if condition is true
            else r = mid;   // else condition is true
        }
        return nums[l];   // return nums[l]
    }
};



540. Single Element in a Sorted Array  in java


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
    public int singleNonDuplicate(int[] nums) {
        int n = nums.length;   // int n=nums.length
        int l = 0, r = n - 1;   // int l=0,r=n-1
        while(l < r){   // loop for l and r
            int mid = l + (r - l) / 2;   // int mid=l+(r-l)/2
            if(mid % 2 == 1) mid--;   // if condition is true
            if(nums[mid] == nums[mid + 1]) l = mid + 2;   // if condition is true
            else r = mid;   // else condition is true
        }
        return nums[l];   // return nums[l]
    }
};







899. Orderly Queue in c++

// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)

class Solution {
public:
    string orderlyQueue(string s, int k) {
        if(k > 1){   // if condition is true
            sort(s.begin(), s.end());   // sort(s.begin(),s.end())
            return s;   // return s
        }
        string ans = s;   // string ans=s
        for(int i = 0; i < s.size(); ++i){   // loop for i
            string temp = s.substr(i) + s.substr(0, i);   // string temp=s.substr(i)+s.substr(0,i)
            ans = min(ans, temp);   // ans=min(ans,temp)
        }
        return ans;   // return ans
    }
};



899. Orderly Queue in java


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
    public String orderlyQueue(String s, int k) {
        if(k > 1){   // if condition is true
            char[] arr = s.toCharArray();   // char[] arr=s.toCharArray()
            Arrays.sort(arr);   // Arrays.sort(arr)
            return new String(arr);   // return new String(arr)
        }
        String ans = s;   // String ans=s
        for(int i = 0; i < s.length(); ++i){   // loop for i
            String temp = s.substring(i) + s.substring(0, i);   // String temp=s.substring(i)+s.substring(0,i)
            if(ans.compareTo(temp) > 0) ans = temp;   // if condition is true
        }
        return ans;   // return ans
    }
};



1323. Maximum 69 Number in c++


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
public:
    int maximum69Number (int num) {
        string s = to_string(num);   // string s=to_string(num)
        for(int i = 0; i < s.size(); ++i){   // loop for i
            if(s[i] == '6'){   // if condition is true
                s[i] = '9';   // s[i]='9'
                break;   // break
            }
        }
        return stoi(s);   // return stoi(s)
    }
};



1323. Maximum 69 Number in java


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
    public int maximum69Number (int num) {
        String s = String.valueOf(num);   // String s=String.valueOf(num)
        for(int i = 0; i < s.length(); ++i){   // loop for i
            if(s.charAt(i) == '6'){   // if condition is true
                s = s.substring(0, i) + '9' + s.substring(i + 1);   // s=s.substring(0,i)+'9'+s.substring(i+1)
                break;   // break
            }
        }
        return Integer.parseInt(s);   // return Integer.parseInt(s)
    }
};


2nd Method :


class Solution {
    public int maximum69Number (int num) {
    char arr[] = String.valueOf(num).toCharArray(); 

	for(int i =0;i<arr.length;i++){
        if(arr[i]=='6'){                        
			arr[i]='9';
            break;
        }
    }
	return Integer.parseInt(new String(arr));
    }
}


3rd Method :


class Solution {
    public int maximum69Number (int num) {
        return Integer.parseInt(("" + num).replaceFirst("6"  , "9"));
    }
}



1544. Make The String Great in c++

// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
public:
    string makeGood(string s) {
        stack<char> st;   // stack<char> st
        for(char c : s){   // loop for c
            if(!st.empty() && abs(st.top() - c) == 32) st.pop();   // if condition is true 
            else st.push(c);   // else condition is true
        }
        string ans = "";   // string ans=""
        while(!st.empty()){   // loop for st
            ans = st.top() + ans;   // ans=st.top()+ans
            st.pop();   // st.pop()
        }
        return ans;   // return ans
    }
};




2nd Method:



class Solution {
public:
    string makeGood(string s) {
        
        string ans;
        
        for(int i = 0 ; i < s.size() ; i++)
        {
            ans.push_back(s[i]);
            
            while(ans.size() && (ans.back()==s[i+1]+32 || ans.back()==s[i+1]-32))
            {
                ans.pop_back();
                i++;
            }
        }
        
        return ans;
    }
};





1544. Make The String Great in java


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
    public String makeGood(String s) {
        Stack<Character> st = new Stack<>();   // Stack<Character> st=new Stack<>()
        for(char c : s.toCharArray()){   // loop for c
            if(!st.isEmpty() && Math.abs(st.peek() - c) == 32) st.pop();   // if condition is true
            else st.push(c);   // else condition is true
        }
        StringBuilder ans = new StringBuilder();   // StringBuilder ans=new StringBuilder()
        while(!st.isEmpty()){   // loop for st
            ans.append(st.pop());   // ans.append(st.pop())
        }
        return ans.reverse().toString();   // return ans.reverse().toString()
    }
};


2nd Method:



class Solution {
    public String makeGood(String s) {
        
        String ans = "";
        
        for(int i = 0 ; i < s.length() ; i++)
        {
            ans += s.charAt(i);

            while(ans.length() > 0 && i+1 < s.length() && (ans.charAt(ans.length()-1)==s.charAt(i+1)+32 || ans.charAt(ans.length()-1)==s.charAt(i+1)-32))
            {
                ans = ans.substring(0,ans.length()-1);
                i++;
            }
        }
        
        return ans;
    }
};



901. Online Stock Span in c++

// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class StockSpanner {
public:
    stack<pair<int, int>> st;   // stack<pair<int,int>> st
    StockSpanner() {
        
    }
    
    int next(int price) {
        int ans = 1;   // int ans=1
        while(!st.empty() && st.top().first <= price){   // loop for st
            ans += st.top().second;   // ans+=st.top().second
            st.pop();   // st.pop()
        }
        st.push({price, ans});   // st.push({price,ans})
        return ans;   // return ans
    }
};


901. Online Stock Span in java


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class StockSpanner {
    Stack<int[]> st;   // Stack<int[]> st
    public StockSpanner() {
        st = new Stack<>();   // st=new Stack<>()
    }
    
    public int next(int price) {
        int ans = 1;   // int ans=1
        while(!st.isEmpty() && st.peek()[0] <= price){   // loop for st
            ans += st.peek()[1];   // ans+=st.peek()[1]
            st.pop();   // st.pop()
        }
        st.push(new int[]{price, ans});   // st.push(new int[]{price,ans})
        return ans;   // return ans
    }
};



1047. Remove All Adjacent Duplicates In String in c++


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
public:
    string removeDuplicates(string s) {
        stack<char> st;   // stack<char> st
        for(char c : s){   // loop for c
            if(!st.empty() && st.top() == c) st.pop();   // if condition is true
            else st.push(c);   // else condition is true
        }
        string ans = "";   // string ans=""
        while(!st.empty()){   // loop for st
            ans = st.top() + ans;   // ans=st.top()+ans
            st.pop();   // st.pop()
        }
        return ans;   // return ans
    }
};

2nd Method :


class Solution {
public:
    string removeDuplicates(string s) {
        string ans;
        for(int i=0 ; i<s.size(); i++){
            if(ans.back() == s[i]){
                ans.pop_back();
            }
            else{
                ans += s[i];
            }
        }
        return ans;

    }
};





1047. Remove All Adjacent Duplicates In String in java


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
    public String removeDuplicates(String s) {
        Stack<Character> st = new Stack<>();   // Stack<Character> st=new Stack<>()
        for(char c : s.toCharArray()){   // loop for c
            if(!st.isEmpty() && st.peek() == c) st.pop();   // if condition is true
            else st.push(c);   // else condition is true
        }
        StringBuilder ans = new StringBuilder();   // StringBuilder ans=new StringBuilder()
        while(!st.isEmpty()){   // loop for st
            ans.append(st.pop());   // ans.append(st.pop())
        }
        return ans.reverse().toString();   // return ans.reverse().toString()
    }
};


2nd Method:

class Solution {
    public String removeDuplicates(String s) {
        StringBuilder ans = new StringBuilder();
        for(int i=0 ; i<s.length(); i++){
            if(ans.length() > 0 && ans.charAt(ans.length()-1) == s.charAt(i)){
                ans.deleteCharAt(ans.length()-1);
            }
            else{
                ans.append(s.charAt(i));
            }
        }
        return ans.toString();

    }
};



1011. Capacity To Ship Packages Within D Days in c++

// Time Complexity : O(nlogn) where n is the number of weights and space complexity is O(1)

class Solution {
public:
    bool isPossible(vector<int>& weights, int D, int mid){  // function to check if the weights can be shipped in D days
        int days = 1;  // variable to store the number of days
        int sum = 0;  // variable to store the sum of the weights
        for(int i = 0; i < weights.size(); i++){  // iterate over the weights
            if(weights[i] > mid){  // if the weight is greater than the mid
                return false;  // return false
            }
            if(sum + weights[i] > mid){  // if the sum of the weights is greater than the mid
                days++;  // increment the number of days
                sum = 0;  // reset the sum
            }
            sum += weights[i];  // add the weight to the sum
        }
        return days <= D;  // return true if the number of days is less than or equal to D
    }
    int shipWithinDays(vector<int>& weights, int D) {
        int low = *max_element(weights.begin(), weights.end());  // variable to store the minimum weight  
        int high = accumulate(weights.begin(), weights.end(), 0);  // variable to store the sum of the weights
        while(low < high){  // iterate until the low is less than the high
            int mid = low + (high - low) / 2;  // variable to store the mid
            if(isPossible(weights, D, mid)){  // if the weights can be shipped in D days
                high = mid;  // update the high
            }
            else{
                low = mid + 1;  // update the low
            }
        }
        return low;  // return the low
    }
};

2nd Method beat 100% 

class Solution {
public:
    int shipWithinDays(vector<int>& weights, int D) {
        int low = *max_element(weights.begin(), weights.end());  // variable to store the minimum weight
        int high = accumulate(weights.begin(), weights.end(), 0);  // variable to store the sum of the weights
        while(low < high){  // iterate until the low is less than the high
            int mid = low + (high - low) / 2;  // variable to store the mid
            int days = 1;  // variable to store the number of days
            int sum = 0;  // variable to store the sum of the weights
            for(int i = 0; i < weights.size(); i++){  // iterate over the weights
                if(sum + weights[i] > mid){  // if the sum of the weights is greater than the mid
                    days++;  // increment the number of days
                    sum = 0;  // reset the sum
                }
                sum += weights[i];  // add the weight to the sum
            }
            if(days <= D){  // if the number of days is less than or equal to D
                high = mid;  // update the high
            }
            else{
                low = mid + 1;  // update the low
            }
        }
        return low;  // return the low
    }
};

3rd Method:
class Solution {
public:
    int shipWithinDays(vector<int>& weights, int D) {
        int left = *max_element(weights.begin(), weights.end());
        int right = accumulate(weights.begin(), weights.end(), 0);
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            int days = 1, current_weight = 0;
            
            for (int weight : weights) {
                current_weight += weight;
                if (current_weight > mid) {
                    days++;
                    current_weight = weight;
                }
            }
            
            if (days <= D) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        
        return left;
    }
};


1011. Capacity To Ship Packages Within D Days in java


// Time Complexity : O(nlogn) where n is the number of weights and space complexity is O(1)


class Solution {
    public boolean isPossible(int[] weights, int D, int mid){  // function to check if the weights can be shipped in D days
        int days = 1;  // variable to store the number of days
        int sum = 0;  // variable to store the sum of the weights
        for(int i = 0; i < weights.length; i++){  // iterate over the weights
            if(weights[i] > mid){  // if the weight is greater than the mid
                return false;  // return false
            }
            if(sum + weights[i] > mid){  // if the sum of the weights is greater than the mid
                days++;  // increment the number of days
                sum = 0;  // reset the sum
            }
            sum += weights[i];  // add the weight to the sum
        }
        return days <= D;  // return true if the number of days is less than or equal to D
    }
    public int shipWithinDays(int[] weights, int D) {
        int low = Arrays.stream(weights).max().getAsInt();  // variable to store the minimum weight
        int high = Arrays.stream(weights).sum();  // variable to store the sum of the weights
        while(low < high){  // iterate until the low is less than the high
            int mid = low + (high - low) / 2;  // variable to store the mid
            if(isPossible(weights, D, mid)){  // if the weights can be shipped in D days
                high = mid;  // update the high
            }
            else{
                low = mid + 1;  // update the low
            }
        }
        return low;  // return the low
    }
};



2nd Method:

class Solution {
    public int shipWithinDays(int[] weights, int D) {
        int low = Arrays.stream(weights).max().getAsInt();  // variable to store the minimum weight
        int high = Arrays.stream(weights).sum();  // variable to store the sum of the weights
        while(low < high){  // iterate until the low is less than the high
            int mid = low + (high - low) / 2;  // variable to store the mid
            int days = 1;  // variable to store the number of days
            int sum = 0;  // variable to store the sum of the weights
            for(int i = 0; i < weights.length; i++){  // iterate over the weights
                if(sum + weights[i] > mid){  // if the sum of the weights is greater than the mid
                    days++;  // increment the number of days
                    sum = 0;  // reset the sum
                }
                sum += weights[i];  // add the weight to the sum
            }
            if(days <= D){  // if the number of days is less than or equal to D
                high = mid;  // update the high
            }
            else{
                low = mid + 1;  // update the low
            }
        }
        return low;  // return the low
    }
};


3rd Method :



class Solution {
    public int shipWithinDays(int[] weights, int D) {
        int left = Arrays.stream(weights).max().getAsInt();
        int right = Arrays.stream(weights).sum();
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            int days = 1, current_weight = 0;
            
            for (int weight : weights) {
                current_weight += weight;
                if (current_weight > mid) {
                    days++;
                    current_weight = weight;
                }
            }
            
            if (days <= D) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        
        return left;
    }
};



502. IPO in c++

// Time Complexity : O(nlogn) where n is the number of projects and space complexity is O(n)

class Solution {
public:
    int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {
        vector<pair<int, int>> projects;  // vector to store the projects
        for(int i = 0; i < profits.size(); i++){  // iterate over the profits
            projects.push_back({capital[i], profits[i]});  // push the capital and the profit of the project
        }
        sort(projects.begin(), projects.end());  // sort the projects based on the capital
        priority_queue<int> pq;  // max heap to store the profits
        int i = 0;  // variable to store the index
        while(k--){  // iterate k times
            while(i < projects.size() && projects[i].first <= w){  // iterate until the index is less than the size of the projects and the capital is less than or equal to w
                pq.push(projects[i].second);  // push the profit of the project
                i++;  // increment the index
            }
            if(pq.empty()){  // if the max heap is empty
                break;  // break
            }
            w += pq.top();  // add the top of the max heap to w
            pq.pop();  // pop the top of the max heap
        }
        return w;  // return w
        
    }
};


2nd Method:

class Solution {
public:
    int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {
        vector<pair<int, int>> projects;  // vector to store the projects
        for(int i = 0; i < profits.size(); i++){  // iterate over the profits
            projects.push_back({capital[i], profits[i]});  // push the capital and the profit of the project
        }
        sort(projects.begin(), projects.end());  // sort the projects based on the capital
        priority_queue<int> pq;  // max heap to store the profits
        int i = 0;  // variable to store the index
        for(int j = 0; j < k; j++){  // iterate k times
            while(i < projects.size() && projects[i].first <= w){  // iterate until the index is less than the size of the projects and the capital is less than or equal to w
                pq.push(projects[i].second);  // push the profit of the project
                i++;  // increment the index
            }
            if(pq.empty()){  // if the max heap is empty
                break;  // break
            }
            w += pq.top();  // add the top of the max heap to w
            pq.pop();  // pop the top of the max heap
        }
        return w;  // return w
        
    }
};



502. IPO in java

// Time Complexity : O(nlogn) where n is the number of projects and space complexity is O(n)


class Solution {
    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
        int[][] projects = new int[profits.length][2];  // array to store the projects
        for(int i = 0; i < profits.length; i++){  // iterate over the profits
            projects[i][0] = capital[i];  // store the capital of the project
            projects[i][1] = profits[i];  // store the profit of the project
        }
        Arrays.sort(projects, (a, b) -> a[0] - b[0]);  // sort the projects based on the capital
        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);  // max heap to store the profits
        int i = 0;  // variable to store the index
        while(k-- > 0){  // iterate k times
            while(i < projects.length && projects[i][0] <= w){  // iterate until the index is less than the size of the projects and the capital is less than or equal to w
                pq.add(projects[i][1]);  // add the profit of the project
                i++;  // increment the index
            }
            if(pq.isEmpty()){  // if the max heap is empty
                break;  // break
            }
            w += pq.poll();  // add the top of the max heap to w
        }
        return w;  // return w
    }
};



2nd Method:

class Solution {
    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
        int[][] projects = new int[profits.length][2];  // array to store the projects
        for(int i = 0; i < profits.length; i++){  // iterate over the profits
            projects[i][0] = capital[i];  // store the capital of the project
            projects[i][1] = profits[i];  // store the profit of the project
        }
        Arrays.sort(projects, (a, b) -> a[0] - b[0]);  // sort the projects based on the capital
        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);  // max heap to store the profits
        int i = 0;  // variable to store the index
        for(int j = 0; j < k; j++){  // iterate k times
            while(i < projects.length && projects[i][0] <= w){  // iterate until the index is less than the size of the projects and the capital is less than or equal to w
                pq.add(projects[i][1]);  // add the profit of the project
                i++;  // increment the index
            }
            if(pq.isEmpty()){  // if the max heap is empty
                break;  // break
            }
            w += pq.poll();  // add the top of the max heap to w
        }
        return w;  // return w
    }
};



295. Find Median from Data Stream  in c++


// Time Complexity : O(logn) where n is the number of elements in the stream and space complexity is O(n)


class MedianFinder {
public:
    /** initialize your data structure here. */
    priority_queue<int> maxHeap;  // max heap to store the first half of the stream
    priority_queue<int, vector<int>, greater<int>> minHeap;  // min heap to store the second half of the stream
    MedianFinder() {
        
    }
    
    void addNum(int num) {
        if(maxHeap.empty() || num < maxHeap.top()){  // if the max heap is empty or the number is less than the top of the max heap
            maxHeap.push(num);  // push the number to the max heap
        } else {  // else
            minHeap.push(num);  // push the number to the min heap
        }
        if(maxHeap.size() > minHeap.size() + 1){  // if the size of the max heap is greater than the size of the min heap by 1
            minHeap.push(maxHeap.top());  // push the top of the max heap to the min heap
            maxHeap.pop();  // pop the top of the max heap
        } else if(minHeap.size() > maxHeap.size() + 1){  // else if the size of the min heap is greater than the size of the max heap by 1
            maxHeap.push(minHeap.top());  // push the top of the min heap to the max heap
            minHeap.pop();  // pop the top of the min heap
        }
    }
    
    double findMedian() {
        if(maxHeap.size() == minHeap.size()){  // if the size of the max heap is equal to the size of the min heap
            return (maxHeap.top() + minHeap.top()) / 2.0;  // return the average of the top of the max heap and the top of the min heap
        } else if(maxHeap.size() > minHeap.size()){  // else if the size of the max heap is greater than the size of the min heap
            return maxHeap.top();  // return the top of the max heap
        } else {  // else
            return minHeap.top();  // return the top of the min heap
        }
    }
};



295. Find Median from Data Stream in java


// Time Complexity : O(logn) where n is the number of elements in the stream and space complexity is O(n)


class MedianFinder {
    PriorityQueue<Integer> maxHeap;  // max heap to store the first half of the stream
    PriorityQueue<Integer> minHeap;  // min heap to store the second half of the stream
    /** initialize your data structure here. */
    public MedianFinder() {
        maxHeap = new PriorityQueue<>((a, b) -> b - a);  // max heap to store the first half of the stream
        minHeap = new PriorityQueue<>();  // min heap to store the second half of the stream
    }
    
    public void addNum(int num) {
        if(maxHeap.isEmpty() || num < maxHeap.peek()){  // if the max heap is empty or the number is less than the top of the max heap
            maxHeap.add(num);  // add the number to the max heap
        } else {  // else
            minHeap.add(num);  // add the number to the min heap
        }
        if(maxHeap.size() > minHeap.size() + 1){  // if the size of the max heap is greater than the size of the min heap by 1
            minHeap.add(maxHeap.poll());  // add the top of the max heap to the min heap
        } else if(minHeap.size() > maxHeap.size() + 1){  // else if the size of the min heap is greater than the size of the max heap by 1
            maxHeap.add(minHeap.poll());  // add the top of the min heap to the max heap
        }
    }
    
    public double findMedian() {
        if(maxHeap.size() == minHeap.size()){  // if the size of the max heap is equal to the size of the min heap
            return (maxHeap.peek() + minHeap.peek()) / 2.0;  // return the average of the top of the max heap and the top of the min heap
        } else if(maxHeap.size() > minHeap.size()){  // else if the size of the max heap is greater than the size of the min heap
            return maxHeap.peek();  // return the top of the max heap
        } else {  // else
            return minHeap.peek();  // return the top of the min heap
        }
    }
}

151. Reverse Words in a String in c++


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
public:
    string reverseWords(string s) {
        string result = "";  // variable to store the result
        int i = s.length() - 1;  // variable to store the index
        while(i >= 0){  // iterate until the index is greater than or equal to 0
            while(i >= 0 && s[i] == ' '){  // iterate until the index is greater than or equal to 0 and the character at the index is a space
                i--;  // decrement the index
            }
            if(i < 0){  // if the index is less than 0
                break;  // break
          }
            if(result.length() != 0){  // if the length of the result is not equal to 0
                result += " ";  // add a space to the result
            }
            string word = "";  // variable to store the word
            while(i >= 0 && s[i] != ' '){  // iterate until the index is greater than or equal to 0 and the character at the index is not a space
                word = s[i] + word;  // add the character at the index to the word
                i--;  // decrement the index
            }
            result += word;  // add the word to the result
        }
        return result;  // return the result
    }
};


151. Reverse Words in a String in swift


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
    func reverseWords(_ s: String) -> String {
        var result = ""  // variable to store the result
        var i = s.count - 1  // variable to store the index
        while(i >= 0){  // iterate until the index is greater than or equal to 0
            while(i >= 0 && s[s.index(s.startIndex, offsetBy: i)] == " "){  // iterate until the index is greater than or equal to 0 and the character at the index is a space
                i -= 1  // decrement the index
            }
            if(i < 0){  // if the index is less than 0
                break  // break
            }
            if(result.count != 0){  // if the length of the result is not equal to 0
                result += " "  // add a space to the result
            }
            var word = ""  // variable to store the word
            while(i >= 0 && s[s.index(s.startIndex, offsetBy: i)] != " "){  // iterate until the index is greater than or equal to 0 and the character at the index is not a space
                word = String(s[s.index(s.startIndex, offsetBy: i)]) + word  // add the character at the index to the word
                i -= 1  // decrement the index
            }
            result += word  // add the word to the result
        }
        return result  // return the result
    }
}



151. Reverse Words in a String in java


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
    public String reverseWords(String s) {
        String result = "";  // variable to store the result
        int i = s.length() - 1;  // variable to store the index
        while(i >= 0){  // iterate until the index is greater than or equal to 0
            while(i >= 0 && s.charAt(i) == ' '){  // iterate until the index is greater than or equal to 0 and the character at the index is a space
                i--;  // decrement the index
            }
            if(i < 0){  // if the index is less than 0
                break;  // break
            }
            if(result.length() != 0){  // if the length of the result is not equal to 0
                result += " ";  // add a space to the result
            }
            String word = "";  // variable to store the word
            while(i >= 0 && s.charAt(i) != ' '){  // iterate until the index is greater than or equal to 0 and the character at the index is not a space
                word = s.charAt(i) + word;  // add the character at the index to the word
                i--;  // decrement the index
            }
            result += word;  // add the word to the result
        }
        return result;  // return the result
    }
}


2nd Method:


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)


class Solution {
    public String reverseWords(String s) {
        String result = "";  // variable to store the result
        String[] words = s.split(" ");  // split the string by spaces
        for(int i = words.length - 1; i >= 0; i--){  // iterate from the last index to the first index
            if(words[i].length() != 0){  // if the length of the word at the index is not equal to 0
                if(result.length() != 0){  // if the length of the result is not equal to 0
                    result += " ";  // add a space to the result
                }
                result += words[i];  // add the word at the index to the result
            }
        }
        return result;  // return the result
    }
}


3rd Method:


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)



class Solution {
    public String reverseWords(String s) {
        String str[]=s.split("\\s+");
        String res="";
        for(int i=str.length-1;i>=0;i--){
            res+= str[i]+" ";
        }
        return res.substring(0,res.length()-1).trim();

    }
}




222. Count Complete Tree Nodes in c++

// Time Complexity : O(logn * logn) where n is the number of nodes in the tree and space complexity is O(1)


class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == NULL){  // if the root is null
            return 0;  // return 0
        }
        int leftHeight = 0;  // variable to store the height of the left subtree
        int rightHeight = 0;  // variable to store the height of the right subtree
        TreeNode* left = root;  // variable to store the left subtree
        TreeNode* right = root;  // variable to store the right subtree
        while(left != NULL){  // iterate until the left subtree is null
            leftHeight++;  // increment the height of the left subtree
            left = left->left;  // move to the left subtree
        }
        while(right != NULL){  // iterate until the right subtree is null
            rightHeight++;  // increment the height of the right subtree
            right = right->right;  // move to the right subtree
        }
        if(leftHeight == rightHeight){  // if the height of the left subtree is equal to the height of the right subtree
            return pow(2, leftHeight) - 1;  // return 2 to the power of the height of the left subtree minus 1
        }
        return 1 + countNodes(root->left) + countNodes(root->right);  // return 1 plus the number of nodes in the left subtree plus the number of nodes in the right subtree
    }
};





222. Count Complete Tree Nodes in java


// Time Complexity : O(logn * logn) where n is the number of nodes in the tree and space complexity is O(1)


class Solution {
    public int countNodes(TreeNode root) {
        if(root == null){  // if the root is null
            return 0;  // return 0
        }
        int leftHeight = 0;  // variable to store the height of the left subtree
        int rightHeight = 0;  // variable to store the height of the right subtree
        TreeNode left = root;  // variable to store the left subtree
        TreeNode right = root;  // variable to store the right subtree
        while(left != null){  // iterate until the left subtree is null
            leftHeight++;  // increment the height of the left subtree
            left = left.left;  // move to the left subtree
        }
        while(right != null){  // iterate until the right subtree is null
            rightHeight++;  // increment the height of the right subtree
            right = right.right;  // move to the right subtree
        }
        if(leftHeight == rightHeight){  // if the height of the left subtree is equal to the height of the right subtree
            return (int)Math.pow(2, leftHeight) - 1;  // return 2 to the power of the height of the left subtree minus 1
        }
        return 1 + countNodes(root.left) + countNodes(root.right);  // return 1 plus the number of nodes in the left subtree plus the number of nodes in the right subtree
    }
}



374. Guess Number Higher or Lower  in c++

// Time Complexity : O(logn) where n is the number of guesses and space complexity is O(1)


class Solution {
public:
    int guessNumber(int n) {
        int low = 1;  // variable to store the low
        int high = n;  // variable to store the high
        while(low <= high){  // iterate until the low is less than or equal to the high
            int mid = low + (high - low) / 2;  // variable to store the mid
            int res = guess(mid);  // variable to store the guess
            if(res == 0){  // if the guess is 0
                return mid;  // return the mid
            }
            else if(res == -1){  // if the guess is -1
                high = mid - 1;  // set the high to the mid minus 1
            }
            else{  // if the guess is 1
                low = mid + 1;  // set the low to the mid plus 1
            }
        }
        return -1;  // return -1
    }
};




374. Guess Number Higher or Lower in java


// Time Complexity : O(logn) where n is the number of guesses and space complexity is O(1)


class Solution extends GuessGame {
    public int guessNumber(int n) {
        int low = 1;  // variable to store the low
        int high = n;  // variable to store the high
        while(low <= high){  // iterate until the low is less than or equal to the high
            int mid = low + (high - low) / 2;  // variable to store the mid
            int res = guess(mid);  // variable to store the guess
            if(res == 0){  // if the guess is 0
                return mid;  // return the mid
            }
            else if(res == -1){  // if the guess is -1
                high = mid - 1;  // set the high to the mid minus 1
            }
            else{  // if the guess is 1
                low = mid + 1;  // set the low to the mid plus 1
            }
        }
        return -1;  // return -1
    }
}



263. Ugly Number in c++

// Time Complexity : O(logn) where n is the number and space complexity is O(1)


class Solution {
public:
    bool isUgly(int n){
        if(n == 0){  // if the number is 0
            return false;  // return false
        }
        while(n % 2 == 0){  // iterate until the number is not divisible by 2
            n = n / 2;  // divide the number by 2
        }
        while(n % 3 == 0){  // iterate until the number is not divisible by 3
            n = n / 3;  // divide the number by 3
        }
        while(n % 5 == 0){  // iterate until the number is not divisible by 5
            n = n / 5;  // divide the number by 5
        }
        return n == 1;  // return true if the number is 1 else return false
    }
};



263. Ugly Number in java


// Time Complexity : O(logn) where n is the number and space complexity is O(1)


class Solution {
    public boolean isUgly(int n) {
        if(n == 0){  // if the number is 0
            return false;  // return false
        }
        while(n % 2 == 0){  // iterate until the number is not divisible by 2
            n = n / 2;  // divide the number by 2
        }
        while(n % 3 == 0){  // iterate until the number is not divisible by 3
            n = n / 3;  // divide the number by 3
        }
        while(n % 5 == 0){  // iterate until the number is not divisible by 5
            n = n / 5;  // divide the number by 5
        }
        return n == 1;  // return true if the number is 1 else return false
    }
}




1675. Minimize Deviation in Array in c++


// Time Complexity : O(nlogn) where n is the number of elements in the array and space complexity is O(n)


class Solution {
public:
    int minimumDeviation(vector<int>& nums) {
        int n = nums.size();  // variable to store the size of the array
        set<int> s;  // set to store the elements in the array
        for(int i = 0; i < n; i++){  // iterate through the array
            if(nums[i] % 2 == 1){  // if the element is odd
                nums[i] *= 2;  // multiply the element by 2
            }
            s.insert(nums[i]);  // insert the element into the set
        }
        int res = *s.rbegin() - *s.begin();  // variable to store the result
        while(*s.rbegin() % 2 == 0){  // iterate until the last element in the set is even
            int temp = *s.rbegin();  // variable to store the last element in the set
            s.erase(temp);  // erase the last element in the set
            s.insert(temp / 2);  // insert the last element in the set divided by 2
            res = min(res, *s.rbegin() - *s.begin());  // update the result
        }
        return res;  // return the result
    }
};



1675. Minimize Deviation in Array in java


// Time Complexity : O(nlogn) where n is the number of elements in the array and space complexity is O(n)


class Solution {
    public int minimumDeviation(int[] nums) {
        int n = nums.length;  // variable to store the size of the array
        TreeSet<Integer> s = new TreeSet<>();  // set to store the elements in the array
        for(int i = 0; i < n; i++){  // iterate through the array
            if(nums[i] % 2 == 1){  // if the element is odd
                nums[i] *= 2;  // multiply the element by 2
            }
            s.add(nums[i]);  // insert the element into the set
        }
        int res = s.last() - s.first();  // variable to store the result
        while(s.last() % 2 == 0){  // iterate until the last element in the set is even
            int temp = s.last();  // variable to store the last element in the set
            s.remove(temp);  // erase the last element in the set
            s.add(temp / 2);  // insert the last element in the set divided by 2
            res = Math.min(res, s.last() - s.first());  // update the result
        }
        return res;  // return the result
    }
};





587. Erect the Fence in c++

// Time Complexity : O(nlogn) where n is the number of points and space complexity is O(n)


class Solution {
public:
    
    int findEquationValue(pair<int, int>& P1, pair<int, int>& P2, pair<int, int> P3) {
        
        int x1 = P1.first;
        int x2 = P2.first;
        int x3 = P3.first;
        
        int y1 = P1.second;
        int y2 = P2.second;
        int y3 = P3.second;
        
        return (y3-y2)*(x2-x1)-(y2-y1)*(x3-x2);
        
    }
    
    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {
        sort(begin(trees), end(trees));
        
        vector<vector<int>> result;
        
        deque<pair<int, int>> upper, lower;
        
        
        for(auto &point : trees) {
            
            int l = lower.size();
            int u = upper.size();
            
            //sabse pehle lower ka dekhte hain
            while(l >= 2 && findEquationValue(lower[l-2], lower[l-1], {point[0], point[1]}) < 0) {
                l--;
                lower.pop_back();
            }
            
            while(u >= 2 && findEquationValue(upper[u-2],upper[u-1],{point[0],point[1]}) > 0) {
                u--;
                upper.pop_back();
            }
            
            upper.push_back({point[0], point[1]});
            lower.push_back({point[0], point[1]}); 
        }
        
        set<pair<int, int>> st;
        
        for(auto &point : upper) {
            st.insert(point);
        }
        
        for(auto &point : lower) {
            st.insert(point);
        }
        
        for(auto &point : st) {
            result.push_back({point.first, point.second});
        }
        
        return result;
        
    }
};

2nd Method 


class Solution {
public:
    vector<vector<int>> outerTrees(vector<vector<int>>& points) {
        int n = points.size();  // variable to store the size of the array
        if(n <= 3){  // if the size is less than or equal to 3
            return points;  // return the points
        }
         bool aligned = true;
        for (int i = 1; i < n; i++) {
            if (points[i][1] != points[0][1]) {
                aligned = false;
                break;
            }
        }
        if (aligned) {
            return points;
        }
        sort(points.begin(), points.end(), [](vector<int> a, vector<int> b){  // sort the points based on the x coordinate
            return a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]);
        });
        vector<vector<int>> hull;  // vector to store the hull
        for(int i = 0; i < n; i++){  // iterate through the points
            while(hull.size() >= 2 && orientation(hull[hull.size() - 2], hull[hull.size() - 1], points[i]) > 0){  // iterate until the orientation is greater than 0
                hull.pop_back();  // pop the last element in the hull
            }
            hull.push_back(points[i]);  // push the point into the hull
        }
        for(int i = n - 2; i >= 0; i--){  // iterate through the points
            while(hull.size() >= 2 && orientation(hull[hull.size() - 2], hull[hull.size() - 1], points[i]) > 0){  // iterate until the orientation is greater than 0
                hull.pop_back();  // pop the last element in the hull
            }
            hull.push_back(points[i]);  // push the point into the hull
        }
        hull.pop_back();  // pop the last element in the hull
        return hull;  // return the hull
    }
    int orientation(vector<int> a, vector<int> b, vector<int> c){  // function to calculate the orientation
        return (b[1] - a[1]) * (c[0] - b[0]) - (b[0] - a[0]) * (c[1] - b[1]);
    }
};




587. Erect the Fence in java


// Time Complexity : O(nlogn) where n is the number of points and space complexity is O(n)

class Solution {
    public int[][] outerTrees(int[][] trees) {
        if(trees.length <= 3) return trees;
        
        Arrays.sort(trees, (a, b) -> {
            if(a[0] == b[0]) {
                return a[1] - b[1];
            } else {
                return a[0] - b[0];
            }
        });
        
        List<int[]> lower = new ArrayList<>();
        List<int[]> upper = new ArrayList<>();
        
        for(int[] tree: trees) {
            while(lower.size() >= 2 && compare(lower.get(lower.size() - 2), lower.get(lower.size() - 1), tree) > 0) {
                lower.remove(lower.size() - 1);
            }
            
            while(upper.size() >= 2 && compare(upper.get(upper.size() - 2), upper.get(upper.size() - 1), tree) < 0) {
                upper.remove(upper.size() - 1);
            }
            
            lower.add(tree);
            upper.add(tree);
        }
        
        Set<int[]> set = new HashSet<>();
        for(int[] l : lower) {
            set.add(l);
        }
        
        for(int[] u : upper) {
            set.add(u);
        }
        
        int[][] result = new int[set.size()][2];
        
        int index = 0;
        for(int[] s: set) {
            result[index++] = s;
        }
        
        return result;
    }
    
    // < 0: clockwise
    // > 0: counterclockwise
    // == 0 : collinear
    private int compare(int[] p1, int[] p2, int[] p3) {
        int x1 = p1[0];
        int y1 = p1[1];
        int x2 = p2[0];
        int y2 = p2[1];
        int x3 = p3[0];
        int y3 = p3[1];
        
        return (y3 - y2) * (x2 - x1) - (y2 - y1) * (x3 - x2);
    }
}




121. Best Time to Buy and Sell Stock in c++


// Time Complexity : O(n) where n is the number of elements in the array and space complexity is O(1)


class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();  // variable to store the size of the array
        int minPrice = INT_MAX;  // variable to store the minimum price
        int maxProfit = 0;  // variable to store the maximum profit
        for(int i = 0; i < n; i++){  // iterate through the array
            if(prices[i] < minPrice){  // if the current price is less than the minimum price
                minPrice = prices[i];  // update the minimum price
            }
            else if(prices[i] - minPrice > maxProfit){  // if the current price minus the minimum price is greater than the maximum profit
                maxProfit = prices[i] - minPrice;  // update the maximum profit
            }
        }
        return maxProfit;  // return the maximum profit
    }
};



121. Best Time to Buy and Sell Stock in java


// Time Complexity : O(n) where n is the number of elements in the array and space complexity is O(1)


class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;  // variable to store the size of the array
        int minPrice = Integer.MAX_VALUE;  // variable to store the minimum price
        int maxProfit = 0;  // variable to store the maximum profit
        for(int i = 0; i < n; i++){  // iterate through the array
            if(prices[i] < minPrice){  // if the current price is less than the minimum price
                minPrice = prices[i];  // update the minimum price
            }
            else if(prices[i] - minPrice > maxProfit){  // if the current price minus the minimum price is greater than the maximum profit
                maxProfit = prices[i] - minPrice;  // update the maximum profit
            }
        }
        return maxProfit;  // return the maximum profit
    }
};


72. Edit Distance in c++


// Time Complexity : O(mn) where m is the length of the first string and n is the length of the second string and space complexity is O(mn)



class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.length();  // variable to store the length of the first string
        int n = word2.length();  // variable to store the length of the second string
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));  // vector to store the dp values
        for(int i = 0; i <= m; i++){  // iterate through the first string
            for(int j = 0; j <= n; j++){  // iterate through the second string
                if(i == 0){  // if the first string is empty
                    dp[i][j] = j;  // the number of operations is equal to the length of the second string
                }
                else if(j == 0){  // if the second string is empty
                    dp[i][j] = i;  // the number of operations is equal to the length of the first string
                }
                else if(word1[i - 1] == word2[j - 1]){  // if the characters are equal
                    dp[i][j] = dp[i - 1][j - 1];  // the number of operations is equal to the number of operations for the previous characters
                }
                else{  // if the characters are not equal
                    dp[i][j] = 1 + min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]));  // the number of operations is equal to the minimum of the number of operations for the previous characters, the number of operations for the previous character in the first string and the number of operations for the previous character in the second string
                }
            }
        }
        return dp[m][n];  // return the number of operations
    }
};



72. Edit Distance in java


// Time Complexity : O(mn) where m is the length of the first string and n is the length of the second string and space complexity is O(mn)



class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();  // variable to store the length of the first string
        int n = word2.length();  // variable to store the length of the second string
        int[][] dp = new int[m + 1][n + 1];  // array to store the dp values
        for(int i = 0; i <= m; i++){  // iterate through the first string
            for(int j = 0; j <= n; j++){  // iterate through the second string
                if(i == 0){  // if the first string is empty
                    dp[i][j] = j;  // the number of operations is equal to the length of the second string
                }
                else if(j == 0){  // if the second string is empty
                    dp[i][j] = i;  // the number of operations is equal to the length of the first string
                }
                else if(word1.charAt(i - 1) == word2.charAt(j - 1)){  // if the characters are equal
                    dp[i][j] = dp[i - 1][j - 1];  // the number of operations is equal to the number of operations for the previous characters
                }
                else{  // if the characters are not equal
                    dp[i][j] = 1 + Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1]));  // the number of operations is equal to the minimum of the number of operations for the previous characters, the number of operations for the previous character in the first string and the number of operations for the previous character in the second string
                }
            }
        }
        return dp[m][n];  // return the number of operations
    }
}

224. Basic Calculator in c++


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)



class Solution {

public:
    int calculate(string s) {
        stack<int> st;  // stack to store the numbers
        int result = 0;  // variable to store the result
        int sign = 1;  // variable to store the sign
        int n = s.length();  // variable to store the length of the string
        for(int i = 0; i < n; i++){  // iterate through the string
            if(s[i] >= '0' && s[i] <= '9'){  // if the current character is a digit
                int num = 0;  // variable to store the number
                while(i < n && s[i] >= '0' && s[i] <= '9'){  // iterate through the string until the current character is not a digit
                    num = num * 10 + (s[i] - '0');  // update the number
                    i++;  // increment the index
                }
                result += sign * num;  // update the result
                i--;  // decrement the index
            }
            else if(s[i] == '+'){  // if the current character is a plus sign
                sign = 1;  // update the sign
            }
            else if(s[i] == '-'){  // if the current character is a minus sign
                sign = -1;  // update the sign
            }
            else if(s[i] == '('){  // if the current character is an opening bracket
                st.push(result);  // push the result into the stack
                st.push(sign);  // push the sign into the stack
                result = 0;  // update the result
                sign = 1;  // update the sign
            }
            else if(s[i] == ')'){  // if the current character is a closing bracket
                result = result * st.top();  // update the result
                st.pop();  // pop the sign from the stack
                result += st.top();  // update the result
                st.pop();  // pop the result from the stack
            }
        }
        return result;  // return the result
    }
};



224. Basic Calculator in java


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)



class Solution {
    public int calculate(String s) {
        Stack<Integer> st = new Stack<>();  // stack to store the numbers
        int result = 0;  // variable to store the result
        int sign = 1;  // variable to store the sign
        int n = s.length();  // variable to store the length of the string
        for(int i = 0; i < n; i++){  // iterate through the string
            if(s.charAt(i) >= '0' && s.charAt(i) <= '9'){  // if the current character is a digit
                int num = 0;  // variable to store the number
                while(i < n && s.charAt(i) >= '0' && s.charAt(i) <= '9'){  // iterate through the string until the current character is not a digit
                    num = num * 10 + (s.charAt(i) - '0');  // update the number
                    i++;  // increment the index
                }
                result += sign * num;  // update the result
                i--;  // decrement the index
            }
            else if(s.charAt(i) == '+'){  // if the current character is a plus sign
                sign = 1;  // update the sign
            }
            else if(s.charAt(i) == '-'){  // if the current character is a minus sign
                sign = -1;  // update the sign
            }
            else if(s.charAt(i) == '('){  // if the current character is an opening bracket
                st.push(result);  // push the result into the stack
                st.push(sign);  // push the sign into the stack
                result = 0;  // update the result
                sign = 1;  // update the sign
            }
            else if(s.charAt(i) == ')'){  // if the current character is a closing bracket
                result = result * st.pop();  // update the result
                result += st.pop();  // update the result
            }
        }
        return result;  // return the result
    }
}



841. Keys and Rooms in c++


// Time Complexity : O(n) where n is the number of rooms and space complexity is O(n)



class Solution {
public:
    bool canVisitAllRooms(vector<vector<int>>& rooms) {
        int n = rooms.size();  // variable to store the number of rooms
        vector<bool> visited(n, false);  // vector to store the visited rooms
        queue<int> q;  // queue to store the rooms
        q.push(0);  // push the first room into the queue
        visited[0] = true;  // mark the first room as visited
        while(!q.empty()){  // iterate through the queue
            int room = q.front();  // variable to store the current room
            q.pop();  // pop the current room from the queue
            for(int i = 0; i < rooms[room].size(); i++){  // iterate through the keys of the current room
                if(!visited[rooms[room][i]]){  // if the room is not visited
                    q.push(rooms[room][i]);  // push the room into the queue
                    visited[rooms[room][i]] = true;  // mark the room as visited
                }
            }
        }
        for(int i = 0; i < n; i++){  // iterate through the rooms
            if(!visited[i]){  // if the room is not visited
                return false;  // return false
            }
        }
        return true;  // return true
    }
};

2nd Method using dfs 

class Solution {
public:
    bool canVisitAllRooms(vector<vector<int>>& rooms) {
        int n = rooms.size();  // variable to store the number of rooms
        vector<bool> visited(n, false);  // vector to store the visited rooms
        dfs(rooms, visited, 0);  // call the dfs function
        for(int i = 0; i < n; i++){  // iterate through the rooms
            if(!visited[i]){  // if the room is not visited
                return false;  // return false
            }
        }
        return true;  // return true
    }
    
    void dfs(vector<vector<int>>& rooms, vector<bool>& visited, int room){  // function to perform dfs
        visited[room] = true;  // mark the current room as visited
        for(int i = 0; i < rooms[room].size(); i++){  // iterate through the keys of the current room
            if(!visited[rooms[room][i]]){  // if the room is not visited
                dfs(rooms, visited, rooms[room][i]);  // call the dfs function
            }
        }
    }
};






841. Keys and Rooms in java




// Time Complexity : O(n) where n is the number of rooms and space complexity is O(n)



class Solution {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        int n = rooms.size();  // variable to store the number of rooms
        boolean[] visited = new boolean[n];  // array to store the visited rooms
        Queue<Integer> q = new LinkedList<>();  // queue to store the rooms
        q.add(0);  // push the first room into the queue
        visited[0] = true;  // mark the first room as visited
        while(!q.isEmpty()){  // iterate through the queue
            int room = q.poll();  // variable to store the current room
            for(int i = 0; i < rooms.get(room).size(); i++){  // iterate through the keys of the current room
                if(!visited[rooms.get(room).get(i)]){  // if the room is not visited
                    q.add(rooms.get(room).get(i));  // push the room into the queue
                    visited[rooms.get(room).get(i)] = true;  // mark the room as visited
                }
            }
        }
        for(int i = 0; i < n; i++){  // iterate through the rooms
            if(!visited[i]){  // if the room is not visited
                return false;  // return false
            }
        }
        return true;  // return true
    }
};



2nd Method using dfs



class Solution {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        int n = rooms.size();  // variable to store the number of rooms
        boolean[] visited = new boolean[n];  // array to store the visited rooms
        dfs(rooms, visited, 0);  // call the dfs function
        for(int i = 0; i < n; i++){  // iterate through the rooms
            if(!visited[i]){  // if the room is not visited
                return false;  // return false
            }
        }
        return true;  // return true
    }
    
    public void dfs(List<List<Integer>> rooms, boolean[] visited, int room){  // function to perform dfs
        visited[room] = true;  // mark the current room as visited
        for(int i = 0; i < rooms.get(room).size(); i++){  // iterate through the keys of the current room
            if(!visited[rooms.get(room).get(i)]){  // if the room is not visited
                dfs(rooms, visited, rooms.get(room).get(i));  // call the dfs function
            }
        }
    }
}



427. Construct Quad Tree in c++



// Time Complexity : O(n^2) where n is the length of the grid and space complexity is O(n^2)



class Solution {
public:
    Node* construct(vector<vector<int>>& grid) {
        int n = grid.size();  // variable to store the length of the grid
        return construct(grid, 0, 0, n);  // call the construct function
    }
    
    Node* construct(vector<vector<int>>& grid, int x, int y, int n){  // function to construct the quad tree
        if(n == 0){  // if the length of the grid is 0
            return NULL;  // return NULL
        }
        bool isLeaf = true;  // variable to store if the current node is a leaf node
        int val = grid[x][y];  // variable to store the value of the current node
        for(int i = x; i < x + n; i++){  // iterate through the grid
            for(int j = y; j < y + n; j++){  // iterate through the grid
                if(grid[i][j] != val){  // if the value of the current node is not equal to the value of the first node
                    isLeaf = false;  // update the isLeaf variable
                    break;  // break the loop
                }
            }
        }
        if(isLeaf){  // if the current node is a leaf node
            return new Node(val == 1, true, NULL, NULL, NULL, NULL);  // return the node
        }
        int m = n / 2;  // variable to store the length of the grid
        return new Node(false, false, construct(grid, x, y, m), construct(grid, x, y + m, m), construct(grid, x + m, y, m), construct(grid, x + m, y + m, m));  // return the node
    }
};





427. Construct Quad Tree in java



// Time Complexity : O(n^2) where n is the length of the grid and space complexity is O(n^2)



class Solution {
    public Node construct(int[][] grid) {
        int n = grid.length;  // variable to store the length of the grid
        return construct(grid, 0, 0, n);  // call the construct function
    }
    
    public Node construct(int[][] grid, int x, int y, int n){  // function to construct the quad tree
        if(n == 0){  // if the length of the grid is 0
            return null;  // return null
        }
        boolean isLeaf = true;  // variable to store if the current node is a leaf node
        int val = grid[x][y];  // variable to store the value of the current node
        for(int i = x; i < x + n; i++){  // iterate through the grid
            for(int j = y; j < y + n; j++){  // iterate through the grid
                if(grid[i][j] != val){  // if the value of the current node is not equal to the value of the first node
                    isLeaf = false;  // update the isLeaf variable
                    break;  // break the loop
                }
            }
        }
        if(isLeaf){  // if the current node is a leaf node
            return new Node(val == 1, true, null, null, null, null);  // return the node
        }
        int m = n / 2;  // variable to store the length of the grid
        return new Node(false, false, construct(grid, x, y, m), construct(grid, x, y + m, m), construct(grid, x + m, y, m), construct(grid, x + m, y + m, m));  // return the node
    }
}







652. Find Duplicate Subtrees in c++

// Time Complexity : O(n) where n is the number of nodes in the tree and space complexity is O(n)



class Solution {
public:
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        vector<TreeNode*> res;  // vector to store the duplicate subtrees
        unordered_map<string, int> m;  // map to store the subtrees and their count
        helper(root, m, res);  // call the helper function
        return res;  // return the duplicate subtrees
    }
    
    string helper(TreeNode* root, unordered_map<string, int>& m, vector<TreeNode*>& res){  // function to find the duplicate subtrees
        if(root == NULL){  // if the root is null
            return "";  // return empty string
        }
        string s = to_string(root->val) + "," + helper(root->left, m, res) + "," + helper(root->right, m, res);  // variable to store the subtree
        if(m[s] == 1){  // if the subtree is already present
            res.push_back(root);  // push the root into the result vector
        }.
        m[s]++;  // increment the count of the subtree
        return s;  // return the subtree
    }
};





652. Find Duplicate Subtrees in java



// Time Complexity : O(n) where n is the number of nodes in the tree and space complexity is O(n)



class Solution {
    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
        List<TreeNode> res = new ArrayList<>();  // list to store the duplicate subtrees
        Map<String, Integer> m = new HashMap<>();  // map to store the subtrees and their count
        helper(root, m, res);  // call the helper function
        return res;  // return the duplicate subtrees
    }
    
    public String helper(TreeNode root, Map<String, Integer> m, List<TreeNode> res){  // function to find the duplicate subtrees
        if(root == null){  // if the root is null
            return "";  // return empty string
        }
        String s = root.val + "," + helper(root.left, m, res) + "," + helper(root.right, m, res);  // variable to store the subtree
        if(m.getOrDefault(s, 0) == 1){  // if the subtree is already present
            res.add(root);  // add the root to the result list
        }
        m.put(s, m.getOrDefault(s, 0) + 1);  // increment the count of the subtree
        return s;  // return the subtree
    }
}


912. Sort an Array in c++



// Time Complexity : O(nlogn) where n is the length of the array and space complexity is O(n)



class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        sort(nums.begin(), nums.end());  // sort the array
        return nums;  // return the sorted array
    }
};



912. Sort an Array in java



// Time Complexity : O(nlogn) where n is the length of the array and space complexity is O(n)



class Solution {
    public int[] sortArray(int[] nums) {
        Arrays.sort(nums);  // sort the array
        return nums;  // return the sorted array
    }
}


834. Sum of Distances in Tree in c++



// Time Complexity : O(n) where n is the number of nodes in the tree and space complexity is O(n)





class Solution {
public:
    vector<int> sumOfDistancesInTree(int N, vector<vector<int>>& edges) {
        vector<vector<int>> graph(N);  // graph to store the tree
        for(auto edge: edges){  // iterate through the edges
            graph[edge[0]].push_back(edge[1]);  // add the edge to the graph
            graph[edge[1]].push_back(edge[0]);  // add the edge to the graph
        }
        vector<int> count(N, 1);  // vector to store the count of the nodes
        vector<int> res(N, 0);  // vector to store the sum of distances
        dfs(graph, 0, -1, count, res);  // call the dfs function
        dfs2(graph, 0, -1, count, res);  // call the dfs2 function
        return res;  // return the sum of distances
    }
    
    void dfs(vector<vector<int>>& graph, int root, int parent, vector<int>& count, vector<int>& res){  // function to calculate the sum of distances
        for(auto child: graph[root]){  // iterate through the children of the root
            if(child != parent){  // if the child is not the parent
                dfs(graph, child, root, count, res);  // call the dfs function
                count[root] += count[child];  // update the count of the root
                res[root] += res[child] + count[child];  // update the sum of distances of the root
            }
        }
    }
    
    void dfs2(vector<vector<int>>& graph, int root, int parent, vector<int>& count, vector<int>& res){  // function to calculate the sum of distances
        for(auto child: graph[root]){  // iterate through the children of the root
            if(child != parent){  // if the child is not the parent
                res[child] = res[root] - count[child] + count.size() - count[child];  // update the sum of distances of the child
                dfs2(graph, child, root, count, res);  // call the dfs2 function
            }
        }
    }
};



834. Sum of Distances in Tree in java



// Time Complexity : O(n) where n is the number of nodes in the tree and space complexity is O(n)





class Solution {
    public int[] sumOfDistancesInTree(int N, int[][] edges) {
        List<List<Integer>> graph = new ArrayList<>();  // graph to store the tree
        for(int i = 0; i < N; i++){  // iterate through the nodes
            graph.add(new ArrayList<>());  // add the node to the graph
        }
        for(int[] edge: edges){  // iterate through the edges
            graph.get(edge[0]).add(edge[1]);  // add the edge to the graph
            graph.get(edge[1]).add(edge[0]);  // add the edge to the graph
        }
        int[] count = new int[N];  // array to store the count of the nodes
        int[] res = new int[N];  // array to store the sum of distances
        Arrays.fill(count, 1);  // fill the count array with 1
        dfs(graph, 0, -1, count, res);  // call the dfs function
        dfs2(graph, 0, -1, count, res);  // call the dfs2 function
        return res;  // return the sum of distances
    }
    
    public void dfs(List<List<Integer>> graph, int root, int parent, int[] count, int[] res){  // function to calculate the sum of distances
        for(int child: graph.get(root)){  // iterate through the children of the root
            if(child != parent){  // if the child is not the parent
                dfs(graph, child, root, count, res);  // call the dfs function
                count[root] += count[child];  // update the count of the root
                res[root] += res[child] + count[child];  // update the sum of distances of the root
            }
        }
    }
    
    public void dfs2(List<List<Integer>> graph, int root, int parent, int[] count, int[] res){  // function to calculate the sum of distances
        for(int child: graph.get(root)){  // iterate through the children of the root
            if(child != parent){  // if the child is not the parent
                res[child] = res[root] - count[child] + count.length - count[child];  // update the sum of distances of the child
                dfs2(graph, child, root, count, res);  // call the dfs2 function
            }
        }
    }
}




309. Best Time to Buy and Sell Stock with Cooldown in c++



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)


class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int buy = INT_MIN, sell = 0, prev_sell = 0, prev_buy;  // variables to store the buy, sell, previous sell and previous buy
        for(int price: prices){  // iterate through the prices
            prev_buy = buy;  // update the previous buy
            buy = max(prev_sell - price, buy);  // update the buy
            prev_sell = sell;  // update the previous sell
            sell = max(prev_buy + price, sell);  // update the sell
        }
        return sell;  // return the sell
    }
};

309. Best Time to Buy and Sell Stock with Cooldown in java



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)


class Solution {
    public int maxProfit(int[] prices) {
        int buy = Integer.MIN_VALUE, sell = 0, prev_sell = 0, prev_buy;  // variables to store the buy, sell, previous sell and previous buy
        for(int price: prices){  // iterate through the prices
            prev_buy = buy;  // update the previous buy
            buy = Math.max(prev_sell - price, buy);  // update the buy
            prev_sell = sell;  // update the previous sell
            sell = Math.max(prev_buy + price, sell);  // update the sell
        }
        return sell;  // return the sell
    }
}


443. String Compression in c++



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)


class Solution {
public:
    int compress(vector<char>& chars) {
        int i = 0, j = 0;  // variables to store the index
        while(i < chars.size()){  // iterate through the array
            int count = 0;  // variable to store the count
            char c = chars[i];  // variable to store the character
            while(i < chars.size() && chars[i] == c){  // iterate through the array
                i++;  // increment the index
                count++;  // increment the count
            }f
            chars[j++] = c;  // update the character
            if(count > 1){  // if the count is greater than 1
                string s = to_string(count);  // convert the count to string
                for(char ch: s){  // iterate through the string
                    chars[j++] = ch;  // update the character
                }
            }
        }
        return j;  // return the index
    }
};



443. String Compression in java



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)



class Solution {
    public int compress(char[] chars) {
        int i = 0, j = 0;  // variables to store the index
        while(i < chars.length){  // iterate through the array
            int count = 0;  // variable to store the count
            char c = chars[i];  // variable to store the character
            while(i < chars.length && chars[i] == c){  // iterate through the array
                i++;  // increment the index
                count++;  // increment the count
            }
            chars[j++] = c;  // update the character
            if(count > 1){  // if the count is greater than 1
                String s = Integer.toString(count);  // convert the count to string
                for(char ch: s.toCharArray()){  // iterate through the string
                    chars[j++] = ch;  // update the character
                }
            }
        }
        return j;  // return the index
    }
};






2389. Longest Subsequence With Limited Sum in c++
 



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)


class Solution {
public:
    vector<int> answerQueries(vector<int>& nums, vector<int>& queries) {
      sort(nums.begin(), nums.end()); 
        vector<int> res;
        for(int i = 0; i < queries.size(); i++){
            int sum = 0;
            int count = 0;
            for(int j = 0; j < nums.size(); j++){
                if(sum + nums[j] <= queries[i]){
                    sum += nums[j];
                    count++;
                }
            }
            res.push_back(count);
        }

        return res;
    }
};


2nd Method 

class Solution {
public:
    vector<int> answerQueries(vector<int>& nums, vector<int>& queries) {
        // Sort 'nums'
        sort(nums.begin(), nums.end());
        
        // For each query, collect numbers from lowest to highest.
        // If their sum exceeds the limit 'query', move on to the next query.
        vector<int> ans;
        for (auto query : queries) {
            int count = 0;
            for (auto num : nums) {
                if (query >= num) {
                    query -= num;
                    count++;
                }
                else {
                    break;
                }
            }
            ans.push_back(count);
        }
        
        return ans;
    }
};


2389. Longest Subsequence With Limited Sum in java



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)



class Solution {
    public int[] answerQueries(int[] nums, int[] queries) {
        // Sort 'nums'
        Arrays.sort(nums);
        int n = nums.length, m = queries.length;
        int answer[] = new int[m];
        
        // For each query, collect numbers from lowest to highest.
        // If their sum exceeds the limit 'query', move on to the next query.
        for (int i = 0; i < m; ++i) {
            int count = 0;
            int query = queries[i];
            for (int num : nums) {
                if (query >= num) {
                    count++;
                    query -= num;
                }
                else
                    break;
            }
            answer[i] = count;
        }
        return answer;
    }
}


28. Find the Index of the First Occurrence in a String in c++



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)


class Solution {
public:
    int strStr(string haystack, string needle) {
        if(needle == "") return 0;  // if the needle is empty return 0
        int n = haystack.size(), m = needle.size();  // variables to store the size of the haystack and needle
        for(int i = 0; i <= n - m; i++){  // iterate through the haystack
            int j = 0;  // variable to store the index
            while(j < m && haystack[i + j] == needle[j]){  // iterate through the haystack and needle
                j++;  // increment the index
            }
            if(j == m) return i;  // if the index is equal to the size of the needle return the index
        }
        return -1;  // return -1
        
    }
};



28. Find the Index of the First Occurrence in a String in java



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)


class Solution {
    public int strStr(String haystack, String needle) {
        if(needle.equals("")) return 0;  // if the needle is empty return 0
        int n = haystack.length(), m = needle.length();  // variables to store the size of the haystack and needle
        for(int i = 0; i <= n - m; i++){  // iterate through the haystack
            int j = 0;  // variable to store the index
            while(j < m && haystack.charAt(i + j) == needle.charAt(j)){  // iterate through the haystack and needle
                j++;  // increment the index
            }
            if(j == m) return i;  // if the index is equal to the size of the needle return the index
        }
        return -1;  // return -1
        
    }
};



2562. Find the Array Concatenation Value in c++



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)

class Solution {
public:
    long long findTheArrayConcVal(vector<int>& nums) {
    long long res = 0, sz = nums.size();
    for (int i = 0, j = sz - 1; i <= j; ++i, --j)
        if (i < j)
            res += nums[i] * pow(10, (int)log10(nums[j]) + 1) + nums[j];
        else
            res += nums[i];
    return res;
}
};




2562. Find the Array Concatenation Value in java



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)



class Solution {
    public long findTheArrayConcVal(int[] nums) {
        long res = 0;
        int sz = nums.length;
        for (int i = 0, j = sz - 1; i <= j; ++i, --j)
            if (i < j)
                res += nums[i] * (long)Math.pow(10, (int)Math.log10(nums[j]) + 1) + nums[j];
            else
                res += nums[i];
        return res;
    }
}







2563. Count the Number of Fair Pairs in c++

// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)

class Solution {
public:
    long long countFairPairs(vector<int>& nums, int lower, int upper) {
        sort(nums.begin(), nums.end()); 
        long long ans = 0; 
        for (int i = 0, n = nums.size(), lo = n-1, hi = n-1; i < n; ++i) {
            while (0 <= hi && nums[i] + nums[hi] > upper) --hi; 
            while (0 <= lo && nums[i] + nums[lo] >= lower) --lo; 
            ans += hi - lo; 
            if (lo < i && i <= hi) --ans; 
        }
        return ans/2; 
    }
};

2nd Method 

class Solution {
public:
    long long countFairPairs(vector<int>& nums, int lower, int upper) {
        sort(nums.begin() , nums.end());
        long long res = 0;
        int n = nums.size();
        int low = n-1 , high = n-1;
        for(int i=0; i<n; i++){
            while(high>=0 && nums[i] + nums[high] > upper) high--;
            while(low>=0 && nums[i] + nums[low] >= lower) low--;
             res += high - low;
            if(low<i && i<=high){
                res--;
            }
            
        }
        return res/2;
    }
};


2563. Count the Number of Fair Pairs in java



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)



class Solution {
    public long countFairPairs(int[] nums, int lower, int upper) {
        Arrays.sort(nums); 
        long ans = 0; 
        for (int i = 0, n = nums.length, lo = n-1, hi = n-1; i < n; ++i) {
            while (0 <= hi && nums[i] + nums[hi] > upper) --hi; 
            while (0 <= lo && nums[i] + nums[lo] >= lower) --lo; 
            ans += hi - lo; 
            if (lo < i && i <= hi) --ans; 
        }
        return ans/2; 
    }
}


2nd Method 



class Solution {
    public long countFairPairs(int[] nums, int lower, int upper) {
        Arrays.sort(nums);
        long res = 0;
        int n = nums.length;
        int low = n-1 , high = n-1;
        for(int i=0; i<n; i++){
            while(high>=0 && nums[i] + nums[high] > upper) high--;
            while(low>=0 && nums[i] + nums[low] >= lower) low--;
             res += high - low;
            if(low<i && i<=high){
                res--;
            }
            
        }
        return res/2;
    }
}



2564. Substring XOR Queries in c++



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)


#define ll long long 
#define pii pair<int,int>
#define f first
#define s second

class Solution {
public:
    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& qu) 
    {
        int n=s.size(),q=qu.size();
        vector<vector<int>>ans;  
        unordered_map<ll,pii>map;
        for(int i=0;i<n;i++){
            if(s[i]=='0'){
                if(!map.count(0)) map[0]=make_pair(i,i);
                continue;
            }
            long long num=0;
            for(int j=i;j<=min(i+32,n-1);j++){
                num = (num << 1) + (s[j] - '0');
                if(!map.count(num)) map[num] = make_pair(i,j);                
            }
        }
        for(int i=0;i<q;i++){
            int num=qu[i][0] ^ qu[i][1];
            if(map.count(num)) ans.push_back({map[num].f,map[num].s});
            else   ans.push_back({-1,-1});
        }
        return ans;
    }
};

2nd Method 

class Solution {
public:
    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {
        int n = s.size() , m = queries.size();
        vector<vector<int>> ans;
        unordered_map<int , pair<int, int>> map;
        for(int i=0; i<n; i++){
            if(s[i] == '0'){
                if(!map.count(0)) map[0] = make_pair(i , i);
                continue;
            }
            long long num = 0;
            for(int j=i; j<n && j<i+32; j++){
                num = (num << 1) + (s[j] - '0');
                if(!map.count(num)) map[num] = make_pair(i , j);
                
            }
        }
        for(int i=0; i<m; i++){
            int num = queries[i][0] ^ queries[i][1];
            if(map.count(num)) ans.push_back({map[num].first , map[num].second});
            else ans.push_back({-1, - 1});
        }
        return ans;
    }
};

                                

                            


2564. Substring XOR Queries in java



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)



class Solution {
    public int[][] substringXorQueries(String s, int[][] qu) {
        int n=s.length(),q=qu.length;
        int[][]ans=new int[q][2];  
        HashMap<Integer,int[]>map=new HashMap<>();
        for(int i=0;i<n;i++){
            if(s.charAt(i)=='0'){
                if(!map.containsKey(0)) map.put(0,new int[]{i,i});
                continue;
            }
            int num=0;
            for(int j=i;j<n && j<i+32;j++){
                num = (num << 1) + (s.charAt(j) - '0');
                if(!map.containsKey(num)) map.put(num,new int[]{i,j});                
            }
        }
        for(int i=0;i<q;i++){
            int num=qu[i][0] ^ qu[i][1];
            if(map.containsKey(num)) ans[i]=map.get(num);
            else   ans[i]=new int[]{-1,-1};
        }
        return ans;
    }
}

2nd Method 

class Solution {
    public int[][] substringXorQueries(String s, int[][] queries) {
        Map<Integer, int[]> substrings = new HashMap<>();
        for(int i = 0; i < s.length(); i++) {
            if(s.charAt(i) == '0') {
                substrings.putIfAbsent(0, new int[]{i, i});                        
                continue;
            }
            int num = 0;
            for(int j = i; j < s.length() && j < i + 32; j++) {
                num = (num << 1) + (s.charAt(j) - '0');     
                substrings.putIfAbsent(num, new int[]{i, j});                             
            }
        }
        
        for(int i = 0; i < queries.length; i++) {
            int num = queries[i][0] ^ queries[i][1];            
            queries[i] = substrings.getOrDefault(num, new int[] {-1, -1});
        }         
        return queries;
    }
}

                             OR

class Solution {
    public int[][] substringXorQueries(String s, int[][] queries) {
        int n = s.length() , m = queries.length;
        //int[][] ans = new int[m][2];
        HashMap<Integer ,  int[]> map = new HashMap<>();
        for(int i=0 ; i<n; i++){
            if(s.charAt(i) == '0'){
               map.putIfAbsent(0 , new int[]{i,i});
                continue;
            }
            int num = 0;
            for(int j=i; j<n && j<i+32; j++){
                num = (num << 1) + (s.charAt(j) - '0');
                 map.putIfAbsent(num , new int[]{i,j});

            }
        }  
      for(int i=0;i<m;i++){
            int num=queries[i][0] ^ queries[i][1];
            queries[i] = map.getOrDefault(num , new int[]{-1 , -1});
            // if(map.containsKey(num)) ans[i]=map.get(num);
            // else   ans[i]=new int[]{-1,-1};
        }
        //return ans;
        return queries;
    }
}




2444. Count Subarrays With Fixed Bounds in c++



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)



class Solution {
public:
    long long countSubarrays(vector<int>& nums, int minK, int maxK) {
        long long ans = 0;
        int n = nums.size();
        int minPosition = -1 , maxPosition = -1 , leftBound = -1;
        for(int i=0; i<n; i++){
            if(nums[i] < minK || nums[i] > maxK){
                leftBound = i;
            }
            if(nums[i] == minK){
                minPosition = i;
            }
            if(nums[i] == maxK){
                maxPosition = i;
            }
            ans += max(0 , min(maxPosition  , minPosition) - leftBound);
        }
        return ans;
    }
};



2444. Count Subarrays With Fixed Bounds in java



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)



class Solution {
    public long countSubarrays(int[] nums, int minK, int maxK) {
        long ans = 0;
        int n = nums.length;
        int minPosition = -1 , maxPosition = -1 , leftBound = -1;
        for(int i=0; i<n; i++){
            if(nums[i] < minK || nums[i] > maxK){
                leftBound = i;
            }
            if(nums[i] == minK){
                minPosition = i;
            }
            if(nums[i] == maxK){
                maxPosition = i;
            }
            ans += Math.max(0 , Math.min(maxPosition  , minPosition) - leftBound);
        }
        return ans;
    }
}




2565. Subsequence With the Minimum Score in c++



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)


class Solution {
public:
int minimumScore(string s, string t) {
    int ss = s.size(), st = t.size(), k = st - 1;
    vector<int> dp(st, -1);
    for (int i = ss - 1; i >= 0 && k >= 0; --i)
        if (s[i] == t[k])
            dp[k--] = i;
    int res = k + 1;
    for (int i = 0, j = 0; i < ss && j < st && res > 0; ++i)
        if (s[i] == t[j]) {
            for (; k < t.size() && dp[k] <= i; ++k);
            res = min(res, k - (++j));
        }
    return res;
}
 
};



2565. Subsequence With the Minimum Score in java



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)



class Solution {
    public int minimumScore(String s, String t) {
        int ss = s.length(), st = t.length(), k = st - 1;
        int[] dp = new int[st];
        Arrays.fill(dp, -1);
        for (int i = ss - 1; i >= 0 && k >= 0; --i)
            if (s.charAt(i) == t.charAt(k))
                dp[k--] = i;
        int res = k + 1;
        for (int i = 0, j = 0; i < ss && j < st && res > 0; ++i)
            if (s.charAt(i) == t.charAt(j)) {
                for (; k < t.length() && dp[k] <= i; ++k);
                res = Math.min(res, k - (++j));
            }
        return res;
    }
 
}


2566. Maximum Difference by Remapping a Digit in c++



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)




class Solution {
public:
    int minMaxDifference(int num) {
        string s =to_string(num), large = to_string(num), small = to_string(num);
        char dl = -1, ds = -1;
        for(int i = 0; i < s.size(); ++i){
            if(dl == -1 && s[i] != '9'){
                dl = s[i];
                large[i] = '9';
            }else {
                large[i] = (s[i] == dl)?'9': s[i];
            }
            
            if(ds == -1 && s[i] != '0'){
                ds = s[i];
                small[i] = '0';
            }else{
                small[i] = (s[i] == ds)?'0':s[i];
            }
        }
        return stoi(large) - stoi(small);
    }
};



2566. Maximum Difference by Remapping a Digit in java



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)



class Solution {
    public int minMaxDifference(int num) {
        String s = String.valueOf(num), large = String.valueOf(num), small = String.valueOf(num);
        int dl = -1, ds = -1;
        for(int i = 0; i < s.length(); ++i){
            if(dl == -1 && s.charAt(i) != '9'){
                dl = s.charAt(i);
                large = large.substring(0,i) + '9' + large.substring(i+1);
            }else {
                large = large.substring(0,i) + ((s.charAt(i) == dl)?'9': s.charAt(i)) + large.substring(i+1);
            }
            
            if(ds == -1 && s.charAt(i) != '0'){
                ds = s.charAt(i);
                small = small.substring(0,i) + '0' + small.substring(i+1);
            }else{
                small = small.substring(0,i) + ((s.charAt(i) == ds)?'0':s.charAt(i)) + small.substring(i+1);
            }
        }
        return Integer.parseInt(large) - Integer.parseInt(small);
    }
}


2567. Minimum Score by Changing Two Elements in c++



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)



class Solution {
public:
        int minimizeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int case1 = nums.back() - nums[2];
        int case2 = nums[nums.size() - 3] - nums[0];
        int case3 = nums[nums.size() - 2] - nums[1];
        return min({case1, case2, case3});
    }
};



2567. Minimum Score by Changing Two Elements in java



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)



class Solution {
    public int minimizeSum(int[] nums) {
        Arrays.sort(nums);
        int case1 = nums[nums.length - 1] - nums[2];
        int case2 = nums[nums.length - 3] - nums[0];
        int case3 = nums[nums.length - 2] - nums[1];
        return Math.min(case1, Math.min(case2, case3));
    }
}




1345. Jump Game IV in c++


// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)



class Solution {
public:
    int minJumps(vector<int>& arr) {
        int n = arr.size();  // variable to store the length of the array
        unordered_map<int, vector<int>> mp;  // map to store the indices of the elements
        for(int i = 0; i < n; i++){  // iterate through the array
            mp[arr[i]].push_back(i);  // store the indices of the elements
        }
        queue<int> q;  // queue to store the indices
        q.push(0);  // push the first index
        vector<bool> visited(n, false);  // vector to store thae visited indices
        visited[0] = true;  // mark t first index as visited
        int steps = 0;  // variable to store the number of steps
        while(!q.empty()){  // iterate until the queue is empty
            int size = q.size();  // variable to store the size of the queue
            for(int i = 0; i < size; i++){  // iterate through the queue
                int index = q.front();  // variable to store the current index
                q.pop();  // pop the current index
                if(index == n - 1){  // if the current index is the last index
                    return steps;  // return the number of steps
                }
                if(index - 1 >= 0 && !visited[index - 1]){  // if the previous index is valid and not visited
                    q.push(index - 1);  // push the previous index
                    visited[index - 1] = true;  // mark the previous index as visited
                }
                if(index + 1 < n && !visited[index + 1]){  // if the next index is valid and not visited
                    q.push(index + 1);  // push the next index
                    visited[index + 1] = true;  // mark the next index as visited
                }
                for(int j = 0; j < mp[arr[index]].size(); j++){  // iterate through the indices of the current element
                    if(!visited[mp[arr[index]][j]]){  // if the current index is not visited
                        q.push(mp[arr[index]][j]);  // push the current index
                        visited[mp[arr[index]][j]] = true;  // mark the current index as visited
                    }
                }
                mp[arr[index]].clear();  // clear the indices of the current element
            }
            steps++;  // increment the number of steps
        }
        return steps;  // return the number of steps
    }
};
                    



1345. Jump Game IV in java


// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)



class Solution {
    public int minJumps(int[] arr) {
        int n = arr.length;  // variable to store the length of the array
        Map<Integer, List<Integer>> mp = new HashMap<>();  // map to store the indices of the elements
        for(int i = 0; i < n; i++){  // iterate through the array
            mp.putIfAbsent(arr[i], new ArrayList<>());  // store the indices of the elements
            mp.get(arr[i]).add(i);
        }
        Queue<Integer> q = new LinkedList<>();  // queue to store the indices
        q.add(0);  // push the first index
        boolean[] visited = new boolean[n];  // vector to store the visited indices
        visited[0] = true;  // mark the first index as visited
        int steps = 0;  // variable to store the number of steps
        while(!q.isEmpty()){  // iterate until the queue is empty
            int size = q.size();  // variable to store the size of the queue
            for(int i = 0; i < size; i++){  // iterate through the queue
                int index = q.poll();  // variable to store the current index
                if(index == n - 1){  // if the current index is the last index
                    return steps;  // return the number of steps
                }
                if(index - 1 >= 0 && !visited[index - 1]){  // if the previous index is valid and not visited
                    q.add(index - 1);  // push the previous index
                    visited[index - 1] = true;  // mark the previous index as visited
                }
                if(index + 1 < n && !visited[index + 1]){  // if the next index is valid and not visited
                    q.add(index + 1);  // push the next index
                    visited[index + 1] = true;  // mark the next index as visited
                }
                for(int j = 0; j < mp.get(arr[index]).size(); j++){  // iterate through the indices of the current element
                    if(!visited[mp.get(arr[index]).get(j)]){  // if the current index is not visited
                        q.add(mp.get(arr[index]).get(j));  // push the current index
                        visited [mp.get(arr[index]).get(j)] = true;  // mark the current index as visited
                    }
                }
                mp.get(arr[index]).clear();  // clear the indices of the current element
            }
            steps++;  // increment the number of steps
        }
        return steps;  // return the number of steps
    }
}




54. Spiral Matrix in c++

// Time Complexity : O(m * n) where m is the number of rows and n is the number of columns and space complexity is O(1)



class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> result;  // vector to store the result
        if(matrix.size() == 0){  // if the matrix is empty
            return result;  // return the result
        }
        int m = matrix.size();  // variable to store the number of rows
        int n = matrix[0].size();  // variable to store the number of columns
        int top = 0;  // variable to store the top row
        int bottom = m - 1;  // variable to store the bottom row
        int left = 0;  // variable to store the left column
        int right = n - 1;  // variable to store the right column
        while(top <= bottom && left <= right){  // iterate until the top row is less than or equal to the bottom row and the left column is less than or equal to the right column
            for(int i = left; i <= right; i++){  // iterate through the top row
                result.push_back(matrix[top][i]);  // push the element to the result
            }
            top++;  // increment the top row
            for(int i = top; i <= bottom; i++){  // iterate through the right column
                result.push_back(matrix[i][right]);  // push the element to the result
            }
            right--;  // decrement the right column
            if(top <= bottom){  // if the top row is less than or equal to the bottom row
                for(int i = right; i >= left; i--){  // iterate through the bottom row
                    result.push_back(matrix[bottom][i]);  // push the element to the result
                }
                bottom--;  // decrement the bottom row
            }
            if(left <= right){  // if the left column is less than or equal to the right column
                for(int i = bottom; i >= top; i--){  // iterate through the left column
                    result.push_back(matrix[i][left]);  // push the element to the result
                }
                left++;  // increment the left column
            }
        }
        return result;  // return the result
    }
};


54. Spiral Matrix in java


// Time Complexity : O(m * n) where m is the number of rows and n is the number of columns and space complexity is O(1)



class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> result = new ArrayList<>();  // list to store the result
        if(matrix.length == 0){  // if the matrix is empty
            return result;  // return the result
        }
        int m = matrix.length;  // variable to store the number of rows
        int n = matrix[0].length;  // variable to store the number of columns
        int top = 0;  // variable to store the top row
        int bottom = m - 1;  // variable to store the bottom row
        int left = 0;  // variable to store the left column
        int right = n - 1;  // variable to store the right column
        while(top <= bottom && left <= right){  // iterate until the top row is less than or equal to the bottom row and the left column is less than or equal to the right column
            for(int i = left; i <= right; i++){  // iterate through the top row
                result.add(matrix[top][i]);  // add the element to the result
            }
            top++;  // increment the top row
            for(int i = top; i <= bottom; i++){  // iterate through the right column
                result.add(matrix[i][right]);  // add the element to the result
            }
            right--;  // decrement the right column
            if(top <= bottom){  // if the top row is less than or equal to the bottom row
                for(int i = right; i >= left; i--){  // iterate through the bottom row
                    result.add(matrix[bottom][i]);  // add the element to the result
                }
                bottom--;  // decrement the bottom row
            }
            if(left <= right){  // if the left column is less than or equal to the right column
                for(int i = bottom; i >= top; i--){  // iterate through the left column
                    result.add(matrix[i][left]);  // add the element to the result
                }
                left++;  // increment the left column
            }
        }
        return result;  // return the result
    }
}






354. Russian Doll Envelopes in c++ best iterative method time complexity ologn

// Time Complexity : O(nlogn) where n is the number of envelopes and space complexity is O(n)



class Solution {
public:
    int maxEnvelopes(vector<vector<int>>& envelopes) {
        if(envelopes.size() == 0){  // if the envelopes are empty
            return 0;  // return 0
        }
         sort(envelopes.begin(), envelopes.end(), [](const auto& a, const auto& b) {  // sort the envelopes based on the widt
            return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);
        });
        vector<int> dp;  // vector to store the dp values
        for(int i = 0; i < envelopes.size(); i++){  // iterate through the envelopes
            int index = lower_bound(dp.begin(), dp.end(), envelopes[i][1]) - dp.begin();  // find the index of the current envelope height in the dp vector
            if(index == dp.size()){  // if the index is equal to the size of the dp vector
                dp.push_back(envelopes[i][1]);  // push the current envelope height to the dp vector
            }
            else{  // if the index is not equal to the size of the dp vector
                dp[index] = envelopes[i][1];  // update the dp value at the index with the current envelope height
            }
        }
        return dp.size();  // return the size of the dp vector
    }
};


2nd Method  :


class Solution {
public:
    int maxEnvelopes(vector<vector<int>>& envelopes) {
        if (envelopes.empty()) {
            return 0;
        }
        sort(envelopes.begin(), envelopes.end(), [](const auto& a, const auto& b) {
            return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);
        });
        vector<int> dp;
        for (const auto& env : envelopes) {
            auto it = lower_bound(dp.begin(), dp.end(), env[1]);
            if (it == dp.end()) {
                dp.push_back(env[1]);
            } else {
                *it = env[1];
            }
        }
        return dp.size();
    }
};





354. Russian Doll Envelopes in java best iterative method time complexity ologn


// Time Complexity : O(nlogn) where n is the number of envelopes and space complexity is O(n)



class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        if(envelopes.length == 0){  // if the envelopes are empty
            return 0;  // return 0
        }
         Arrays.sort(envelopes, (a, b) -> a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]); // sort the envelopes based on the width
        int[] dp = new int[envelopes.length];  // array to store the dp values
        int size = 0;  // variable to store the size of the dp array
        for(int[] envelope : envelopes){  // iterate through the envelopes
            int index = Arrays.binarySearch(dp, 0, size, envelope[1]);  // find the index of the current envelope height in the dp array
            if(index < 0){  // if the index is less than 0
                index = -(index + 1);  // update the index
            }
            dp[index] = envelope[1];  // update the dp value at the index with the current envelope height
            if(index == size){  // if the index is equal to the size of the dp array
                size++;  // increment the size of the dp array
            }
        }
        return size;  // return the size of the dp array
    }
}


2nd Method :

class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        if (envelopes.length == 0) {
            return 0;
        }
        Arrays.sort(envelopes, (a, b) -> a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);
        int n = envelopes.length;
        int[] dp = new int[n];
        int maxEnvelopes = 0;
        for (int[] env : envelopes) {
            int i = Arrays.binarySearch(dp, 0, maxEnvelopes, env[1]);
            if (i < 0) {
                i = -(i + 1);
            }
            dp[i] = env[1];
            if (i == maxEnvelopes) {
                maxEnvelopes++;
            }
        }
        return maxEnvelopes;
    }
}



1539. Kth Missing Positive Number in c++

// Time Complexity : O(logn) where n is the number of elements in the array and space complexity is O(1)



class Solution {
public:
    int findKthPositive(vector<int>& arr, int k) {
        int left = 0;  // variable to store the left index
        int right = arr.size() - 1;  // variable to store the right index
        while(left <= right){  // iterate until the left index is less than or equal to the right index
            int mid = left + (right - left) / 2;  // variable to store the mid index
            if(arr[mid] - (mid + 1) >= k){  // if the difference between the element at the mid index and the mid index is greater than or equal to k
                right = mid - 1;  // update the right index
            }
            else{  // if the difference between the element at the mid index and the mid index is less than k
                left = mid + 1;  // update the left index
            }
        }
        return left + k;  // return the left index + k
    }
};



1539. Kth Missing Positive Number in java


// Time Complexity : O(logn) where n is the number of elements in the array and space complexity is O(1)



class Solution {
    public int findKthPositive(int[] arr, int k) {
        int left = 0;  // variable to store the left index
        int right = arr.length - 1;  // variable to store the right index
        while(left <= right){  // iterate until the left index is less than or equal to the right index
            int mid = left + (right - left) / 2;  // variable to store the mid index
            if(arr[mid] - (mid + 1) >= k){  // if the difference between the element at the mid index and the mid index is greater than or equal to k
                right = mid - 1;  // update the right index
            }
            else{  // if the difference between the element at the mid index and the mid index is less than k
                left = mid + 1;  // update the left index
            }
        }
        return left + k;  // return the left index + k
    }
};



5. Longest Palindromic Substring in c++ using dp


// Time Complexity : O(n^2) where n is the length of the string and space complexity is O(n^2)



class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.length();  // variable to store the length of the string
        vector<vector<bool>> dp(n, vector<bool>(n, false));  // 2d vector to store the dp values
        int start = 0;  // variable to store the start index of the longest palindrome
        int end = 0;  // variable to store the end index of the longest palindrome
        for(int i = 0; i < n; i++){  // iterate through the string
            dp[i][i] = true;  // update the dp value at the current index to true
            if(i < n - 1 && s[i] == s[i + 1]){  // if the current index is less than the length of the string - 1 and the current character is equal to the next character
                dp[i][i + 1] = true;  // update the dp value at the current index and the next index to true
                start = i;  // update the start index to the current index
                end = i + 1;  // update the end index to the next index
            }
        }
        for(int i = n - 1; i >= 0; i--){  // iterate through the string from the end
            for(int j = i + 2; j < n; j++){  // iterate through the string from the current index + 2
                if(s[i] == s[j] && dp[i + 1][j - 1]){  // if the current character is equal to the character at the current index + 2 and the dp value at the current index + 1 and the current index - 1 is true
                    dp[i][j] = true;  // update the dp value at the current index and the current index + 2 to true
                    if(j - i > end - start){  // if the difference between the current index and the current index + 2 is greater than the difference between the end index and the start index
                        start = i;  // update the start index to the current index
                        end = j;  // update the end index to the current index + 2
                    }
                }
            }
        }
        return s.substr(start, end - start + 1);  // return the substring from the start index to the end index
    }
};

2nd Method  

class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();

        if (n == 1) { return s; }

        int longestSubstringLength = 1, longestSubstringLengthStartIndex = 0, start, mid = 0, end;

        while (mid + (longestSubstringLength / 2) < n) {
            start = mid;
            end = mid;

            while (s[mid] == s[end + 1]) {
                ++end;
            }

            mid = end + 1;
            while (start > 0 && end + 1 < n && s[start - 1] == s[end + 1]) {
                --start;
                ++end;
            }
            if (end - start + 1 > longestSubstringLength) {
                longestSubstringLength = end - start + 1;
                longestSubstringLengthStartIndex = start;
            }
        }

        return s.substr(longestSubstringLengthStartIndex, longestSubstringLength);
    }
};



5. Longest Palindromic Substring in java using dp


// Time Complexity : O(n^2) where n is the length of the string and space complexity is O(n^2)



class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();  // variable to store the length of the string
        boolean[][] dp = new boolean[n][n];  // 2d array to store the dp values
        int start = 0;  // variable to store the start index of the longest palindrome
        int end = 0;  // variable to store the end index of the longest palindrome
        for(int i = 0; i < n; i++){  // iterate through the string
            dp[i][i] = true;  // update the dp value at the current index to true
            if(i < n - 1 && s.charAt(i) == s.charAt(i + 1)){  // if the current index is less than the length of the string - 1 and the current character is equal to the next character
                dp[i][i + 1] = true;  // update the dp value at the current index and the next index to true
                start = i;  // update the start index to the current index
                end = i + 1;  // update the end index to the next index
            }
        }
        for(int i = n - 1; i >= 0; i--){  // iterate through the string from the end
            for(int j = i + 2; j < n; j++){  // iterate through the string from the current index + 2
                if(s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]){  // if the current character is equal to the character at the current index + 2 and the dp value at the current index + 1 and the current index - 1 is true
                    dp[i][j] = true;  // update the dp value at the current index and the current index + 2 to true
                    if(j - i > end - start){  // if the difference between the current index and the current index + 2 is greater than the difference between the end index and the start index
                        start = i;  // update the start index to the current index
                        end = j;  // update the end index to the current index + 2
                    }
                }
            }
        }
        return s.substring(start, end + 1);  // return the substring from the start index to the end index
    }
}

2nd Method


class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();

        if (n == 1) { return s; }

        int longestSubstringLength = 1, longestSubstringLengthStartIndex = 0, start, mid = 0, end;

        while (mid + (longestSubstringLength / 2) < n) {
            start = mid;
            end = mid;

            while (end + 1  < n && s.charAt(mid) == s.charAt(end + 1)) {
                ++end;
            }

            mid = end + 1;
            while (start > 0 && end + 1 < n && s.charAt(start - 1) == s.charAt(end + 1)) {
                --start;
                ++end;
            }
            if (end - start + 1 > longestSubstringLength) {
                longestSubstringLength = end - start + 1;
                longestSubstringLengthStartIndex = start;
            }
        }

        return s.substring(longestSubstringLengthStartIndex, longestSubstringLengthStartIndex + longestSubstringLength);
    }
}



10. Regular Expression Matching in c++


// Time Complexity : O(m*n) where m is the length of the string and n is the length of the pattern and space complexity is O(m*n)



class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size();  // variable to store the length of the string
        int n = p.size();  // variable to store the length of the pattern
        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));  // 2d vector to store the dp values
        dp[0][0] = true;  // update the dp value at the 0th index of the string and the 0th index of the pattern to true
        for(int i = 1; i <= n; i++){  // iterate through the pattern
            if(p[i - 1] == '*'){  // if the current character is equal to *
                dp[0][i] = dp[0][i - 2];  // update the dp value at the 0th index of the string and the current index of the pattern to the dp value at the 0th index of the string and the current index - 2 of the pattern
            }
        }
        for(int i = 1; i <= m; i++){  // iterate through the string
            for(int j = 1; j <= n; j++){  // iterate through the pattern
                if(p[j - 1] == '.' || p[j - 1] == s[i - 1]){  // if the current character of the pattern is equal to . or the current character of the pattern is equal to the current character of the string
                    dp[i][j] = dp[i - 1][j - 1];  // update the dp value at the current index of the string and the current index of the pattern to the dp value at the current index - 1 of the string and the current index - 1 of the pattern
                }
                else if(p[j - 1] == '*'){  // if the current character of the pattern is equal to *
                    dp[i][j] = dp[i][j - 2];  // update the dp value at the current index of the string and the current index of the pattern to the dp value at the current index of the string and the current index - 2 of the pattern
                    if(p[j - 2] == '.' || p[j - 2] == s[i - 1]){  // if the current character - 2 of the pattern is equal to . or the current character - 2 of the pattern is equal to the current character of the string
                        dp[i][j] = dp[i][j] || dp[i - 1][j];  // update the dp value at the current index of the string and the current index of the pattern to the dp value at the current index of the string and the current index of the pattern or the dp value at the current index - 1 of the string and the current index of the pattern
                    }
                }
            }
        }
        return dp[m][n];  // return the dp value at the last index of the string and the last index of the pattern
    }
};
        

2nd Method 

class Solution {
public:
    bool isMatch(string s, string p) {
         
        //tabulation with single vector 
        int m = s.size(), n = p.size();
        vector<bool> cur(n + 1, false);
        for (int i = 0; i <= m; i++) {
            bool pre = cur[0];
            cur[0] = !i;
            for (int j = 1; j <= n; j++) {
                bool temp = cur[j];
                if (p[j - 1] == '*') {
                    cur[j] = cur[j - 2] || (i && cur[j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));
                } else {
                    cur[j] = i && pre && (s[i - 1] == p[j - 1] || p[j - 1] == '.');
                }
                pre = temp;
            }
        }
        return cur[n];
    }
};



10. Regular Expression Matching in java



// Time Complexity : O(m*n) where m is the length of the string and n is the length of the pattern and space complexity is O(m*n)



class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length();  // variable to store the length of the string
        int n = p.length();  // variable to store the length of the pattern
        boolean[][] dp = new boolean[m + 1][n + 1];  // 2d array to store the dp values
        dp[0][0] = true;  // update the dp value at the 0th index of the string and the 0th index of the pattern to true
        for(int i = 1; i <= n; i++){  // iterate through the pattern
            if(p.charAt(i - 1) == '*'){  // if the current character is equal to *
                dp[0][i] = dp[0][i - 2];  // update the dp value at the 0th index of the string and the current index of the pattern to the dp value at the 0th index of the string and the current index - 2 of the pattern
            }
        }
        for(int i = 1; i <= m; i++){  // iterate through the string
            for(int j = 1; j <= n; j++){  // iterate through the pattern
                if(p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1)){  // if the current character of the pattern is equal to . or the current character of the pattern is equal to the current character of the string
                    dp[i][j] = dp[i - 1][j - 1];  // update the dp value at the current index of the string and the current index of the pattern to the dp value at the current index - 1 of the string and the current index - 1 of the pattern
                }
                else if(p.charAt(j - 1) == '*'){  // if the current character of the pattern is equal to *
                    dp[i][j] = dp[i][j - 2];  // update the dp value at the current index of the string and the current index of the pattern to the dp value at the current index of the string and the current index - 2 of the pattern
                    if(p.charAt(j - 2) == '.' || p.charAt(j - 2) == s.charAt(i - 1)){  // if the current character - 2 of the pattern is equal to . or the current character - 2 of the pattern is equal to the current character of the string
                        dp[i][j] = dp[i][j] || dp[i - 1][j];  // update the dp value at the current index of the string and the current index of the pattern to the dp value at the current index of the string and the current index of the pattern or the dp value at the current index - 1 of the string and the current index of the pattern
                    }
                }
            }
        }
        return dp[m][n];  // return the dp value at the last index of the string and the last index of the pattern
    }
}



22. Generate Parentheses in c++





// Time Complexity : O(2^n) where n is the number of pairs of parentheses and space complexity is O(n)



class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> result;  // vector to store the result
        string s = "";  // string to store the current string
        helper(result, s, 0, 0, n);  // call the helper functio
        return result;  // return the result
    }
    void helper(vector<string>& result, string s, int open, int close, int n){  // helper function
        if(s.size() == 2 * n){  // if the size of the current string is equal to 2 * n
            result.push_back(s);  // push the current string to the result
            return;
        }
        if(open < n){  // if the number of open parentheses is less than n
            helper(result, s + "(", open + 1, close, n);  // call the helper function with the current string + (, open + 1, close and n
        }
        if(close < open){  // if the number of close parentheses is less than open
            helper(result, s + ")", open, close + 1, n);  // call the helper function with the current string + ), open, close + 1 and n
        }
    }
};



22. Generate Parentheses in java



// Time Complexity : O(2^n) where n is the number of pairs of parentheses and space complexity is O(n)



class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> result = new ArrayList<>();  // list to store the result
        helper(result, "", 0, 0, n);  // call the helper function
        return result;  // return the result
    }
    public void helper(List<String> result, String s, int open, int close, int n){  // helper function
        if(s.length() == 2 * n){  // if the length of the current string is equal to 2 * n
            result.add(s);  // add the current string to the result
            return;
        }
        if(open < n){  // if the number of open parentheses is less than n
            helper(result, s + "(", open + 1, close, n);  // call the helper function with the current string + (, open + 1, close and n
        }
        if(close < open){  // if the number of close parentheses is less than open
            helper(result, s + ")", open, close + 1, n);  // call the helper function with the current string + ), open, close + 1 and n
        }
    }
}

2187. Minimum Time to Complete Trips in c++ using Binary Search 



// Time Complexity : O(nlogn) where n is the number of trips and space complexity is O(1)




class Solution {
public:
    // Can these buses finish 'totalTrips' of trips in 'givenTime'?
    bool timeEnough(vector<int>& time, long long givenTime, int totalTrips) {
        long long actualTrips = 0;
        for (int t : time) {
            actualTrips += givenTime / t;
        }
        return actualTrips >= totalTrips;
    }
    long long minimumTime(vector<int>& time, int totalTrips) {
        // Initialize the left and right boundaries.
        long long left = 1, right = 1LL * *max_element(time.begin(), time.end()) * totalTrips;

        // Binary search to find the minimum time to finish the task.
        while (left < right) {
            long long mid = (left + right) / 2;
            if (timeEnough(time, mid, totalTrips)) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
};



2187. Minimum Time to Complete Trips in java using Binary Search



// Time Complexity : O(nlogn) where n is the number of trips and space complexity is O(1)



class Solution {
    public long minimumTime(int[] time, int totalTrips) {
        long left = 1, right = 1L * Arrays.stream(time).max().getAsInt() * totalTrips;
        while (left < right) {
            long mid = (left + right) / 2;
            if (timeEnough(time, mid, totalTrips)) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
    public boolean timeEnough(int[] time, long givenTime, int totalTrips) {
        long actualTrips = 0;
        for (int t : time) {
            actualTrips += givenTime / t;
        }
        return actualTrips >= totalTrips;
    }
}








875. Koko Eating Bananas in c++


// Time Complexity : O(nlogn) where n is the number of piles and space complexity is O(1)



class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int h) {
        int low = 1;  // variable to store the low value
        int high = *max_element(piles.begin(), piles.end());  // variable to store the high value
        while(low < high){  // iterate until the low value is less than the high value
            int mid = low + (high - low) / 2;  // variable to store the mid value
            int hours = 0;  // variable to store the number of hours
            for(int i = 0; i < piles.size(); i++){  // iterate through the piles
                hours += (piles[i] / mid);  // calculate the number of hours
                if(piles[i] % mid != 0){  // if the current pile is not divisible by the mid value
                    hours++;  // increment the number of hours
                }
            }
            if(hours > h){  // if the number of hours is greater than the given hours
                low = mid + 1;  // increment the low value
            }
            else{  // if the number of hours is less than or equal to the given hours
                high = mid;  // decrement the high value
            }
        }
        return low;  // return the low value
    }
};


2nd Method  using bool function



// Time Complexity : O(nlogn) where n is the number of piles and space complexity is O(1)



class Solution {
public:
    bool canEatAllBananas(vector<int>& piles, int h, int k){  // function to check if the given k value is valid
        int hours = 0;  // variable to store the number of hours
        for(int i = 0; i < piles.size(); i++){  // iterate through the piles
            hours += (piles[i] / k);  // calculate the number of hours
            if(piles[i] % k != 0){  // if the current pile is not divisible by the k value
                hours++;  // increment the number of hours
            }
        }
        return hours <= h;  // return true if the number of hours is less than or equal to the given hours
    }
    int minEatingSpeed(vector<int>& piles, int h) {
        int low = 1;  // variable to store the low value
        int high = *max_element(piles.begin(), piles.end());  // variable to store the high value
        while(low < high){  // iterate until the low value is less than the high value
            int mid = low + (high - low) / 2;  // variable to store the mid value
            if(canEatAllBananas(piles, h, mid)){  // if the given mid value is valid
                high = mid;  // decrement the high value
            }
            else{  // if the given mid value is not valid
                low = mid + 1;  // increment the low value
            }
        }
        return low;  // return the low value
    }
};



                        OR 

class Solution {
public:
    bool canEatAllBananas(vector<int>& piles, int H, int K) {
        int hours = 0;
        for (int pile : piles) {
            hours += (pile - 1) / K + 1;
        }
        return hours <= H;
    }
    int minEatingSpeed(vector<int>& piles, int H) {
        int left = 1, right = *max_element(piles.begin(), piles.end());
        while (left < right) {
            int mid = (left + right) / 2;
            if (canEatAllBananas(piles, H, mid)) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
};



875. Koko Eating Bananas in java





// Time Complexity : O(nlogm) where n is the length of the array and m is the maximum element in the array and space complexity is O(1)



class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int n = piles.length;  // variable to store the length of the array
        int low = 1;  // variable to store the minimum speed
        int high = 0;  // variable to store the maximum speed
        for(int i = 0; i < n; i++){  // iterate through the array
            high = Math.max(high, piles[i]);  // find the maximum element in the array
        }
        while(low < high){  // iterate until the low is less than high
            int mid = low + (high - low) / 2;  // variable to store the current speed
            int hours = 0;  // variable to store the number of hours
            for(int i = 0; i < n; i++){  // iterate through the array
                hours += (piles[i] / mid);  // calculate the number of hours
                if(piles[i] % mid != 0){  // if the current element is not completely divisible by the current speed
                    hours++;  // increment the number of hours
                }
            }
            if(hours > h){  // if the number of hours is greater than the given hours
                low = mid + 1;  // increment the low
            }
            else{  // if the number of hours is less than or equal to the given hours
                high = mid;  // decrement the high
            }
        }
        return low;  // return the low
    }
}





2nd Method using bool function


// Time Complexity : O(nlogn) where n is the number of piles and space complexity is O(1)


class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int low = 1, high = Arrays.stream(piles).max().getAsInt();
        while (low < high) {
            int mid = low + (high - low) / 2;
            if (canEatAllBananas(piles, h, mid)) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }
    public boolean canEatAllBananas(int[] piles, int h, int k) {
        int hours = 0;
        for (int pile : piles) {
            hours += (pile - 1) / k + 1;
        }
        return hours <= h;
    }
}


32. Longest Valid Parentheses in c++



// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)



class Solution {
public:
    int longestValidParentheses(string s) {
        int n = s.length();  // variable to store the length of the string
        stack<int> st;  // stack to store the indices of the string
        st.push(-1);  // push -1 to the stack
        int maxLen = 0;  // variable to store the maximum length
        for(int i = 0; i < n; i++){  // iterate through the string
            if(s[i] == '('){  // if the current character is '('
                st.push(i);  // push the index to the stack
            }
            else{  // if the current character is ')'
                st.pop();  // pop the top element from the stack
                if(st.empty()){  // if the stack is empty
                    st.push(i);  // push the index to the stack
                }
                else{  // if the stack is not empty
                    maxLen = max(maxLen, i - st.top());  // calculate the maximum length
                }
            }
        }
        return maxLen;  // return the maximum length
    }
};


2nd Method using dp


// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)



class Solution {
public:
    int longestValidParentheses(string s) {
        int n = s.length();  // variable to store the length of the string
        vector<int> dp(n, 0);  // vector to store the dp values
        int maxLen = 0;  // variable to store the maximum length
        for(int i = 1; i < n; i++){  // iterate through the string
            if(s[i] == ')'){  // if the current character is ')'
                if(s[i - 1] == '('){  // if the previous character is '('
                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;  // calculate the dp value
                }
                else if(i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '('){  // if the previous character is ')' and the previous dp value is greater than 0 and the previous character of the previous dp value is '('
                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;  // calculate the dp value
                }
                maxLen = max(maxLen, dp[i]);  // calculate the maximum length
            }
        }
        return maxLen;  // return the maximum length
    }
};


32. Longest Valid Parentheses in java



// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)



class Solution {
    public int longestValidParentheses(String s) {
        int n = s.length();  // variable to store the length of the string
        Stack<Integer> st = new Stack<>();  // stack to store the indices of the string
        st.push(-1);  // push -1 to the stack
        int maxLen = 0;  // variable to store the maximum length
        for(int i = 0; i < n; i++){  // iterate through the string
            if(s.charAt(i) == '('){  // if the current character is '('
                st.push(i);  // push the index to the stack
            }
            else{  // if the current character is ')'
                st.pop();  // pop the top element from the stack
                if(st.empty()){  // if the stack is empty
                    st.push(i);  // push the index to the stack
                }
                else{  // if the stack is not empty
                    maxLen = Math.max(maxLen, i - st.peek());  // calculate the maximum length
                }
            }
        }
        return maxLen;  // return the maximum length
    }
}



2nd Method using dp



// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)



class Solution {
    public int longestValidParentheses(String s) {
        int n = s.length();  // variable to store the length of the string
        int[] dp = new int[n];  // array to store the dp values
        int maxLen = 0;  // variable to store the maximum length
        for(int i = 1; i < n; i++){  // iterate through the string
            if(s.charAt(i) == ')'){  // if the current character is ')'
                if(s.charAt(i - 1) == '('){  // if the previous character is '('
                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;  // calculate the dp value
                }
                else if(i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '('){  // if the previous character is ')' and the previous dp value is greater than 0 and the previous character of the previous dp value is '('
                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;  // calculate the dp value
                }
                maxLen = Math.max(maxLen, dp[i]);  // calculate the maximum length
            }
        }
        return maxLen;  // return the maximum length
    }
}



42. Trapping Rain Water in c++ using brute force 



// Time Complexity : O(n^2) where n is the length of the array and space complexity is O(1)



class Solution {

public:

    int trap(vector<int>& height) {

        int n = height.size();  // variable to store the length of the array

        int result = 0;  // variable to store the result

        for(int i = 1; i < n - 1; i++){  // iterate through the arra

            int leftMax = 0;  // variable to store the left max value

            int rightMax = 0;  // variable to store the right max value

            for(int j = i; j >= 0; j--){  // iterate through the array from the current index to the left

                leftMax = max(leftMax, height[j]);  // calculate the left max value

            }

            for(int j = i; j < n; j++){  // iterate through the array from the current index to the right

                rightMax = max(rightMax, height[j]);  // calculate the right max value

            }

            result += min(leftMax, rightMax) - height[i];  // calculate the result

        }

        return result;  // return the result

    }

};


2nd Method using Dp



// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)



class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();  // variable to store the length of the array
        vector<int> leftMax(n, 0);  // vector to store the left max values
        vector<int> rightMax(n, 0);  // vector to store the right max values
        int result = 0;  // variable to store the result
        leftMax[0] = height[0];  // update the left max value
        for(int i = 1; i < n; i++){  // iterate through the array
            leftMax[i] = max(leftMax[i - 1], height[i]);  // calculate the left max value
        }
        rightMax[n - 1] = height[n - 1];  // update the right max value
        for(int i = n - 2; i >= 0; i--){  // iterate through the array
            rightMax[i] = max(rightMax[i + 1], height[i]);  // calculate the right max value
        }
        for(int i = 0; i < n; i++){  // iterate through the array
            result += min(leftMax[i], rightMax[i]) - height[i];  // calculate the result
        }
        return result;  // return the result
    }
};



3rd Method using two pointers



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)



class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();  // variable to store the length of the array
        int left = 0, right = n - 1;  // variables to store the left and right pointers
        int leftMax = 0, rightMax = 0;  // variables to store the left and right max values
        int result = 0;  // variable to store the result
        while(left <= right){  // iterate through the array
            if(height[left] <= height[right]){  // if the left value is less than or equal to the right value
                if(height[left] >= leftMax){  // if the left value is greater than or equal to the left max value
                    leftMax = height[left];  // update the left max value
                }
                else{  // if the left value is less than the left max value
                    result += leftMax - height[left];  // calculate the result
                }
                left++;  // increment the left pointer
            }
            else{  // if the right value is less than the left value
                if(height[right] >= rightMax){  // if the right value is greater than or equal to the right max value
                    rightMax = height[right];  // update the right max value
                }
                else{  // if the right value is less than the right max value
                    result += rightMax - height[right];  // calculate the result
                }
                right--;  // decrement the right pointer
            }
        }
        return result;  // return the result
    }
};



4th Method using stack



// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)



class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();  // variable to store the length of the array
        stack<int> st;  // stack to store the indices
        int result = 0;  // variable to store the result
        for(int i = 0; i < n; i++){  // iterate through the array
            while(!st.empty() && height[i] > height[st.top()]){  // if the stack is not empty and the current value is greater than the top value of the stack
                int top = st.top();  // variable to store the top value of the stack
                st.pop();  // pop the top value of the stack
                if(st.empty()){  // if the stack is empty
                    break;  // break
                }
                int distance = i - st.top() - 1;  // variable to store the distance
                int boundedHeight = min(height[i], height[st.top()]) - height[top];  // variable to store the bounded height
                result += distance * boundedHeight;  // calculate the result
            }
            st.push(i);  // push the current index to the stack
        }
        return result;  // return the result
    }
};





42. Trapping Rain Water in java using brute force 



// Time Complexity : O(n^2) where n is the length of the array and space complexity is O(1)



class Solution {

    public int trap(int[] height) {

        int n = height.length;  // variable to store the length of the array

        int result = 0;  // variable to store the result

        for(int i = 1; i < n - 1; i++){  // iterate through the array

            int leftMax = 0;  // variable to store the left max value

            int rightMax = 0;  // variable to store the right max value

            for(int j = i; j >= 0; j--){  // iterate through the array from the current index to the left

                leftMax = Math.max(leftMax, height[j]);  // calculate the left max value

            }

            for(int j = i; j < n; j++){  // iterate through the array from the current index to the right

                rightMax = Math.max(rightMax, height[j]);  // calculate the right max value

            }

            result += Math.min(leftMax, rightMax) - height[i];  // calculate the result

        }

        return result;  // return the result

    }

}



42. Trapping Rain Water in java using Dp



// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)



class Solution {
    public int trap(int[] height) {
        int n = height.length;  // variable to store the length of the array
        int[] leftMax = new int[n];  // array to store the left max values
        int[] rightMax = new int[n];  // array to store the right max values
        int result = 0;  // variable to store the result
        leftMax[0] = height[0];  // update the left max value
        for(int i = 1; i < n; i++){  // iterate through the array
            leftMax[i] = Math.max(leftMax[i - 1], height[i]);  // calculate the left max value
        }
        rightMax[n - 1] = height[n - 1];  // update the right max value
        for(int i = n - 2; i >= 0; i--){  // iterate through the array
            rightMax[i] = Math.max(rightMax[i + 1], height[i]);  // calculate the right max value
        }
        for(int i = 0; i < n; i++){  // iterate through the array
            result += Math.min(leftMax[i], rightMax[i]) - height[i];  // calculate the result
        }
        return result;  // return the result
    }
}





42. Trapping Rain Water in java using two pointers



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)





class Solution {
    public int trap(int[] height) {
        int n = height.length;  // variable to store the length of the array
        int left = 0, right = n - 1;  // variables to store the left and right pointers
        int leftMax = 0, rightMax = 0;  // variables to store the left and right max values
        int result = 0;  // variable to store the result
        while(left <= right){  // iterate through the array
            if(height[left] <= height[right]){  // if the left value is less than or equal to the right value
                if(height[left] >= leftMax){  // if the left value is greater than or equal to the left max value
                    leftMax = height[left];  // update the left max value
                }
                else{  // if the left value is less than the left max value
                    result += leftMax - height[left];  // calculate the result
                }
                left++;  // increment the left pointer
            }
            else{  // if the right value is less than the left value
                if(height[right] >= rightMax){  // if the right value is greater than or equal to the right max value
                    rightMax = height[right];  // update the right max value
                }
                else{  // if the right value is less than the right max value
                    result += rightMax - height[right];  // calculate the result
                }
                right--;  // decrement the right pointer
            }
        }
        return result;  // return the result
    }
}





42. Trapping Rain Water in java using stack



// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)



class Solution {
    public int trap(int[] height) {
        int n = height.length;  // variable to store the length of the array
        Stack<Integer> st = new Stack<>();  // stack to store the indices
        int result = 0;  // variable to store the result
        for(int i = 0; i < n; i++){  // iterate through the array
            while(!st.isEmpty() && height[i] > height[st.peek()]){  // if the stack is not empty and the current value is greater than the top value of the stack
                int top = st.pop();  // variable to store the top value of the stack
                if(st.isEmpty()){  // if the stack is empty
                    break;  // break
                }
                int distance = i - st.peek() - 1;  // variable to store the distance
                int boundedHeight = Math.min(height[i], height[st.peek()]) - height[top];  // variable to store the bounded height
                result += distance * boundedHeight;  // calculate the result
            }
            st.push(i);  // push the current index to the stack
        }
        return result;  // return the result
    }
}







44. Wildcard Matching in c++



// Time Complexity : O(m * n) where m is the length of the string and n is the length of the pattern and space complexity is O(m * n)



class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.length();  // variable to store the length of the string
        int n = p.length();  // variable to store the length of the pattern
        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));  // 2d vector to store the dp values
        dp[0][0] = true;  // update the dp value
        for(int i = 1; i <= n; i++){  // iterate through the pattern
            if(p[i - 1] == '*'){  // if the current character is '*'
                dp[0][i] = dp[0][i - 1];  // update the dp value
            }
        }
        for(int i = 1; i <= m; i++){  // iterate through the string
            for(int j = 1; j <= n; j++){  // iterate through the pattern
                if(p[j - 1] == '*'){  // if the current character is '*'
                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];  // update the dp value
                }
                else if(p[j - 1] == '?' || s[i - 1] == p[j - 1]){  // if the current character is '?' or the current character of the string is equal to the current character of the pattern
                    dp[i][j] = dp[i - 1][j - 1];  // update the dp value
                }
            }
        }
        return dp[m][n];  // return the dp value
    }
};



44. Wildcard Matching in java



// Time Complexity : O(m * n) where m is the length of the string and n is the length of the pattern and space complexity is O(m * n)





class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length();  // variable to store the length of the string
        int n = p.length();  // variable to store the length of the pattern
        boolean[][] dp = new boolean[m + 1][n + 1];  // 2d array to store the dp values
        dp[0][0] = true;  // update the dp value
        for(int i = 1; i <= n; i++){  // iterate through the pattern
            if(p.charAt(i - 1) == '*'){  // if the current character is '*'
                dp[0][i] = dp[0][i - 1];  // update the dp value
            }
        }
        for(int i = 1; i <= m; i++){  // iterate through the string
            for(int j = 1; j <= n; j++){  // iterate through the pattern
                if(p.charAt(j - 1) == '*'){  // if the current character is '*'
                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];  // update the dp value
                }
                else if(p.charAt(j - 1) == '?' || s.charAt(i - 1) == p.charAt(j - 1)){  // if the current character is '?' or the current character of the string is equal to the current character of the pattern
                    dp[i][j] = dp[i - 1][j - 1];  // update the dp value
                }
            }
        }
        return dp[m][n];  // return the dp value
    }
}


53. Maximum Subarray in c++



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)



class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();  // variable to store the length of the array
        int result = nums[0];  // variable to store the result
        int sum = nums[0];  // variable to store the sum
        for(int i = 1; i < n; i++){  // iterate through the array
            sum = max(nums[i], sum + nums[i]);  // update the sum
            result = max(result, sum);  // update the result
        }
        return result;  // return the result
    }
};


2nd Method using dp



// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)



class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();  // variable to store the length of the array
        vector<int> dp(n);  // vector to store the dp values
        dp[0] = nums[0];  // update the dp value
        int result = dp[0];  // variable to store the result
        for(int i = 1; i < n; i++){  // iterate through the array
            dp[i] = max(nums[i], dp[i - 1] + nums[i]);  // update the dp value
            result = max(result, dp[i]);  // update the result
        }
        return result;  // return the result
    }
};



53. Maximum Subarray in java



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)





class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;  // variable to store the length of the array
        int result = nums[0];  // variable to store the result
        int sum = nums[0];  // variable to store the sum
        for(int i = 1; i < n; i++){  // iterate through the array
            sum = Math.max(nums[i], sum + nums[i]);  // update the sum
            result = Math.max(result, sum);  // update the result
        }
        return result;  // return the result
    }
};



2nd Method using dp



// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)





class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;  // variable to store the length of the array
        int[] dp = new int[n];  // array to store the dp values
        dp[0] = nums[0];  // update the dp value
        int result = dp[0];  // variable to store the result
        for(int i = 1; i < n; i++){  // iterate through the array
            dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);  // update the dp value
            result = Math.max(result, dp[i]);  // update the result
        }
        return result;  // return the result
    }

}



62. Unique Paths in c++



// Time Complexity : O(m * n) where m is the number of rows and n is the number of columns and space complexity is O(m * n)





class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n));  // 2d vector to store the dp values
        for(int i = 0; i < m; i++){  // iterate through the rows
            dp[i][0] = 1;  // update the dp value
        }
        for(int i = 0; i < n; i++){  // iterate through the columns
            dp[0][i] = 1;  // update the dp value
        }
        for(int i = 1; i < m; i++){  // iterate through the rows
            for(int j = 1; j < n; j++){  // iterate through the columns
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];  // update the dp value
            }
        }
        return dp[m - 1][n - 1];  // return the dp value
    }
};


2nd Method 


class Solution {
public:
    int dp[101][101]{};
    int uniquePaths(int m, int n, int i = 0, int j = 0) {
        if(i >= m || j >= n) return 0;
        if(i == m-1 && j == n-1) return 1;
        if(dp[i][j]) return dp[i][j];
        return dp[i][j] = uniquePaths(m, n, i+1, j) + uniquePaths(m, n, i, j+1);
    }
};





62. Unique Paths in java



// Time Complexity : O(m * n) where m is the number of rows and n is the number of columns and space complexity is O(m * n)





class Solution {
    public int uniquePaths(int m, int n
        int[][] dp = new int[m][n];  // 2d array to store the dp values
        for(int i = 0; i < m; i++){  // iterate through the rows
            dp[i][0] = 1;  // update the dp value
        }
        for(int i = 0; i < n; i++){  // iterate through the columns
            dp[0][i] = 1;  // update the dp value
        }
        for(int i = 1; i < m; i++){  // iterate through the rows
            for(int j = 1; j < n; j++){  // iterate through the columns
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];  // update the dp value
            }
        }
        return dp[m - 1][n - 1];  // return the dp value
    }
}



63. Unique Paths II in c++



// Time Complexity : O(m * n) where m is the number of rows and n is the number of columns and space complexity is O(m * n)





class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();  // variable to store the number of rows
        int n = obstacleGrid[0].size();  // variable to store the number of columns
        vector<vector<int>> dp(m, vector<int>(n));  // 2d vector to store the dp values
        for(int i = 0; i < m; i++){  // iterate through the rows
            if(obstacleGrid[i][0] == 1) break;  // break if the obstacle is found
            dp[i][0] = 1;  // update the dp value
        }
        for(int i = 0; i < n; i++){  // iterate through the columns
            if(obstacleGrid[0][i] == 1) break;  // break if the obstacle is found
            dp[0][i] = 1;  // update the dp value
        }
        for(int i = 1; i < m; i++){  // iterate through the rows
            for(int j = 1; j < n; j++){  // iterate through the columns
                if(obstacleGrid[i][j] == 1) continue;  // continue if the obstacle is found
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];  // update the dp value
            }
        }
        return dp[m - 1][n - 1];  // return the dp value
    }
};

2nd Method 


class Solution {
public:
    int dp[101][101]{};
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid, int i = 0, int j = 0) {
        if(i >= obstacleGrid.size() || j >= obstacleGrid[0].size()) return 0;
        if(obstacleGrid[i][j]) return 0;
        if(i == obstacleGrid.size()-1 && j == obstacleGrid[0].size()-1) return 1;
        if(dp[i][j]) return dp[i][j];
        return dp[i][j] = uniquePathsWithObstacles(obstacleGrid, i+1, j) + uniquePathsWithObstacles(obstacleGrid, i, j+1);
    }
};





63. Unique Paths II in java



// Time Complexity : O(m * n) where m is the number of rows and n is the number of columns and space complexity is O(m * n)





class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;  // variable to store the number of rows
        int n = obstacleGrid[0].length;  // variable to store the number of columns
        int[][] dp = new int[m][n];  // 2d array to store the dp values
        for(int i = 0; i < m; i++){  // iterate through the rows
            if(obstacleGrid[i][0] == 1) break;  // break if the obstacle is found
            dp[i][0] = 1;  // update the dp value
        }
        for(int i = 0; i < n; i++){  // iterate through the columns
            if(obstacleGrid[0][i] == 1) break;  // break if the obstacle is found
            dp[0][i] = 1;  // update the dp value
        }
        for(int i = 1; i < m; i++){  // iterate through the rows
            for(int j = 1; j < n; j++){  // iterate through the columns
                if(obstacleGrid[i][j] == 1) continue;  // continue if the obstacle is found
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];  // update the dp value
            }
        }
        return dp[m - 1][n - 1];  // return the dp value
    }
}





142. Linked List Cycle II in c++



// Time Complexity : O(n) where n is the number of nodes in the linked list and space complexity is O(1)





class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *slow = head;  // slow pointer
        ListNode *fast = head;  // fast pointer
        while(fast != NULL && fast -> next != NULL){  // iterate until the fast pointer reaches the end
            slow = slow -> next;  // update the slow pointer
            fast = fast -> next -> next;  // update the fast pointer
            if(slow == fast){  // if the slow and fast pointers meet
                slow = head;  // update the slow pointer
                while(slow != fast){  // iterate until the slow and fast pointers meet
                    slow = slow -> next;  // update the slow pointer
                    fast = fast -> next;  // update the fast pointer
                }
                return slow;  // return the slow pointer
            }
        }
        return NULL;  // return NULL
    }
};





15. 3Sum





// Time Complexity : O(n^2) where n is the length of the array and space complexity is O(1)







class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n = nums.size();  // variable to store the length of the array
        vector<vector<int>> result;  // vector to store the result
        sort(nums.begin(), nums.end());  // sort the array
        for(int i = 0; i < n; i++){  // iterate through the array
            if(i > 0 && nums[i] == nums[i - 1]) continue;  // continue if the current value is equal to the previous value
            int left = i + 1;  // variable to store the left pointer
            int right = n - 1;  // variable to store the right pointer
            while(left < right){  // iterate until the left pointer is less than the right pointer
                int sum = nums[i] + nums[left] + nums[right];  // variable to store the sum
                if(sum == 0){  // if the sum is equal to 0
                    result.push_back({nums[i], nums[left], nums[right]});  // push the values to the result
                    left++;  // increment the left pointer
                    right--;  // decrement the right pointer
                    while(left < right && nums[left] == nums[left - 1]) left++;  // increment the left pointer until the current value is equal to the previous value
                    while(left < right && nums[right] == nums[right + 1]) right--;  // decrement the right pointer until the current value is equal to the previous value
                }
                else if(sum < 0){  // if the sum is less than 0
                    left++;  // increment the left pointer
                }
                else{  // if the sum is greater than 0
                    right--;  // decrement the right pointer
                }
            }
        }
        return result;  // return the result
    }
};





15. 3Sum in java





// Time Complexity : O(n^2) where n is the length of the array and space complexity is O(1)







class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int n = nums.length;  // variable to store the length of the array
        List<List<Integer>> result = new ArrayList<>();  // list to store the result
        Arrays.sort(nums);  // sort the array
        for(int i = 0; i < n; i++){  // iterate through the array
            if(i > 0 && nums[i] == nums[i - 1]) continue;  // continue if the current value is equal to the previous value
            int left = i + 1;  // variable to store the left pointer
            int right = n - 1;  // variable to store the right pointer
            while(left < right){  // iterate until the left pointer is less than the right pointer
                int sum = nums[i] + nums[left] + nums[right];  // variable to store the sum
                if(sum == 0){  // if the sum is equal to 0
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));  // add the values to the result
                    left++;  // increment the left pointer
                    right--;  // decrement the right pointer
                    while(left < right && nums[left] == nums[left - 1]) left++;  // increment the left pointer until the current value is equal to the previous value
                    while(left < right && nums[right] == nums[right + 1]) right--;  // decrement the right pointer until the current value is equal to the previous value
                }
                else if(sum < 0){  // if the sum is less than 0
                    left++;  // increment the left pointer
                }
                else{  // if the sum is greater than 0
                    right--;  // decrement the right pointer
                }
            }
        }
        return result;  // return the result
    }
}
















16. 3Sum Closest





// Time Complexity : O(n^2) where n is the length of the array and space complexity is O(1)








class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        int n = nums.size();  // variable to store the length of the array
        int result = nums[0] + nums[1] + nums[2];  // variable to store the result
        sort(nums.begin(), nums.end());  // sort the array
        for(int i = 0; i < n; i++){  // iterate through the array
            int left = i + 1;  // variable to store the left pointer
            int right = n - 1;  // variable to store the right pointer
            while(left < right){  // iterate until the left pointer is less than the right pointer
                int sum = nums[i] + nums[left] + nums[right];  // variable to store the sum
                if(sum == target){  // if the sum is equal to the target
                    return sum;  // return the sum
                }
                else if(sum < target){  // if the sum is less than the target
                    left++;  // increment the left pointer
                }
                else{  // if the sum is greater than the target
                    right--;  // decrement the right pointer
                }
                if(abs(sum - target) < abs(result - target)){  // if the absolute difference between the sum and the target is less than the absolute difference between the result and the target
                    result = sum;  // update the result
                }
            }
        }
        return result;  // return the result
    }
};







16. 3Sum Closest in java





// Time Complexity : O(n^2) where n is the length of the array and space complexity is O(1)







class Solution {
    public int threeSumClosest(int[] nums, int target) {
        int n = nums.length;  // variable to store the length of the array
        int result = nums[0] + nums[1] + nums[2];  // variable to store the result
        Arrays.sort(nums);  // sort the array
        for(int i = 0; i < n; i++){  // iterate through the array
            int left = i + 1;  // variable to store the left pointer
            int right = n - 1;  // variable to store the right pointer
            while(left < right){  // iterate until the left pointer is less than the right pointer
                int sum = nums[i] + nums[left] + nums[right];  // variable to store the sum
                if(sum == target){  // if the sum is equal to the target
                    return sum;  // return the sum
                }
                else if(sum < target){  // if the sum is less than the target
                    left++;  // increment the left pointer
                }
                else{  // if the sum is greater than the target
                    right--;  // decrement the right pointer
                }
                if(Math.abs(sum - target) < Math.abs(result - target)){  // if the absolute difference between the sum and the target is less than the absolute difference between the result and the target
                    result = sum;  // update the result
                }
            }
        }
        return result;  // return the result
    }
}










17. Letter Combinations of a Phone Number





// Time Complexity : O(4^n) where n is the length of the string and space complexity is O(n)







class Solution {
public:
    vector<string> letterCombinations(string digits) {
        vector<string> result;  // vector to store the result
        if(digits.length() == 0) return result;  // return the result if the length of the string is 0
        vector<string> mapping = {"0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};  // vector to store the mapping
        result.push_back("");  // push the empty string to the result
        for(int i = 0; i < digits.length(); i++){  // iterate through the string
            vector<string> temp;  // vector to store the temporary result
            string chars = mapping[digits[i] - '0'];  // variable to store the characters
            for(int j = 0; j < chars.length(); j++){  // iterate through the characters
                for(int k = 0; k < result.size(); k++){  // iterate through the result
                    temp.push_back(result[k] + chars[j]);  // push the characters to the temporary result
                }
            }
            result = temp;  // update the result
        }
        return result;  // return the result
    }
};







17. Letter Combinations of a Phone Number in java





// Time Complexity : O(4^n) where n is the length of the string and space complexity is O(n)







class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> result = new ArrayList<>();  // list to store the result
        if(digits.length() == 0) return result;  // return the result if the length of the string is 0
        String[] mapping = {"0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv","wxyz"};  // array to store the mapping
        result.add("");  // add the empty string to the result
        for(int i = 0; i < digits.length(); i++){  // iterate through the string
            List<String> temp = new ArrayList<>();  // list to store the temporary result
            String chars = mapping[digits.charAt(i) - '0'];  // variable to store the characters
            for(int j = 0; j < chars.length(); j++){  // iterate through the characters
                for(int k = 0; k < result.size(); k++){  // iterate through the result
                    temp.add(result.get(k) + chars.charAt(j));  // add the characters to the temporary result
                }
            }
            result = temp;  // update the result
        }
        return result;  // return the result
    }
}







18. 4Sum



// Time Complexity : O(n^3) where n is the length of the vector nums and space complexity is O(1)




class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        int n = nums.size();  // variable to store the length of the vector nums
        vector<vector<int>> result;  // vector to store the result
        if(n < 4) return result;  // return the result if the length of the vector nums is less than 4
        sort(nums.begin(), nums.end());  // sort the vector nums
        for(int i = 0; i < n - 3; i++){  // iterate through the vector nums
            if(i > 0 && nums[i] == nums[i - 1]) continue;  // continue if the current value is equal to the previous value
            for(int j = i + 1; j < n - 2; j++){  // iterate through the vector nums
                if(j > i + 1 && nums[j] == nums[j - 1]) continue;  // continue if the current value is equal to the previous value
                int left = j + 1;  // variable to store the left pointer
                int right = n - 1;  // variable to store the right pointer
                while(left < right){  // iterate until the left pointer is less than the right pointer
                   long long sum = static_cast<long long>(nums[i]) + nums[j] + nums[left] + nums[right];  // variable to store the sum
                    if(sum == target){  // if the sum is equal to the target
                        result.push_back({nums[i], nums[j], nums[left], nums[right]});  // push the values to the result
                        left++;  // increment the left pointer
                        right--;  // decrement the right pointer
                        while(left < right && nums[left] == nums[left - 1]) left++;  // increment the left pointer until the current value is equal to the previous value
                        while(left < right && nums[right] == nums[right + 1]) right--;  // decrement the right pointer until the current value is equal to the previous value
                    }
                    else if(sum < target){  // if the sum is less than the target
                        left++;  // increment the left pointer
                    }
                    else{  // if the sum is greater than the target
                        right--;  // decrement the right pointer
                    }
                }
            }
        }
        return result;  // return the result
    }
};







18. 4Sum in java



// Time Complexity : O(n^3) where n is the length of the vector nums and space complexity is O(1)




class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        int n = nums.length;  // variable to store the length of the vector nums
        List<List<Integer>> result = new ArrayList<>();  // list to store the result
        if(n < 4) return result;  // return the result if the length of the vector nums is less than 4
        Arrays.sort(nums);  // sort the vector nums
        for(int i = 0; i < n - 3; i++){  // iterate through the vector nums
            if(i > 0 && nums[i] == nums[i - 1]) continue;  // continue if the current value is equal to the previous value
            for(int j = i + 1; j < n - 2; j++){  // iterate through the vector nums
                if(j > i + 1 && nums[j] == nums[j - 1]) continue;  // continue if the current value is equal to the previous value
                int left = j + 1;  // variable to store the left pointer
                int right = n - 1;  // variable to store the right pointer
                while(left < right){  // iterate until the left pointer is less than the right pointer
                   long  sum = (long)nums[i] + nums[j] + nums[left] + nums[right];  // variable to store the sum
                    if(sum == target){  // if the sum is equal to the target
                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));  // add the values to the result
                        left++;  // increment the left pointer
                        right--;  // decrement the right pointer
                        while(left < right && nums[left] == nums[left - 1]) left++;  // increment the left pointer until the current value is equal to the previous value
                        while(left < right && nums[right] == nums[right + 1]) right--;  // decrement the right pointer until the current value is equal to the previous value
                    }
                    else if(sum < target){  // if the sum is less than the target
                        left++;  // increment the left pointer
                    }
                    else{  // if the sum is greater than the target
                        right--;  // decrement the right pointer
                    }
                }
            }
        }
        return result;  // return the result
    }
}




19. Remove Nth Node From End of List





// Time Complexity : O(n) where n is the number of nodes in the linked list and space complexity is O(1)







class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *dummy = new ListNode();  // dummy node
        dummy -> next = head;  // update the next pointer of the dummy node
        ListNode *slow = dummy;  // slow pointer
        ListNode *fast = dummy;  // fast pointer
        for(int i = 0; i <= n; i++){  // iterate until the fast pointer reaches the nth node
            fast = fast -> next;  // update the fast pointer
        }
        while(fast != NULL){  // iterate until the fast pointer reaches the end
            slow = slow -> next;  // update the slow pointer
            fast = fast -> next;  // update the fast pointer
        }
        slow -> next = slow -> next -> next;  // update the next pointer of the slow pointer
        return dummy -> next;  // return the next pointer of the dummy node
    }
};







19. Remove Nth Node From End of List in java





// Time Complexity : O(n) where n is the number of nodes in the linked list and space complexity is O(1)







class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode();  // dummy node
        dummy.next = head;  // update the next pointer of the dummy node
        ListNode slow = dummy;  // slow pointer
        ListNode fast = dummy;  // fast pointer
        for(int i = 0; i <= n; i++){  // iterate until the fast pointer reaches the nth node
            fast = fast.next;  // update the fast pointer
        }
        while(fast != null){  // iterate until the fast pointer reaches the end
            slow = slow.next;  // update the slow pointer
            fast = fast.next;  // update the fast pointer
        }
        slow.next = slow.next.next;  // update the next pointer of the slow pointer
        return dummy.next;  // return the next pointer of the dummy node
    }
}








20. Valid Parentheses





// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)







class Solution {
public:
    bool isValid(string s) {
        stack<char> st;  // stack to store the characters
        for(int i = 0; i < s.length(); i++){  // iterate through the string
            if(s[i] == '(' || s[i] == '{' || s[i] == '['){  // if the current character is '(' or '{' or '['
                st.push(s[i]);  // push the character to the stack
            }
            else if(s[i] == ')' && !st.empty() && st.top() == '('){  // if the current character is ')' and the stack is not empty and the top of the stack is '('
                st.pop();  // pop the top of the stack
            }
            else if(s[i] == '}' && !st.empty() && st.top() == '{'){  // if the current character is '}' and the stack is not empty and the top of the stack is '{'
                st.pop();  // pop the top of the stack
            }
            else if(s[i] == ']' && !st.empty() && st.top() == '['){  // if the current character is ']' and the stack is not empty and the top of the stack is '['
                st.pop();  // pop the top of the stack
            }
            else{  // if the current character is not '(' or '{' or '[' or ')' or '}' or ']'
                return false;  // return false
            }
        }
        return st.empty();  // return true if the stack is empty else return false
    }
}







20. Valid Parentheses in java






// Time Complexity : O(n) where n is the length of the string and space complexity is O(n)









class Solution {
    public boolean isValid(String s) {
        Stack<Character> st = new Stack<>();  // stack to store the characters
        for(int i = 0; i < s.length(); i++){  // iterate through the string
            if(s.charAt(i) == '(' || s.charAt(i) == '{' || s.charAt(i) == '['){  // if the current character is '(' or '{' or '['
                st.push(s.charAt(i));  // push the character to the stack
            }
            else if(s.charAt(i) == ')' && !st.empty() && st.peek() == '('){  // if the current character is ')' and the stack is not empty and the top of the stack is '('
                st.pop();  // pop the top of the stack
            }
            else if(s.charAt(i) == '}' && !st.empty() && st.peek() == '{'){  // if the current character is '}' and the stack is not empty and the top of the stack is '{'
                st.pop();  // pop the top of the stack
            }
            else if(s.charAt(i) == ']' && !st.empty() && st.peek() == '['){  // if the current character is ']' and the stack is not empty and the top of the stack is '['
                st.pop();  // pop the top of the stack
            }
            else{  // if the current character is not '(' or '{' or '[' or ')' or '}' or ']'
                return false;  // return false
            }
        }
        return st.empty();  // return true if the stack is empty else return false
    }
}










24. Swap Nodes in Pairs






// Time Complexity : O(n) where n is the number of nodes in the linked list and space complexity is O(1)







class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode *dummy = new ListNode();  // dummy node
        dummy -> next = head;  // update the next pointer of the dummy node
        ListNode *prev = dummy;  // variable to store the previous node
        while(head != NULL && head -> next != NULL){  // iterate until the head reaches the end
            ListNode *first = head;  // variable to store the first node
            ListNode *second = head -> next;  // variable to store the second node
            prev -> next = second;  // update the next pointer of the previous node
            first -> next = second -> next;  // update the next pointer of the first node
            second -> next = first;  // update the next pointer of the second node
            prev = first;  // update the previous node
            head = first -> next;  // update the head
        }
        return dummy -> next;  // return the next pointer of the dummy node
    }
};








24. Swap Nodes in Pairs in java






// Time Complexity : O(n) where n is the number of nodes in the linked list and space complexity is O(1)







class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode();  // dummy node
        dummy.next = head;  // update the next pointer of the dummy node
        ListNode prev = dummy;  // variable to store the previous node
        while(head != null && head.next != null){  // iterate until the head reaches the end
            ListNode first = head;  // variable to store the first node
            ListNode second = head.next;  // variable to store the second node
            prev.next = second;  // update the next pointer of the previous node
            first.next = second.next;  // update the next pointer of the first node
            second.next = first;  // update the next pointer of the second node
            prev = first;  // update the previous node
            head = first.next;  // update the head
        }
        return dummy.next;  // return the next pointer of the dummy node
    }
}





25. Reverse Nodes in k-Group


Both methods are valid approaches to solve the "Reverse Nodes in k-Group" problem, and the choice between them depends on personal preference and coding style. Let's discuss the two methods:

First Method:

This method uses recursion to reverse the linked list in groups of size k.
It counts the number of nodes in the current group and checks if it's less than k. If so, it returns the head as is.
It recursively reverses the remaining groups by calling reverseKGroup on the next group of nodes.
The reversal of the current group is done using iterative swapping of nodes.
Overall, this method follows a top-down recursive approach.
Second Method:

This method uses an iterative approach to reverse the linked list in groups of size k.
It uses a dummy node and a prev pointer to keep track of the previous node.
It iterates through the list until the end, processing groups of k nodes at a time.
Within each group, it identifies the tail node and the next node after the group.
It calls a separate reverse function to reverse the group of nodes between head and tail.
The prev and head pointers are updated accordingly, and the process continues until the end of the list.
Overall, this method follows a bottom-up iterative approach.
Both methods achieve the same result of reversing the nodes in groups of size k. The first method utilizes recursion, which may provide a clearer and more concise implementation. On the other hand, the second method uses an iterative approach, which can be advantageous for cases where recursion is not preferred or may lead to stack overflow issues with large input sizes.

Ultimately, the choice between the two methods depends on personal preference, coding style, and the specific requirements of the problem at hand.



First Method:

Time Complexity: The time complexity of this method is O(n), where n is the total number of nodes in the linked list. This is because the method traverses each node in the linked list once in order to reverse the groups of size k.
Space Complexity: The space complexity of this method is O(k), where k is the size of the groups to be reversed. This is due to the recursive calls made to reverse each group. The space used by the recursive stack is proportional to the number of recursive calls, which is determined by k.
Second Method:

Time Complexity: The time complexity of this method is O(n), where n is the total number of nodes in the linked list. This is because the method iterates through each node in the linked list once to perform the necessary swaps and reversals.
Space Complexity: The space complexity of this method is O(1) since it uses a constant amount of extra space. It only requires a few additional pointers and variables to perform the swaps and reversals, regardless of the size of the input.
In terms of time complexity, both methods have the same efficiency, traversing each node once. However, the second method has a better space complexity as it uses a constant amount of extra space, whereas the first method's space complexity depends on the group size k.

Therefore, if memory usage is a concern and the group size is small, the second method may be more preferable. On the other hand, if a recursive approach is preferred or the group size is large, the first method can still be a valid choice.




// Time Complexity : O(n) where n is the number of nodes in the linked list and space complexity is O(K)


// Recursive Approach

1st Method 


class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* curr = head;
        int count = 0;

        // Count the number of nodes in the current group
        while (curr != nullptr && count < k) {
            curr = curr->next;
            count++;
        }

        // If the number of nodes is less than k, return the head
        if (count < k) {
            return head;
        }

        // Reverse the current group
        curr = reverseKGroup(curr, k);
        while (count > 0) {
            ListNode* nextNode = head->next;
            head->next = curr;
            curr = head;
            head = nextNode;
            count--;
        }

        return curr;
    }
};



2nd Method 


// Iterative Approach




// Time Complexity : O(n) where n is the number of nodes in the linked list and space complexity is O(1)



class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode *dummy = new ListNode();  // dummy node
        dummy -> next = head;  // update the next pointer of the dummy node
        ListNode *prev = dummy;  // variable to store the previous node
        while(head != NULL){  // iterate until the head reaches the end
            ListNode *tail = prev;  // variable to store the tail node
            for(int i = 0; i < k; i++){  // iterate k times
                tail = tail -> next;  // update the tail node
                if(tail == NULL) return dummy -> next;  // return the next pointer of the dummy node if the tail node reaches the end
            }
            ListNode *next = tail -> next;  // variable to store the next node
            reverse(head, tail);  // call the reverse function
            prev -> next = tail;  // update the next pointer of the previous node
            head -> next = next;  // update the next pointer of the head node
            prev = head;  // update the previous node
            head = next;  // update the head
        }
        return dummy -> next;  // return the next pointer of the dummy node
    }
    void reverse(ListNode *head, ListNode *tail){  // function to reverse the linked list
        ListNode *prev = NULL;  // variable to store the previous node
        ListNode *curr = head;  // variable to store the current node
        while(curr != tail){  // iterate until the current node reaches the tail node
            ListNode *next = curr -> next;  // variable to store the next node
            curr -> next = prev;  // update the next pointer of the current node
            prev = curr;  // update the previous node
            curr = next;  // update the current node
        }
        curr -> next = prev;  // update the next pointer of the current node
    }
};




25. Reverse Nodes in k-Group in java




// Time Complexity : O(n) where n is the number of nodes in the linked list and space complexity is O(K)


// Recursive Approach



1st Method


class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode curr = head;
        int count = 0;

        // Count the number of nodes in the current group
        while (curr != null && count < k) {
            curr = curr.next;
            count++;
        }

        // If the number of nodes is less than k, return the head
        if (count < k) {
            return head;
        }

        // Reverse the current group
        curr = reverseKGroup(curr, k);
        while (count > 0) {
            ListNode nextNode = head.next;
            head.next = curr;
            curr = head;
            head = nextNode;
            count--;
        }

        return curr;
    }
}





2nd Method


// Iterative Approach




// Time Complexity : O(n) where n is the number of nodes in the linked list and space complexity is O(1)





class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode();  // dummy node
        dummy.next = head;  // update the next pointer of the dummy node
        ListNode prev = dummy;  // variable to store the previous node
        while(head != null){  // iterate until the head reaches the end
            ListNode tail = prev;  // variable to store the tail node
            for(int i = 0; i < k; i++){  // iterate k times
                tail = tail.next;  // update the tail node
                if(tail == null) return dummy.next;  // return the next pointer of the dummy node if the tail node reaches the end
            }
            ListNode next = tail.next;  // variable to store the next node
            reverse(head, tail);  // call the reverse function
            prev.next = tail;  // update the next pointer of the previous node
            head.next = next;  // update the next pointer of the head node
            prev = head;  // update the previous node
            head = next;  // update the head
        }
        return dummy.next;  // return the next pointer of the dummy node
    }
    void reverse(ListNode head, ListNode tail){  // function to reverse the linked list
        ListNode prev = null;  // variable to store the previous node
        ListNode curr = head;  // variable to store the current node
        while(curr != tail){  // iterate until the current node reaches the tail node
            ListNode next = curr.next;  // variable to store the next node
            curr.next = prev;  // update the next pointer of the current node
            prev = curr;  // update the previous node
            curr = next;  // update the current node
        }
        curr.next = prev;  // update the next pointer of the current node
    }
}





26. Remove Duplicates from Sorted Array





// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)







class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();  // variable to store the length of the vector nums
        if(n == 0) return 0;  // return 0 if the length of the vector nums is 0
        int i = 0;  // variable to store the index
        for(int j = 1; j < n; j++){  // iterate through the vector nums
            if(nums[j] != nums[i]){  // if the current value is not equal to the previous value
                i++;  // increment the index
                nums[i] = nums[j];  // update the value at the index
            }
        }
        return i + 1;  // return the length of the vector nums
    }
};







26. Remove Duplicates from Sorted Array in java





// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)







class Solution {
    public int removeDuplicates(int[] nums) {
        int n = nums.length;  // variable to store the length of the vector nums
        if(n == 0) return 0;  // return 0 if the length of the vector nums is 0
        int i = 0;  // variable to store the index
        for(int j = 1; j < n; j++){  // iterate through the vector nums
            if(nums[j] != nums[i]){  // if the current value is not equal to the previous value
                i++;  // increment the index
                nums[i] = nums[j];  // update the value at the index
            }
        }
        return i + 1;  // return the length of the vector nums
    }
}








27. Remove Element





// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)








class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int n = nums.size();  // variable to store the length of the vector nums
        int i = 0;  // variable to store the index
        for(int j = 0; j < n; j++){  // iterate through the vector nums
            if(nums[j] != val){  // if the current value is not equal to the target value
                nums[i] = nums[j];  // update the value at the index
                i++;  // increment the index
            }
        }
        return i;  // return the index
    }
};







27. Remove Element in java





// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)








class Solution {
    public int removeElement(int[] nums, int val) {
        int n = nums.length;  // variable to store the length of the vector nums
        int i = 0;  // variable to store the index
        for(int j = 0; j < n; j++){  // iterate through the vector nums
            if(nums[j] != val){  // if the current value is not equal to the target value
                nums[i] = nums[j];  // update the value at the index
                i++;  // increment the index
            }
        }
        return i;  // return the index
    }
}





29. Divide Two Integers





// Time Complexity : O(log n) where n is the absolute value of the dividend and space complexity is O(1)




// public:: This indicates the access specifier of the function. In this case, the divide function is declared as public, meaning it can be accessed from outside the class.

// int divide(int dividend, int divisor) { ... }: This is the definition of the divide function, which takes two integer arguments dividend and divisor and returns an integer as the result of the division.

// if(dividend==INT_MIN && divisor==-1) return INT_MAX;: This is a special case check to handle the scenario where dividing INT_MIN by -1 would result in integer overflow. In such a case, the function returns INT_MAX to represent positive infinity.

// long dvd=abs(dividend),dvs=abs(divisor),ans=0;: Here, three variables are declared and initialized:

// dvd: The absolute value of the dividend.
// dvs: The absolute value of the divisor.
// ans: The variable that will store the result of the division.
// int sign=dividend>0 ^ divisor>0 ? -1 : 1;: This line determines the sign of the result by performing bitwise XOR operations on the signs of the dividend and divisor. If the signs are different, the result will be negative, otherwise, it will be positive.

// while(dvd>=dvs) { ... }: This loop performs the main division calculation. It continues as long as the absolute value of the dividend (dvd) is greater than or equal to the absolute value of the divisor (dvs).

// long temp=dvs,m=1;: Two variables temp and m are declared and initialized. temp is used to store the current value of the divisor, and m is used to keep track of how many times the divisor is doubled during the division process.

// while(temp<<1 <= dvd) { ... }: This nested loop continues as long as doubling the temp (dvs) does not exceed or become greater than the current dvd value. It effectively finds the largest multiple of dvs that is less than or equal to dvd and stores it in temp.

// temp<<=1; m<<=1;: In this line, both temp and m are doubled by left-shifting them, effectively multiplying by 2.

// ans+=m; dvd-=temp;: The loop updates the ans variable by adding the value of m, which represents how many times the divisor was doubled during the division process. It also subtracts temp from dvd, effectively reducing the remaining value to be divided.

// return sign*ans;: Finally, the function returns the result of the division, which is calculated by multiplying ans with the sign variable to apply the correct sign (positive or negative) to the result.

// This implementation of the divide function ensures better accuracy and handles special cases like integer overflow when dividing INT_MIN by -1.





class Solution {
public:
    int divide(int dividend, int divisor) {
        if(dividend == INT_MIN && divisor == -1) return INT_MAX;
        int sign =  (dividend > 0) ^ (divisor > 0) ? -1 : 1;
        long dvd = abs(dividend) , dvs = abs(divisor) , ans = 0;
        while(dvd >= dvs){
            long temp = dvs , m = 1;
            while(temp<<1 <= dvd){
               temp<<=1;
               m<<=1;
            }
            ans += m;
            dvd -= temp;
        }
        return sign * ans;
    }
};



2nd Method 



class Solution {
public:
    int divide(int dividend, int divisor) {
        // Handle special cases
        if (divisor == 0) {
            // Division by zero is undefined, return a large value to represent infinity
            return INT_MAX;
        }

        if (dividend == INT_MIN && divisor == -1) {
            // Handling integer overflow when dividing INT_MIN by -1
            return INT_MAX;
        }

        // Determine the sign of the result
        int sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;

        // Convert both dividend and divisor to positive to simplify calculation
        long long absDividend = llabs(dividend);
        long long absDivisor = llabs(divisor);

        // Perform the division
        long long result = 0;
        while (absDividend >= absDivisor) {
            long long temp = absDivisor;
            long long quotient = 1;
            while (absDividend >= (temp << 1)) {
                temp <<= 1;
                quotient <<= 1;
            }
            absDividend -= temp;
            result += quotient;
        }

        // Apply the sign to the result
        result = sign * result;

        // Check for integer overflow and return the result
        if (result > INT_MAX || result < INT_MIN) {
            return INT_MAX;
        } else {
            return static_cast<int>(result);
        }
    }
};







29. Divide Two Integers in java






// Time Complexity : O(log n) where n is the absolute value of the dividend and space complexity is O(1)









class Solution {
    public int divide(int dividend, int divisor) {
        if(dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;
        int sign =  (dividend > 0) ^ (divisor > 0) ? -1 : 1;
        long dvd = Math.abs((long)dividend) , dvs = Math.abs((long)divisor) , ans = 0;
        while(dvd >= dvs){
            long temp = dvs , m = 1;
            while(temp<<1 <= dvd){
               temp<<=1;
               m<<=1;
            }
            ans += m;
            dvd -= temp;
        }
        return sign * (int)ans;
    }
}









30. Substring with Concatenation of All Words





// Time Complexity : O(n * m) where n is the length of the string s and m is the length of the vector words and space complexity is O(n + m)







class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        vector<int> result;
        if (s.empty() || words.empty()) return result;

        int wordLength = words[0].length();
        int totalWords = words.size();
        int totalLength = wordLength * totalWords;

        if (s.length() < totalLength) return result;

        unordered_map<string, int> wordFreq;

        // Count the frequency of each word in the 'words' array
        for (const string& word : words)
            wordFreq[word]++;

        for (int i = 0; i < wordLength; ++i) { // Start from each possible starting position for a word
            int left = i;
            int right = i;
            unordered_map<string, int> seenWords;

            while (right + wordLength <= s.length()) {
                string word = s.substr(right, wordLength);
                right += wordLength;

                if (wordFreq.find(word) == wordFreq.end()) {
                    seenWords.clear();
                    left = right;
                } else {
                    seenWords[word]++;
                    while (seenWords[word] > wordFreq[word]) {
                        string leftWord = s.substr(left, wordLength);
                        seenWords[leftWord]--;
                        left += wordLength;
                    }

                    if (right - left == totalLength)
                        result.push_back(left);
                }
            }
        }

        return result;
    }
};





30. Substring with Concatenation of All Words in java







// Time Complexity : O(n * m) where n is the length of the string s and m is the length of the vector words and space complexity is O(n + m)








class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        List<Integer> result = new ArrayList<>();
        if (s.isEmpty() || words.length == 0) return result;

        int wordLength = words[0].length();
        int totalWords = words.length;
        int totalLength = wordLength * totalWords;

        if (s.length() < totalLength) return result;

        Map<String, Integer> wordFreq = new HashMap<>();

        // Count the frequency of each word in the 'words' array
        for (String word : words)
            wordFreq.put(word, wordFreq.getOrDefault(word, 0) + 1);

        for (int i = 0; i < wordLength; ++i) { // Start from each possible starting position for a word
            int left = i;
            int right = i;
            Map<String, Integer> seenWords = new HashMap<>();

            while (right + wordLength <= s.length()) {
                String word = s.substring(right, right + wordLength);
                right += wordLength;

                if (!wordFreq.containsKey(word)) {
                    seenWords.clear();
                    left = right;
                } else {
                    seenWords.put(word, seenWords.getOrDefault(word, 0) + 1);
                    while (seenWords.get(word) > wordFreq.get(word)) {
                        String leftWord = s.substring(left, left + wordLength);
                        seenWords.put(leftWord, seenWords.get(leftWord) - 1);
                        left += wordLength;
                    }

                    if (right - left == totalLength)
                        result.add(left);
                }
            }
        }

        return result;
    }
}




31. Next Permutation





// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)







class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int n = nums.size();  // variable to store the length of the vector nums
        int i = n - 2;  // variable to store the index
        while(i >= 0 && nums[i] >= nums[i + 1]){  // iterate until the current value is greater than the next value
            i--;  // decrement the index
        }
        if(i >= 0){  // if the index is greater than or equal to 0
            int j = n - 1;  // variable to store the index
            while(j >= 0 && nums[j] <= nums[i]){  // iterate until the current value is less than the next value
                j--;  // decrement the index
            }
            swap(nums[i], nums[j]);  // swap the values
        }
        reverse(nums.begin() + i + 1, nums.end());  // reverse the vector nums
    }
};



2nd Method



class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        next_permutation(nums.begin() , nums.end());
    }
};







31. Next Permutation in java





// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)







class Solution {
    public void nextPermutation(int[] nums) {
        int n = nums.length;  // variable to store the length of the vector nums
        int i = n - 2;  // variable to store the index
        while(i >= 0 && nums[i] >= nums[i + 1]){  // iterate until the current value is greater than the next value
            i--;  // decrement the index
        }
        if(i >= 0){  // if the index is greater than or equal to 0
            int j = n - 1;  // variable to store the index
            while(j >= 0 && nums[j] <= nums[i]){  // iterate until the current value is less than the next value
                j--;  // decrement the index
            }
            swap(nums, i, j);  // swap the values
        }
        reverse(nums, i + 1, n - 1);  // reverse the vector nums
    }
    void swap(int[] nums, int i, int j){  // function to swap the values
        int temp = nums[i];  // variable to store the value
        nums[i] = nums[j];  // update the value
        nums[j] = temp;  // update the value
    }
    void reverse(int[] nums, int i, int j){  // function to reverse the vector nums
        while(i < j){  // iterate until the i is less than j
            swap(nums, i, j);  // swap the values
            i++;  // increment i
            j--;  // decrement j
        }
    }
}







33. Search in Rotated Sorted Array





// Time Complexity : O(log n) where n is the length of the vector nums and space complexity is O(1)







class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();  // variable to store the length of the vector nums
        int low = 0;  // variable to store the low index
        int high = n - 1;  // variable to store the high index
        while(low <= high){  // iterate until the low is less than or equal to high
            int mid = low + (high - low) / 2;  // variable to store the mid index
            if(nums[mid] == target) return mid;  // return the mid index if the current value is equal to the target value
            else if(nums[mid] >= nums[low]){  // if the current value is greater than or equal to the low value
                if(target >= nums[low] && target < nums[mid]){  // if the target value is greater than or equal to the low value and less than the mid value
                    high = mid - 1;  // update the high index
                }
                else{  // if the target value is less than the low value or greater than or equal to the mid value
                    low = mid + 1;  // update the low index
                }
            }
            else{  // if the current value is less than the low value
                if(target <= nums[high] && target > nums[mid]){  // if the target value is less than or equal to the high value and greater than the mid value
                    low = mid + 1;  // update the low index
                }
                else{  // if the target value is greater than the high value or less than or equal to the mid value
                    high = mid - 1;  // update the high index
                }
            }
        }
        return -1;  // return -1 if the target value is not found
    }
};      







33. Search in Rotated Sorted Array in java






// Time Complexity : O(log n) where n is the length of the vector nums and space complexity is O(1)







class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;  // variable to store the length of the vector nums
        int low = 0;  // variable to store the low index
        int high = n - 1;  // variable to store the high index
        while(low <= high){  // iterate until the low is less than or equal to high
            int mid = low + (high - low) / 2;  // variable to store the mid index
            if(nums[mid] == target) return mid;  // return the mid index if the current value is equal to the target value
            else if(nums[mid] >= nums[low]){  // if the current value is greater than or equal to the low value
                if(target >= nums[low] && target < nums[mid]){  // if the target value is greater than or equal to the low value and less than the mid value
                    high = mid - 1;  // update the high index
                }
                else{  // if the target value is less than the low value or greater than or equal to the mid value
                    low = mid + 1;  // update the low index
                }
            }
            else{  // if the current value is less than the low value
                if(target <= nums[high] && target > nums[mid]){  // if the target value is less than or equal to the high value and greater than the mid value
                    low = mid + 1;  // update the low index
                }
                else{  // if the target value is greater than the high value or less than or equal to the mid value
                    high = mid - 1;  // update the high index
                }
            }
        }
        return -1;  // return -1 if the target value is not found
    }
}











34. Find First and Last Position of Element in Sorted Array 







// Time Complexity : O(log n) where n is the length of the vector nums and space complexity is O(1)




class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int firstPosition = -1;
        int lastPosition = -1;
        int start = 0;
        int end = nums.size() - 1;

        // Binary search to find the first occurrence of the target element
        while (start <= end) {
            int mid = start + (end - start) / 2;

            if (nums[mid] == target) {
                firstPosition = mid;
                end = mid - 1; // Move left to find the first occurrence
            } else if (nums[mid] > target) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }

        // Reset start and end for the second binary search
        start = 0;
        end = nums.size() - 1;

        // Binary search to find the last occurrence of the target element
        while (start <= end) {
            int mid = start + (end - start) / 2;

            if (nums[mid] == target) {
                lastPosition = mid;
                start = mid + 1; // Move right to find the last occurrence
            } else if (nums[mid] > target) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }

        return {firstPosition, lastPosition};
    }
};







34. Find First and Last Position of Element in Sorted Array in java






// Time Complexity : O(log n) where n is the length of the vector nums and space complexity is O(1)







class Solution {
    public int[] searchRange(int[] nums, int target) {
        int firstPosition = -1;
        int lastPosition = -1;
        int start = 0;
        int end = nums.length - 1;

        // Binary search to find the first occurrence of the target element
        while (start <= end) {
            int mid = start + (end - start) / 2;

            if (nums[mid] == target) {
                firstPosition = mid;
                end = mid - 1; // Move left to find the first occurrence
            } else if (nums[mid] > target) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }

        // Reset start and end for the second binary search
        start = 0;
        end = nums.length - 1;

        // Binary search to find the last occurrence of the target element
        while (start <= end) {
            int mid = start + (end - start) / 2;

            if (nums[mid] == target) {
                lastPosition = mid;
                start = mid + 1; // Move right to find the last occurrence
            } else if (nums[mid] > target) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }

        return new int[]{firstPosition, lastPosition};
    }
}



36. Valid Sudoku





// Time Complexity : O(1) where n is the length of the vector nums and space complexity is O(1)







class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        vector<unordered_set<int>> row(9);  // vector to store the row values
        vector<unordered_set<int>> col(9);  // vector to store the column values
        vector<unordered_set<int>> box(9);  // vector to store the box values
        for(int i = 0; i < 9; i++){  // iterate through the board
            for(int j = 0; j < 9; j++){
                if(board[i][j] != '.'){  // if the current value is not equal to '.'
                    int num = board[i][j] - '0';  // variable to store the value
                    if(row[i].count(num) || col[j].count(num) || box[(i / 3) * 3 + j / 3].count(num)) return false;  // return false if the value is already present in the row, column or box
                    row[i].insert(num);  // insert the value in the row
                    col[j].insert(num);  // insert the value in the column
                    box[(i / 3) * 3 + j / 3].insert(num);  // insert the value in the box
                }
            }
        }
        return true;  // return true if the board is valid
    }
};







36. Valid Sudoku in java






// Time Complexity : O(1) where n is the length of the vector nums and space complexity is O(1)








class Solution {
    public boolean isValidSudoku(char[][] board) {
        Set<Integer>[] row = new HashSet[9];  // vector to store the row values
        Set<Integer>[] col = new HashSet[9];  // vector to store the column values
        Set<Integer>[] box = new HashSet[9];  // vector to store the box values
        for(int i = 0; i < 9; i++){  // iterate through the board
            row[i] = new HashSet<>();  // initialize the row
            col[i] = new HashSet<>();  // initialize the column
            box[i] = new HashSet<>();  // initialize the box
        }
        for(int i = 0; i < 9; i++){  // iterate through the board
            for(int j = 0; j < 9; j++){
                if(board[i][j] != '.'){  // if the current value is not equal to '.'
                    int num = board[i][j] - '0';  // variable to store the value
                    if(row[i].contains(num) || col[j].contains(num) || box[(i / 3) * 3 + j / 3].contains(num)) return false;  // return false if the value is already present in the row, column or box
                    row[i].add(num);  // insert the value in the row
                    col[j].add(num);  // insert the value in the column
                    box[(i / 3) * 3 + j / 3].add(num);  // insert the value in the box
                }
            }
        }
        return true;  // return true if the board is valid
    }
}





37. Sudoku Solver





// Time Complexity : O(1) where n is the length of the vector nums and space complexity is O(1)







class Solution {
public:
    void solveSudoku(vector<vector<char>>& board) {
        solve(board, 0, 0);  // call the solve function
    }
    bool solve(vector<vector<char>>& board, int row, int col){  // function to solve the sudoku
        if(row == 9) return true;  // return true if the row is equal to 9
        if(col == 9) return solve(board, row + 1, 0);  // return the solve function if the column is equal to 9
        if(board[row][col] != '.') return solve(board, row, col + 1);  // return the solve function if the current value is not equal to '.'
        for(char c = '1'; c <= '9'; c++){  // iterate through the numbers from 1 to 9
            if(isValid(board, row, col, c)){  // if the current value is valid
                board[row][col] = c;  // update the value
                if(solve(board, row, col + 1)) return true;  // return true if the solve function returns true
                board[row][col] = '.';  // update the value
            }
        }
        return false;  // return false
    }
    bool isValid(vector<vector<char>>& board, int row, int col, char c){  // function to check if the current value is valid
        for(int i = 0; i < 9; i++){  // iterate through the board
            if(board[row][i] == c) return false;  // return false if the current value is equal to c
            if(board[i][col] == c) return false;  // return false if the current value is equal to c
            if(board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false;  // return false if the current value is equal to c
        }
        return true;  // return true
    }
};








37. Sudoku Solver in java






// Time Complexity : O(1) where n is the length of the vector nums and space complexity is O(1)







class Solution {
    public void solveSudoku(char[][] board) {
        solve(board, 0, 0);  // call the solve function
    }
    boolean solve(char[][] board, int row, int col){  // function to solve the sudoku
        if(row == 9) return true;  // return true if the row is equal to 9
        if(col == 9) return solve(board, row + 1, 0);  // return the solve function if the column is equal to 9
        if(board[row][col] != '.') return solve(board, row, col + 1);  // return the solve function if the current value is not equal to '.'
        for(char c = '1'; c <= '9'; c++){  // iterate through the numbers from 1 to 9
            if(isValid(board, row, col, c)){  // if the current value is valid
                board[row][col] = c;  // update the value
                if(solve(board, row, col + 1)) return true;  // return true if the solve function returns true
                board[row][col] = '.';  // update the value
            }
        }
        return false;  // return false
    }
    boolean isValid(char[][] board, int row, int col, char c){  // function to check if the current value is valid
        for(int i = 0; i < 9; i++){  // iterate through the board
            if(board[row][i] == c) return false;  // return false if the current value is equal to c
            if(board[i][col] == c) return false;  // return false if the current value is equal to c
            if(board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false;  // return false if the current value is equal to c
        }
        return true;  // return true
    }

}


38. Count and Say





// Time Complexity : O(n * m) where n is the length of the vector nums and space complexity is O(n + m)







class Solution {
public:
    string countAndSay(int n) {
        string result = "1";  // variable to store the result
        for(int i = 1; i < n; i++){  // iterate from 1 to n
            string temp = "";  // variable to store the temporary result
            int count = 1;  // variable to store the count
            for(int j = 1; j < result.length(); j++){  // iterate through the result
                if(result[j] == result[j - 1]){  // if the current value is equal to the previous value
                    count++;  // increment the count
                }
                else{  // if the current value is not equal to the previous value
                    temp += to_string(count) + result[j - 1];  // update the temp
                    count = 1;  // reset the count
                }
            }
            temp += to_string(count) + result[result.length() - 1];  // update the temp
            result = temp;  // update the result
        }
        return result;  // return the result
    }
};


2nd Method 



 class Solution {
public:
    string countAndSay(int n) {
        if(n==1) return "1";

        string s = countAndSay(n-1);

        int cnt=1;
        
        string ans="";

        for(int i=0; i<s.size(); i++){
            if(i<s.size() && s[i]==s[i+1]){
                cnt++;
            }
            else{
                ans+=char(cnt+int('0'));
                ans+=s[i];
                cnt=1;
            }
        }
        return ans;
    }
};








38. Count and Say in java






// Time Complexity : O(n * m) where n is the length of the vector nums and space complexity is O(n + m)







class Solution {
    public String countAndSay(int n) {
        String result = "1";  // variable to store the result
        for(int i = 1; i < n; i++){  // iterate from 1 to n
            String temp = "";  // variable to store the temporary result
            int count = 1;  // variable to store the count
            for(int j = 1; j < result.length(); j++){  // iterate through the result
                if(result.charAt(j) == result.charAt(j - 1)){  // if the current value is equal to the previous value
                    count++;  // increment the count
                }
                else{  // if the current value is not equal to the previous value
                    temp += Integer.toString(count) + result.charAt(j - 1);  // update the temp
                    count = 1;  // reset the count
                }
            }
            temp += Integer.toString(count) + result.charAt(result.length() - 1);  // update the temp
            result = temp;  // update the result
        }
        return result;  // return the result
    }
}





2nd Method 




class Solution {
    public String countAndSay(int n) {
        if(n==1) return "1";

        String s = countAndSay(n-1);

        int cnt=1;
        
        String ans="";

        for(int i=0; i<s.length(); i++){
            if(i<s.length()-1 && s.charAt(i)==s.charAt(i+1)){
                cnt++;
            }
            else{
                ans+=Integer.toString(cnt);
                ans+=s.charAt(i);
                cnt=1;
            }
        }
        return ans;
    }
}




39. Combination Sum






// Time Complexity : O(n * m) where n is the length of the vector nums and space complexity is O(n + m)







class Solution {
public:
    vector<vector<int>> result;  // vector to store the result
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<int> temp;  // vector to store the temporary result
        backtrack(candidates, target, temp, 0);  // call the backtrack function
        return result;  // return the result
    }
    void backtrack(vector<int>& candidates, int target, vector<int>& temp, int index){  // function to backtrack
        if(target == 0){  // if the target is equal to 0
            result.push_back(temp);  // push the temp into the result
            return;  // return
        }
        if(target < 0) return;  // if the target is less than 0, return
        for(int i = index; i < candidates.size(); i++){  // iterate through the candidates
            temp.push_back(candidates[i]);  // push the current value into the temp
            backtrack(candidates, target - candidates[i], temp, i);  // call the backtrack function
            temp.pop_back();  // pop the value from the temp
        }
    }
};








39. Combination Sum in java






// Time Complexity : O(n * m) where n is the length of the vector nums and space complexity is O(n + m)







class Solution {
    List<List<Integer>> result = new ArrayList<>();  // vector to store the result
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<Integer> temp = new ArrayList<>();  // vector to store the temporary result
        backtrack(candidates, target, temp, 0);  // call the backtrack function
        return result;  // return the result
    }
    void backtrack(int[] candidates, int target, List<Integer> temp, int index){  // function to backtrack
        if(target == 0){  // if the target is equal to 0
            result.add(new ArrayList<>(temp));  // push the temp into the result
            return;  // return
        }
        if(target < 0) return;  // if the target is less than 0, return
        for(int i = index; i < candidates.length; i++){  // iterate through the candidates
            temp.add(candidates[i]);  // push the current value into the temp
            backtrack(candidates, target - candidates[i], temp, i);  // call the backtrack function
            temp.remove(temp.size() - 1);  // pop the value from the temp
        }
    }
}









40. Combination Sum II








// Time Complexity : O(n * m) where n is the length of the vector nums and space complexity is O(n + m)







class Solution {
public:
    vector<vector<int>> result;  // vector to store the result
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<int> temp;  // vector to store the temporary result
        sort(candidates.begin(), candidates.end());  // sort the candidates
        backtrack(candidates, target, temp, 0);  // call the backtrack function
        return result;  // return the result
    }
    void backtrack(vector<int>& candidates, int target, vector<int>& temp, int index){  // function to backtrack
        if(target == 0){  // if the target is equal to 0
            result.push_back(temp);  // push the temp into the result
            return;  // return
        }
        if(target < 0) return;  // if the target is less than 0, return
        for(int i = index; i < candidates.size(); i++){  // iterate through the candidates
            if(i > index && candidates[i] == candidates[i - 1]) continue;  // if the current value is equal to the previous value, continue
            temp.push_back(candidates[i]);  // push the current value into the temp
            backtrack(candidates, target - candidates[i], temp, i + 1);  // call the backtrack function
            temp.pop_back();  // pop the value from the temp
        }
    }
};








40. Combination Sum II in java







// Time Complexity : O(n * m) where n is the length of the vector nums and space complexity is O(n + m)








class Solution {
    List<List<Integer>> result = new ArrayList<>();  // vector to store the result
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<Integer> temp = new ArrayList<>();  // vector to store the temporary result
        Arrays.sort(candidates);  // sort the candidates
        backtrack(candidates, target, temp, 0);  // call the backtrack function
        return result;  // return the result
    }
    void backtrack(int[] candidates, int target, List<Integer> temp, int index){  // function to backtrack
        if(target == 0){  // if the target is equal to 0
            result.add(new ArrayList<>(temp));  // push the temp into the result
            return;  // return
        }
        if(target < 0) return;  // if the target is less than 0, return
        for(int i = index; i < candidates.length; i++){  // iterate through the candidates
            if(i > index && candidates[i] == candidates[i - 1]) continue;  // if the current value is equal to the previous value, continue
            temp.add(candidates[i]);  // push the current value into the temp
            backtrack(candidates, target - candidates[i], temp, i + 1);  // call the backtrack function
            temp.remove(temp.size() - 1);  // pop the value from the temp
        }
    }
}










41. First Missing Positive



// Time Complexity:
// Swapping Technique:

// The time complexity of the swapping technique is O(n), where n is the number of elements in the array.
// In the first loop, we iterate through the array once to rearrange the elements using swaps, which takes O(n) time in the worst case.
// In the second loop, we iterate through the array again to find the first missing positive number, which also takes O(n) time in the worst case.
// Therefore, the overall time complexity is O(n).
// Inbuilt sort Function:

// The time complexity of the inbuilt sort function is O(nlogn), where n is the number of elements in the array.
// Sorting the array using the sort function takes O(nlogn) time in the worst case.
// After sorting, we iterate through the array once to find the first missing positive number, which takes O(n) time in the worst case.
// Therefore, the overall time complexity is dominated by the sorting step, which is O(nlogn).
// Space Complexity:
// Swapping Technique:

// The swapping technique uses constant extra space, O(1), as it only requires a few variables for iteration and swapping.
// It modifies the input array in place without using additional memory.
// Inbuilt sort Function:

// The inbuilt sort function may require O(logn) space for its internal recursive calls during the sorting process.
// However, since the sorting is done in place on the input vector, the space complexity for the sorting step is considered to be O(1).
// The rest of the algorithm uses only a few variables, so it requires O(1) additional space for the rest of the steps.
// In conclusion:

// The swapping technique has a better time complexity of O(n) compared to the inbuilt sort function's O(nlogn).
// Both techniques have the same space complexity of O(1) because they use constant extra space, but the inbuilt sort function might require some extra space for its internal operations (recursive calls) during sorting.
// Overall, the swapping technique is generally more efficient in terms of both time and space complexity compared to using the inbuilt sort function.





// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)








class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();  // variable to store the length of the vector nums
        for(int i = 0; i < n; i++){  // iterate through the vector nums
            while(nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1]){  // iterate until the current value is greater than 0 and less than or equal to n and the current value is not equal to the value at the index current value - 1
                swap(nums[i], nums[nums[i] - 1]);  // swap the values
            }
        }
        for(int i = 0; i < n; i++){  // iterate through the vector nums
            if(nums[i] != i + 1) return i + 1;  // return the index + 1 if the current value is not equal to the index + 1
        }
        return n + 1;  // return n + 1
    }
};


2nd Method 




class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        sort(nums.begin() , nums.end());
        int missing = 1;
        for(int i=0; i<nums.size(); i++){
            if(nums[i] > 0 && nums[i] == missing ) missing ++;
        }
        return missing;
    }
};










41. First Missing Positive in java









// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)







class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;  // variable to store the length of the vector nums
        for(int i = 0; i < n; i++){  // iterate through the vector nums
            while(nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1]){  // iterate until the current value is greater than 0 and less than or equal to n and the current value is not equal to the value at the index current value - 1
                swap(nums, i, nums[i] - 1);  // swap the values
            }
        }
        for(int i = 0; i < n; i++){  // iterate through the vector nums
            if(nums[i] != i + 1) return i + 1;  // return the index + 1 if the current value is not equal to the index + 1
        }
        return n + 1;  // return n + 1
    }
    void swap(int[] nums, int i, int j){  // function to swap the values
        int temp = nums[i];  // variable to store the value
        nums[i] = nums[j];  // update the value
        nums[j] = temp;  // update the value
    }
}





2nd Method 




class Solution {
    public int firstMissingPositive(int[] nums) {
        Arrays.sort(nums);
        int missing = 1;
        for(int i=0; i<nums.length; i++){
            if(nums[i] > 0 && nums[i] == missing ) missing ++;
        }
        return missing;
    }
}




41. First Missing Positive in python




// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)



class Solution(object):
    def firstMissingPositive(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """


        n = len(nums)  # variable to store the length of the vector nums


        for i in range(n):  # iterate through the vector nums
            while nums[i] > 0 and nums[i] <= n and nums[i] != nums[nums[i] - 1]:  # iterate until the current value is greater than 0 and less than or equal to n and the current value is not equal to the value at the index current value - 1
                nums[i], nums[nums[i] - 1] = nums[nums[i] - 1], nums[i]  # swap the values
            
        for i in range(n):  # iterate through the vector nums
            if nums[i] != i + 1: return i + 1  # return the index + 1 if the current value is not equal to the index + 1
        return n + 1  # return n + 1






 2nd  Method




class Solution(object):
    def firstMissingPositive(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """


        nums.sort()
        missing = 1
        for i in range(len(nums)):
            if nums[i] > 0 and nums[i] == missing:
                missing += 1
        return missing
               





41. First Missing Positive in python3






// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)





class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        n = len(nums)
        
        # Cyclic Sort to arrange the positive integers correctly
        for i in range(n):
            while 1 <= nums[i] <= n and nums[i] != nums[nums[i] - 1]:
                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
        
        # Find the first missing positive integer
        for i in range(n):
            if nums[i] != i + 1:
                return i + 1
        
        return n + 1



2nd Method





class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        nums.sort()
        missing = 1
        for i in range(len(nums)):
            if nums[i] > 0 and nums[i] == missing:
                missing += 1
        return missing





41. First Missing Positive in  C





// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)







int firstMissingPositive(int* nums, int numsSize){
    int n = numsSize;  // variable to store the length of the vector nums
    for(int i = 0; i < n; i++){  // iterate through the vector nums
        while(nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1]){  // iterate until the current value is greater than 0 and less than or equal to n and the current value is not equal to the value at the index current value - 1
            int temp = nums[i];  // swap the values
            nums[i] = nums[temp - 1];
            nums[temp - 1] = temp;       
        }
    }
    for(int i = 0; i < n; i++){  // iterate through the vector nums
        if(nums[i] != i + 1) return i + 1;  // return the index + 1 if the current value is not equal to the index + 1
    }
    return n + 1;  // return n + 1
}












41. First Missing Positive in  C#






// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)







public class Solution {
    public int FirstMissingPositive(int[] nums) {
        int n = nums.Length;  // variable to store the length of the vector nums
        for(int i = 0; i < n; i++){  // iterate through the vector nums
            while(nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1]){  // iterate until the current value is greater than 0 and less than or equal to n and the current value is not equal to the value at the index current value - 1
                swap(nums, i, nums[i] - 1);  // swap the values
            }
        }
        for(int i = 0; i < n; i++){  // iterate through the vector nums
            if(nums[i] != i + 1) return i + 1;  // return the index + 1 if the current value is not equal to the index + 1
        }
        return n + 1;  // return n + 1
    }
    void swap(int[] nums, int i, int j){  // function to swap the values
        int temp = nums[i];  // variable to store the value
        nums[i] = nums[j];  // update the value
        nums[j] = temp;  // update the value
    }
}





2nd Method 




public class Solution {
    public int FirstMissingPositive(int[] nums) {
        Array.Sort(nums);
        int missing = 1;
        for(int i=0; i<nums.Length; i++){
            if(nums[i] > 0 && nums[i] == missing ) missing ++;
        }
        return missing;
    }
}





41. First Missing Positive in  javascript 




// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)





var firstMissingPositive = function(nums) {
    let n = nums.length;  // variable to store the length of the vector nums
    for(let i = 0; i < n; i++){  // iterate through the vector nums
        while(nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1]){  // iterate until the current value is greater than 0 and less than or equal to n and the current value is not equal to the value at the index current value - 1
            let tmp = nums[i];  // swap the values
            nums[i] = nums[tmp - 1];
            nums[tmp - 1] = tmp;       
        }
    }
    for(let i = 0; i < n; i++){  // iterate through the vector nums
        if(nums[i] != i + 1) return i + 1;  // return the index + 1 if the current value is not equal to the index + 1
    }
    return n + 1;  // return n + 1
};







2nd Method



var firstMissingPositive = function(nums) {
    // Filter out non-positive numbers and duplicates
    const filteredNums = [...new Set(nums)].filter(num => num > 0);

    // Sort the filtered array in ascending order
    filteredNums.sort((a, b) => a - b);

    let missing = 1;
    for (let i = 0; i < filteredNums.length; i++) {
        if (filteredNums[i] === missing) {
            missing++;
        } else {
            // If the missing positive is found, return it
            return missing;
        }
    }

    // If all positive integers up to the length of the array are present,
    // then the next missing positive would be the length of the array + 1.
    return missing;
};



            OR

/**
 * @param {number[]} nums
 * @return {number}
 */
var firstMissingPositive = function(nums) {
    let missingPositive = 1;
    let set = new Set(nums);

    while(set.has(missingPositive)) {
        missingPositive++
    }


    return missingPositive
};



41. First Missing Positive in  swift 






// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)







class Solution {
    func firstMissingPositive(_ nums: [Int]) -> Int {
        var nums = nums  // variable to store the vector nums
        let n = nums.count  // variable to store the length of the vector nums
        for i in 0..<n{  // iterate through the vector nums
            var num = nums[i]  // variable to store the value
            while num > 0 && num <= n && num != nums[num - 1]{  // iterate until the current value is greater than 0 and less than or equal to n and the current value is not equal to the value at the index current value - 1
                nums.swapAt(i, num - 1)  // swap the values
                num = nums[i]  // update the value
            }
        }
        for i in 0..<n{  // iterate through the vector nums
            if nums[i] != i + 1{  // if the current value is not equal to the index + 1
                return i + 1  // return the index + 1
            }
        }
        return n + 1  // return n + 1
    }
}








2nd Method 





class Solution {
    func firstMissingPositive(_ nums: [Int]) -> Int {
        var nums = nums  // variable to store the vector nums
        nums.sort()  // sort the vector nums
        var missing = 1  // variable to store the missing value
        for i in 0..<nums.count{  // iterate through the vector nums
            if nums[i] > 0 && nums[i] == missing{  // if the current value is greater than 0 and equal to the missing value
                missing += 1  // increment the missing value
            }
        }
        return missing  // return the missing value
    }
}

















2652. Sum Multiples







// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)










class Solution {
public:
    int sumMultiples(vector<int>& nums) {
        int sum = 0;  // variable to store the sum
        for(int i = 0; i < nums.size(); i++){  // iterate through the vector nums
            if(nums[i] % 3 == 0 || nums[i] % 5 == 0) sum += nums[i];  // if the current value is divisible by 3 or 5, add it to the sum
        }
        return sum;  // return the sum
    }
};








2652. Sum Multiples in java






// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)







class Solution {
    public int sumMultiples(int[] nums) {
        int sum = 0;  // variable to store the sum
        for(int i = 0; i < nums.length; i++){  // iterate through the vector nums
            if(nums[i] % 3 == 0 || nums[i] % 5 == 0) sum += nums[i];  // if the current value is divisible by 3 or 5, add it to the sum
        }
        return sum;  // return the sum
    }
}




2651. Calculate Delayed Arrival Time







// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)




class Solution {
public:
    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {
        return (arrivalTime + delayedTime) % 24;
    }
};







2651. Calculate Delayed Arrival Time in java






// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)





class Solution {
    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {
        return (arrivalTime + delayedTime) % 24;
    }
}






2582. Pass the Pillow



Comparison:
Both implementations provide the same output, but the second implementation is more efficient in terms of time complexity. It avoids the need for explicit iteration and uses a direct mathematical formula to calculate the result. Additionally, the second implementation is more concise and easier to read.

In conclusion, the second implementation with the mathematical formula is better than the first one in terms of both time and space complexity.





// Time Complexity : O(time) where n is the length of the vector nums and space complexity is O(1)




class Solution {
public:
    int passThePillow(int n, int time) {
         int  position = 1;
    bool going_right = true;

    for(int i=0;i<time;i++){
        if(going_right)
            position += 1;
        else
            position -= 1;

        if(position == 1 || position == n)
            going_right = !going_right;
    }

    return position;
    }
};





2nd Method 






// Time Complexity : O(1) where n is the length of the vector nums and space complexity is O(1)



class Solution {
public:
    int passThePillow(int n, int time) {
          return n - abs(n - 1 - time % (n * 2 - 2));
    }
};

// The function passThePillow takes two integer parameters: n and time.

// The function returns an integer, which represents the index of the person holding the pillow when the time runs out in a game of passing the pillow.

// Let's understand the expression inside the return statement step by step:

// a. n * 2 - 2: It calculates the number of positions in a circular arrangement where the pillow can be passed. Since there are n people, there are n positions where the pillow can be initially passed, and for each person holding the pillow afterward, there are n - 1 new positions available. So, the total number of positions in the circular arrangement is n + (n - 1) = n * 2 - 1. However, we subtract 2 instead of 1 because we are working with zero-based indexing.

// b. time % (n * 2 - 2): This calculates the remaining time after completing one full round of passing the pillow in the circular arrangement. The modulo operator (%) returns the remainder of the division between time and the total number of positions. It ensures that we wrap around the positions in the circle if the time exceeds the duration of one full round.

// c. n - 1 - time % (n * 2 - 2): This calculates the position of the person holding the pillow when the time runs out. Since the position is zero-based, we subtract 1 from the result.

// Finally, the function returns n minus the position calculated above. This is because if we start counting people from 0, then the person holding the pillow at the end will be at index n - 1 (assuming zero-based indexing). By subtracting the calculated position from n, we get the correct index of the last person holding the pillow when the time runs out.

// In summary, this code provides a concise way to find the index of the person holding the pillow when the time runs out in a circular game of passing the pillow.




2582. Pass the Pillow in java



Comparison:
Both implementations provide the same output, but the second implementation is more efficient in terms of time complexity. It avoids the need for explicit iteration and uses a direct mathematical formula to calculate the result. Additionally, the second implementation is more concise and easier to read.

In conclusion, the second implementation with the mathematical formula is better than the first one in terms of both time and space complexity.





// Time Complexity : O(time) where n is the length of the vector nums and space complexity is O(1)







class Solution {
    public int passThePillow(int n, int time) {
         int  position = 1;
    boolean going_right = true;

    for(int i=0;i<time;i++){
        if(going_right)
            position += 1;
        else
            position -= 1;

        if(position == 1 || position == n)
            going_right = !going_right;
    }

    return position;
    }
}






2nd Method 






// Time Complexity : O(1) where n is the length of the vector nums and space complexity is O(1)





class Solution {
    public int passThePillow(int n, int time) {
          return n - Math.abs(n - 1 - time % (n * 2 - 2));
    }
}


// The function passThePillow takes two integer parameters: n and time.

// The function returns an integer, which represents the index of the person holding the pillow when the time runs out in a game of passing the pillow.

// Let's understand the expression inside the return statement step by step:

// a. n * 2 - 2: It calculates the number of positions in a circular arrangement where the pillow can be passed. Since there are n people, there are n positions where the pillow can be initially passed, and for each person holding the pillow afterward, there are n - 1 new positions available. So, the total number of positions in the circular arrangement is n + (n - 1) = n * 2 - 1. However, we subtract 2 instead of 1 because we are working with zero-based indexing.

// b. time % (n * 2 - 2): This calculates the remaining time after completing one full round of passing the pillow in the circular arrangement. The modulo operator (%) returns the remainder of the division between time and the total number of positions. It ensures that we wrap around the positions in the circle if the time exceeds the duration of one full round.

// c. n - 1 - time % (n * 2 - 2): This calculates the position of the person holding the pillow when the time runs out. Since the position is zero-based, we subtract 1 from the result.

// Finally, the function returns n minus the position calculated above. This is because if we start counting people from 0, then the person holding the pillow at the end will be at index n - 1 (assuming zero-based indexing). By subtracting the calculated position from n, we get the correct index of the last person holding the pillow when the time runs out.

// In summary, this code provides a concise way to find the index of the person holding the pillow when the time runs out in a circular game of passing the pillow.











42. Trapping Rain Water in c++ using brute force 



// Time Complexity : O(n^2) where n is the length of the array and space complexity is O(1)



class Solution {

public:

    int trap(vector<int>& height) {

        int n = height.size();  // variable to store the length of the array

        int result = 0;  // variable to store the result

        for(int i = 1; i < n - 1; i++){  // iterate through the arra

            int leftMax = 0;  // variable to store the left max value

            int rightMax = 0;  // variable to store the right max value

            for(int j = i; j >= 0; j--){  // iterate through the array from the current index to the left

                leftMax = max(leftMax, height[j]);  // calculate the left max value

            }

            for(int j = i; j < n; j++){  // iterate through the array from the current index to the right

                rightMax = max(rightMax, height[j]);  // calculate the right max value

            }

            result += min(leftMax, rightMax) - height[i];  // calculate the result

        }

        return result;  // return the result

    }

};


2nd Method using Dp



// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)



class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();  // variable to store the length of the array
        vector<int> leftMax(n, 0);  // vector to store the left max values
        vector<int> rightMax(n, 0);  // vector to store the right max values
        int result = 0;  // variable to store the result
        leftMax[0] = height[0];  // update the left max value
        for(int i = 1; i < n; i++){  // iterate through the array
            leftMax[i] = max(leftMax[i - 1], height[i]);  // calculate the left max value
        }
        rightMax[n - 1] = height[n - 1];  // update the right max value
        for(int i = n - 2; i >= 0; i--){  // iterate through the array
            rightMax[i] = max(rightMax[i + 1], height[i]);  // calculate the right max value
        }
        for(int i = 0; i < n; i++){  // iterate through the array
            result += min(leftMax[i], rightMax[i]) - height[i];  // calculate the result
        }
        return result;  // return the result
    }
};



3rd Method using two pointers



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)



class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();  // variable to store the length of the array
        int left = 0, right = n - 1;  // variables to store the left and right pointers
        int leftMax = 0, rightMax = 0;  // variables to store the left and right max values
        int result = 0;  // variable to store the result
        while(left <= right){  // iterate through the array
            if(height[left] <= height[right]){  // if the left value is less than or equal to the right value
                if(height[left] >= leftMax){  // if the left value is greater than or equal to the left max value
                    leftMax = height[left];  // update the left max value
                }
                else{  // if the left value is less than the left max value
                    result += leftMax - height[left];  // calculate the result
                }
                left++;  // increment the left pointer
            }
            else{  // if the right value is less than the left value
                if(height[right] >= rightMax){  // if the right value is greater than or equal to the right max value
                    rightMax = height[right];  // update the right max value
                }
                else{  // if the right value is less than the right max value
                    result += rightMax - height[right];  // calculate the result
                }
                right--;  // decrement the right pointer
            }
        }
        return result;  // return the result
    }
};



4th Method using stack



// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)



class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();  // variable to store the length of the array
        stack<int> st;  // stack to store the indices
        int result = 0;  // variable to store the result
        for(int i = 0; i < n; i++){  // iterate through the array
            while(!st.empty() && height[i] > height[st.top()]){  // if the stack is not empty and the current value is greater than the top value of the stack
                int top = st.top();  // variable to store the top value of the stack
                st.pop();  // pop the top value of the stack
                if(st.empty()){  // if the stack is empty
                    break;  // break
                }
                int distance = i - st.top() - 1;  // variable to store the distance
                int boundedHeight = min(height[i], height[st.top()]) - height[top];  // variable to store the bounded height
                result += distance * boundedHeight;  // calculate the result
            }
            st.push(i);  // push the current index to the stack
        }
        return result;  // return the result
    }
};





42. Trapping Rain Water in java using brute force 



// Time Complexity : O(n^2) where n is the length of the array and space complexity is O(1)



class Solution {

    public int trap(int[] height) {

        int n = height.length;  // variable to store the length of the array

        int result = 0;  // variable to store the result

        for(int i = 1; i < n - 1; i++){  // iterate through the array

            int leftMax = 0;  // variable to store the left max value

            int rightMax = 0;  // variable to store the right max value

            for(int j = i; j >= 0; j--){  // iterate through the array from the current index to the left

                leftMax = Math.max(leftMax, height[j]);  // calculate the left max value

            }

            for(int j = i; j < n; j++){  // iterate through the array from the current index to the right

                rightMax = Math.max(rightMax, height[j]);  // calculate the right max value

            }

            result += Math.min(leftMax, rightMax) - height[i];  // calculate the result

        }

        return result;  // return the result

    }

}



42. Trapping Rain Water in java using Dp



// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)



class Solution {
    public int trap(int[] height) {
        int n = height.length;  // variable to store the length of the array
        int[] leftMax = new int[n];  // array to store the left max values
        int[] rightMax = new int[n];  // array to store the right max values
        int result = 0;  // variable to store the result
        leftMax[0] = height[0];  // update the left max value
        for(int i = 1; i < n; i++){  // iterate through the array
            leftMax[i] = Math.max(leftMax[i - 1], height[i]);  // calculate the left max value
        }
        rightMax[n - 1] = height[n - 1];  // update the right max value
        for(int i = n - 2; i >= 0; i--){  // iterate through the array
            rightMax[i] = Math.max(rightMax[i + 1], height[i]);  // calculate the right max value
        }
        for(int i = 0; i < n; i++){  // iterate through the array
            result += Math.min(leftMax[i], rightMax[i]) - height[i];  // calculate the result
        }
        return result;  // return the result
    }
}





42. Trapping Rain Water in java using two pointers



// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)





class Solution {
    public int trap(int[] height) {
        int n = height.length;  // variable to store the length of the array
        int left = 0, right = n - 1;  // variables to store the left and right pointers
        int leftMax = 0, rightMax = 0;  // variables to store the left and right max values
        int result = 0;  // variable to store the result
        while(left <= right){  // iterate through the array
            if(height[left] <= height[right]){  // if the left value is less than or equal to the right value
                if(height[left] >= leftMax){  // if the left value is greater than or equal to the left max value
                    leftMax = height[left];  // update the left max value
                }
                else{  // if the left value is less than the left max value
                    result += leftMax - height[left];  // calculate the result
                }
                left++;  // increment the left pointer
            }
            else{  // if the right value is less than the left value
                if(height[right] >= rightMax){  // if the right value is greater than or equal to the right max value
                    rightMax = height[right];  // update the right max value
                }
                else{  // if the right value is less than the right max value
                    result += rightMax - height[right];  // calculate the result
                }
                right--;  // decrement the right pointer
            }
        }
        return result;  // return the result
    }
}





42. Trapping Rain Water in java using stack



// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)



class Solution {
    public int trap(int[] height) {
        int n = height.length;  // variable to store the length of the array
        Stack<Integer> st = new Stack<>();  // stack to store the indices
        int result = 0;  // variable to store the result
        for(int i = 0; i < n; i++){  // iterate through the array
            while(!st.isEmpty() && height[i] > height[st.peek()]){  // if the stack is not empty and the current value is greater than the top value of the stack
                int top = st.pop();  // variable to store the top value of the stack
                if(st.isEmpty()){  // if the stack is empty
                    break;  // break
                }
                int distance = i - st.peek() - 1;  // variable to store the distance
                int boundedHeight = Math.min(height[i], height[st.peek()]) - height[top];  // variable to store the bounded height
                result += distance * boundedHeight;  // calculate the result
            }
            st.push(i);  // push the current index to the stack
        }
        return result;  // return the result
    }
}







42. Trapping Rain Water in python using brute force





// Time Complexity : O(n^2) where n is the length of the array and space complexity is O(1)





class Solution(object):
    def trap(self, height):
        """
        :type height: List[int]
        :rtype: int
        """
        n = len(height)  # variable to store the length of the array
        result = 0  # variable to store the result
        for i in range(1, n - 1):  # iterate through the array
            leftMax = 0  # variable to store the left max value
            rightMax = 0  # variable to store the right max value
            for j in range(i, -1, -1):  # iterate through the array from the current index to the left
                leftMax = max(leftMax, height[j])  # calculate the left max value
            for j in range(i, n):  # iterate through the array from the current index to the right
                rightMax = max(rightMax, height[j])  # calculate the right max value
            result += min(leftMax, rightMax) - height[i]  # calculate the result
        return result  # return the result






2nd Method using dp 






// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)







class Solution(object):
    def trap(self, height):
        """
        :type height: List[int]
        :rtype: int
        """
        n = len(height)  # variable to store the length of the array
        leftMax = [0] * n  # list to store the left max values
        rightMax = [0] * n  # list to store the right max values
        result = 0  # variable to store the result
        leftMax[0] = height[0]  # update the left max value
        for i in range(1, n):  # iterate through the array
            leftMax[i] = max(leftMax[i - 1], height[i])  # calculate the left max value
        rightMax[n - 1] = height[n - 1]  # update the right max value
        for i in range(n - 2, -1, -1):  # iterate through the array
            rightMax[i] = max(rightMax[i + 1], height[i])  # calculate the right max value
        for i in range(n):  # iterate through the array
            result += min(leftMax[i], rightMax[i]) - height[i]  # calculate the result
        return result  # return the result






3rd Method using two pointers





// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)







class Solution(object):
    def trap(self, height):
        """
        :type height: List[int]
        :rtype: int
        """
        n = len(height)  # variable to store the length of the array
        left = 0  # variable to store the left pointer
        right = n - 1  # variable to store the right pointer
        leftMax = 0  # variable to store the left max value
        rightMax = 0  # variable to store the right max value
        result = 0  # variable to store the result
        while left <= right:  # iterate through the array
            if height[left] <= height[right]:  # if the left value is less than or equal to the right value
                if height[left] >= leftMax:  # if the left value is greater than or equal to the left max value
                    leftMax = height[left]  # update the left max value
                else:  # if the left value is less than the left max value
                    result += leftMax - height[left]  # calculate the result
                left += 1  # increment the left pointer
            else:  # if the right value is less than the left value
                if height[right] >= rightMax:  # if the right value is greater than or equal to the right max value
                    rightMax = height[right]  # update the right max value
                else:  # if the right value is less than the right max value
                    result += rightMax - height[right]  # calculate the result
                right -= 1  # decrement the right pointer
        return result  # return the result






4th Method using stack





// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)







class Solution(object):
    def trap(self, height):
        """
        :type height: List[int]
        :rtype: int
        """
        n = len(height)  # variable to store the length of the array
        st = []  # stack to store the indices
        result = 0  # variable to store the result
        for i in range(n):  # iterate through the array
            while st and height[i] > height[st[-1]]:  # if the stack is not empty and the current value is greater than the top value of the stack
                top = st.pop()  # variable to store the top value of the stack
                if not st:  # if the stack is empty
                    break  # break
                distance = i - st[-1] - 1  # variable to store the distance
                boundedHeight = min(height[i], height[st[-1]]) - height[top]  # variable to store the bounded height
                result += distance * boundedHeight  # calculate the result
            st.append(i)  # push the current index to the stack
        return result  # return the result




42. Trapping Rain Water in python3 using brute force






// Time Complexity : O(n^2) where n is the length of the array and space complexity is O(1)







class Solution:
    def trap(self, height: List[in) -> int: //add ] after int
        n = len(height)  #variable to store the length of the array
        result = 0  # variable to store the result
        for i in range(1, n - 1):  # iterate through the array
            leftMax = 0  # variable to store the left max value
            rightMax = 0  # variable to store the right max value
            for j in range(i, -1, -1):  # iterate through the array from the current index to the left
                leftMax = max(leftMax, height[j])  # calculate the left max value
            for j in range(i, n):  # iterate through the array from the current index to the right
                rightMax = max(rightMax, height[j])  # calculate the right max value
            result += min(leftMax, rightMax) - height[i]  # calculate the result
        return result  # return the result




2nd Method using dp





// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)







class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)  # variable to store the length of the array
        leftMax = [0] * n  # list to store the left max values
        rightMax = [0] * n  # list to store the right max values
        result = 0  # variable to store the result
        leftMax[0] = height[0]  # update the left max value
        for i in range(1, n):  # iterate through the array
            leftMax[i] = max(leftMax[i - 1], height[i])  # calculate the left max value
        rightMax[n - 1] = height[n - 1]  # update the right max value
        for i in range(n - 2, -1, -1):  # iterate through the array
            rightMax[i] = max(rightMax[i + 1], height[i])  # calculate the right max value
        for i in range(n):  # iterate through the array
            result += min(leftMax[i], rightMax[i]) - height[i]  # calculate the result
        return result  # return the result







3rd Method using two pointers







// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)







class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)  # variable to store the length of the array
        left = 0  # variable to store the left pointer
        right = n - 1  # variable to store the right pointer
        leftMax = 0  # variable to store the left max value
        rightMax = 0  # variable to store the right max value
        result = 0  # variable to store the result
        while left <= right:  # iterate through the array
            if height[left] <= height[right]:  # if the left value is less than or equal to the right value
                if height[left] >= leftMax:  # if the left value is greater than or equal to the left max value
                    leftMax = height[left]  # update the left max value
                else:  # if the left value is less than the left max value
                    result += leftMax - height[left]  # calculate the result
                left += 1  # increment the left pointer
            else:  # if the right value is less than the left value
                if height[right] >= rightMax:  # if the right value is greater than or equal to the right max value
                    rightMax = height[right]  # update the right max value
                else:  # if the right value is less than the right max value
                    result += rightMax - height[right]  # calculate the result
                right -= 1  # decrement the right pointer
        return result  # return the result









4th Method using stack







// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)







class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)  # variable to store the length of the array
        st = []  # stack to store the indices
        result = 0  # variable to store the result
        for i in range(n):  # iterate through the array
            while st and height[i] > height[st[-1]]:  # if the stack is not empty and the current value is greater than the top value of the stack
                top = st.pop()  # variable to store the top value of the stack
                if not st:  # if the stack is empty
                    break  # break
                distance = i - st[-1] - 1  # variable to store the distance
                boundedHeight = min(height[i], height[st[-1]]) - height[top]  # variable to store the bounded height
                result += distance * boundedHeight  # calculate the result
            st.append(i)  # push the current index to the stack
        return result  # return the result










42. Trapping Rain Water in c using brute force





// Time Complexity : O(n^2) where n is the length of the array and space complexity is O(1)







int trap(int* height, int heightSize){
    int n = heightSize;  // variable to store the length of the array
    int result = 0;  // variable to store the result
    for(int i = 1; i < n - 1; i++){  // iterate through the array
        int leftMax = 0;  // variable to store the left max value
        int rightMax = 0;  // variable to store the right max value
        for(int j = i; j >= 0; j--){  // iterate through the array from the current index to the left
            leftMax = fmax(leftMax, height[j]);  // calculate the left max value
        }
        for(int j = i; j < n; j++){  // iterate through the array from the current index to the right
            rightMax = fmax(rightMax, height[j]);  // calculate the right max value
        }
        result += fmin(leftMax, rightMax) - height[i];  // calculate the result
    }
    return result;  // return the result
}








2nd Method using dp







// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)







int trap(int* height, int heightSize){
    int n = heightSize;  // variable to store the length of the array
    int leftMax[n];  // array to store the left max values
    int rightMax[n];  // array to store the right max values
    int result = 0;  // variable to store the result
    leftMax[0] = height[0];  // update the left max value
    for(int i = 1; i < n; i++){  // iterate through the array
        leftMax[i] = fmax(leftMax[i - 1], height[i]);  // calculate the left max value
    }
    rightMax[n - 1] = height[n - 1];  // update the right max value
    for(int i = n - 2; i >= 0; i--){  // iterate through the array
        rightMax[i] = fmax(rightMax[i + 1], height[i]);  // calculate the right max value
    }
    for(int i = 0; i < n; i++){  // iterate through the array
        result += fmin(leftMax[i], rightMax[i]) - height[i];  // calculate the result
    }
    return result;  // return the result
}











3rd Method using two pointers







// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)







int trap(int* height, int heightSize){
    int n = heightSize;  // variable to store the length of the array
    int left = 0;  // variable to store the left pointer
    int right = n - 1;  // variable to store the right pointer
    int leftMax = 0;  // variable to store the left max value
    int rightMax = 0;  // variable to store the right max value
    int result = 0;  // variable to store the result
    while(left <= right){  // iterate through the array
        if(height[left] <= height[right]){  // if the left value is less than or equal to the right value
            if(height[left] >= leftMax){  // if the left value is greater than or equal to the left max value
                leftMax = height[left];  // update the left max value
            }
            else{  // if the left value is less than the left max value
                result += leftMax - height[left];  // calculate the result
            }
            left++;  // increment the left pointer
        }
        else{  // if the right value is less than the left value
            if(height[right] >= rightMax){  // if the right value is greater than or equal to the right max value
                rightMax = height[right];  // update the right max value
            }
            else{  // if the right value is less than the right max value
                result += rightMax - height[right];  // calculate the result
            }
            right--;  // decrement the right pointer
        }
    }
    return result;  // return the result
}











4th Method using stack







// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)







int trap(int* height, int heightSize){
    int n = heightSize;  // variable to store the length of the array
    int st[n];  // stack to store the indices
    int top = -1;  // variable to store the top index of the stack
    int result = 0;  // variable to store the result
    for(int i = 0; i < n; i++){  // iterate through the array
        while(top != -1 && height[i] > height[st[top]]){  // if the stack is not empty and the current value is greater than the top value of the stack
            int topIndex = st[top];  // variable to store the top index of the stack
            top--;  // pop the top value of the stack
            if(top == -1){  // if the stack is empty
                break;  // break
            }
            int distance = i - st[top] - 1;  // variable to store the distance
            int boundedHeight = fmin(height[i], height[st[top]]) - height[topIndex];  // variable to store the bounded height
            result += distance * boundedHeight;  // calculate the result
        }
        top++;  // push the current index to the stack
        st[top] = i;  // push the current index to the stack
    }
    return result;  // return the result
}










42. Trapping Rain Water in c# using brute force







// Time Complexity : O(n^2) where n is the length of the array and space complexity is O(1)







public class Solution {
    public int Trap(int[] height) {
        int n = height.Length;  // variable to store the length of the array
        int result = 0;  // variable to store the result
        for(int i = 1; i < n - 1; i++){  // iterate through the array
            int leftMax = 0;  // variable to store the left max value
            int rightMax = 0;  // variable to store the right max value
            for(int j = i; j >= 0; j--){  // iterate through the array from the current index to the left
                leftMax = Math.Max(leftMax, height[j]);  // calculate the left max value
            }
            for(int j = i; j < n; j++){  // iterate through the array from the current index to the right
                rightMax = Math.Max(rightMax, height[j]);  // calculate the right max value
            }
            result += Math.Min(leftMax, rightMax) - height[i];  // calculate the result
        }
        return result;  // return the result
    }
}










2nd Method using dp







// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)







public class Solution {
    public int Trap(int[] height) {
        int n = height.Length;  // variable to store the length of the array
        int[] leftMax = new int[n];  // array to store the left max values
        int[] rightMax = new int[n];  // array to store the right max values
        int result = 0;  // variable to store the result
        leftMax[0] = height[0];  // update the left max value
        for(int i = 1; i < n; i++){  // iterate through the array
            leftMax[i] = Math.Max(leftMax[i - 1], height[i]);  // calculate the left max value
        }
        rightMax[n - 1] = height[n - 1];  // update the right max value
        for(int i = n - 2; i >= 0; i--){  // iterate through the array
            rightMax[i] = Math.Max(rightMax[i + 1], height[i]);  // calculate the right max value
        }
        for(int i = 0; i < n; i++){  // iterate through the array
            result += Math.Min(leftMax[i], rightMax[i]) - height[i];  // calculate the result
        }
        return result;  // return the result
    }
}










3rd Method using two pointers







// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)







public class Solution {
    public int Trap(int[] height) {
        int n = height.Length;  // variable to store the length of the array
        int left = 0;  // variable to store the left pointer
        int right = n - 1;  // variable to store the right pointer
        int leftMax = 0;  // variable to store the left max value
        int rightMax = 0;  // variable to store the right max value
        int result = 0;  // variable to store the result
        while(left <= right){  // iterate through the array
            if(height[left] <= height[right]){  // if the left value is less than or equal to the right value
                if(height[left] >= leftMax){  // if the left value is greater than or equal to the left max value
                    leftMax = height[left];  // update the left max value
                }
                else{  // if the left value is less than the left max value
                    result += leftMax - height[left];  // calculate the result
                }
                left++;  // increment the left pointer
            }
            else{  // if the right value is less than the left value
                if(height[right] >= rightMax){  // if the right value is greater than or equal to the right max value
                    rightMax = height[right];  // update the right max value
                }
                else{  // if the right value is less than the right max value
                    result += rightMax - height[right];  // calculate the result
                }
                right--;  // decrement the right pointer
            }
        }
        return result;  // return the result
    }
}





4th Method using stack







// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)







public class Solution {
    public int Trap(int[] height) {
        int n = height.Length;  // variable to store the length of the array
        Stack<int> st = new Stack<int>();  // stack to store the indices
        int result = 0;  // variable to store the result
        for(int i = 0; i < n; i++){  // iterate through the array
            while(st.Count != 0 && height[i] > height[st.Peek()]){  // if the stack is not empty and the current value is greater than the top value of the stack
                int top = st.Pop();  // variable to store the top value of the stack
                if(st.Count == 0){  // if the stack is empty
                    break;  // break
                }
                int distance = i - st.Peek() - 1;  // variable to store the distance
                int boundedHeight = Math.Min(height[i], height[st.Peek()]) - height[top];  // variable to store the bounded height
                result += distance * boundedHeight;  // calculate the result
            }
            st.Push(i);  // push the current index to the stack
        }
        return result;  // return the result
    }
}










42. Trapping Rain Water in javascript using brute force







// Time Complexity : O(n^2) where n is the length of the array and space complexity is O(1)











/**
 * @param {number[]} height
 * @return {number}
 */


var trap = function(height) {
    let n = height.length;  // variable to store the length of the array
    let result = 0;  // variable to store the result
    for(let i = 1; i < n - 1; i++){  // iterate through the array
        let leftMax = 0;  // variable to store the left max value
        let rightMax = 0;  // variable to store the right max value
        for(let j = i; j >= 0; j--){  // iterate through the array from the current index to the left
            leftMax = Math.max(leftMax, height[j]);  // calculate the left max value
        }
        for(let j = i; j < n; j++){  // iterate through the array from the current index to the right
            rightMax = Math.max(rightMax, height[j]);  // calculate the right max value
        }
        result += Math.min(leftMax, rightMax) - height[i];  // calculate the result
    }
    return result;  // return the result

};










2nd Method using dp







// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)







/**
 * @param {number[]} height
 * @return {number}
 */


var trap = function(height) {
    let n = height.length;  // variable to store the length of the array
    let leftMax = new Array(n);  // array to store the left max values
    let rightMax = new Array(n);  // array to store the right max values
    let result = 0;  // variable to store the result
    leftMax[0] = height[0];  // update the left max value
    for(let i = 1; i < n; i++){  // iterate through the array
        leftMax[i] = Math.max(leftMax[i - 1], height[i]);  // calculate the left max value
    }
    rightMax[n - 1] = height[n - 1];  // update the right max value
    for(let i = n - 2; i >= 0; i--){  // iterate through the array
        rightMax[i] = Math.max(rightMax[i + 1], height[i]);  // calculate the right max value
    }
    for(let i = 0; i < n; i++){  // iterate through the array
        result += Math.min(leftMax[i], rightMax[i]) - height[i];  // calculate the result
    }
    return result;  // return the result
};








3rd Method using two pointers







// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)











/**
 * @param {number[]} height
 * @return {number}
 */



var trap = function(height) {
    let n = height.length;  // variable to store the length of the array
    let left = 0;  // variable to store the left pointer
    let right = n - 1;  // variable to store the right pointer
    let leftMax = 0;  // variable to store the left max value
    let rightMax = 0;  // variable to store the right max value
    let result = 0;  // variable to store the result
    while(left <= right){  // iterate through the array
        if(height[left] <= height[right]){  // if the left value is less than or equal to the right value
            if(height[left] >= leftMax){  // if the left value is greater than or equal to the left max value
                leftMax = height[left];  // update the left max value
            }
            else{  // if the left value is less than the left max value
                result += leftMax - height[left];  // calculate the result
            }
            left++;  // increment the left pointer
        }
        else{  // if the right value is less than the left value
            if(height[right] >= rightMax){  // if the right value is greater than or equal to the right max value
                rightMax = height[right];  // update the right max value
            }
            else{  // if the right value is less than the right max value
                result += rightMax - height[right];  // calculate the result
            }
            right--;  // decrement the right pointer
        }
    }
    return result;  // return the result
};







4th Method using stack







// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)







/**
 * @param {number[]} height
 * @return {number}
 */



var trap = function(height) {
    let n = height.length;  // variable to store the length of the array
    let st = [];  // stack to store the indices
    let result = 0;  // variable to store the result
    for(let i = 0; i < n; i++){  // iterate through the array
        while(st.length != 0 && height[i] > height[st[st.length - 1]]){  // if the stack is not empty and the current value is greater than the top value of the stack
            let top = st.pop();  // variable to store the top value of the stack
            if(st.length == 0){  // if the stack is empty
                break;  // break
            }
            let distance = i - st[st.length - 1] - 1;  // variable to store the distance
            let boundedHeight = Math.min(height[i], height[st[st.length - 1]]) - height[top];  // variable to store the bounded height
            result += distance * boundedHeight;  // calculate the result
        }
        st.push(i);  // push the current index to the stack
    }
    return result;  // return the result
};










42. Trapping Rain Water in Swift using brute force








// Time Complexity : O(n^2) where n is the length of the array and space complexity is O(1)







class Solution {
    func trap(_ height: [Int]) -> Int {
        let n = height.count  // variable to store the length of the array
        var result = 0  // variable to store the result
        for i in 1..<n - 1{  // iterate through the array
            var leftMax = 0  // variable to store the left max value
            var rightMax = 0  // variable to store the right max value
            for j in stride(from: i, through: 0, by: -1){  // iterate through the array from the current index to the left
                leftMax = max(leftMax, height[j])  // calculate the left max value
            }
            for j in stride(from: i, through: n - 1, by: 1){  // iterate through the array from the current index to the right
                rightMax = max(rightMax, height[j])  // calculate the right max value
            }
            result += min(leftMax, rightMax) - height[i]  // calculate the result
        }
        return result  // return the result
    }
}





2nd Method using dp








// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)







class Solution {
    func trap(_ height: [Int]) -> Int {
        let n = height.count  // variable to store the length of the array
        var leftMax = Array(repeating: 0, count: n)  // array to store the left max values
        var rightMax = Array(repeating: 0, count: n)  // array to store the right max values
        var result = 0  // variable to store the result
        leftMax[0] = height[0]  // update the left max value
        for i in 1..<n{  // iterate through the array
            leftMax[i] = max(leftMax[i - 1], height[i])  // calculate the left max value
        }
        rightMax[n - 1] = height[n - 1]  // update the right max value
        for i in stride(from: n - 2, through: 0, by: -1){  // iterate through the array
            rightMax[i] = max(rightMax[i + 1], height[i])  // calculate the right max value
        }
        for i in 0..<n{  // iterate through the array
            result += min(leftMax[i], rightMax[i]) - height[i]  // calculate the result
        }
        return result  // return the result
    }
}





3rd Method using two pointers








// Time Complexity : O(n) where n is the length of the array and space complexity is O(1)




class Solution {
    func trap(_ height: [Int]) -> Int {
        var left = 0
        var right = height.count - 1
        var leftMax = 0
        var rightMax = 0
        var result = 0
        while left <= right{
            if height[left] <= height[right]{
                if height[left] >= leftMax{
                    leftMax = height[left]
                }
                else{
                    result += leftMax - height[left]
                }
                left += 1
            }
            else{
                if height[right] >= rightMax{
                    rightMax = height[right]
                }
                else{
                    result += rightMax - height[right]
                }
                right -= 1
            }
        }
    }
}







4th Method using stack








// Time Complexity : O(n) where n is the length of the array and space complexity is O(n)\










class Solution {
    func trap(_ height: [Int]) -> Int {
        let n = height.count  // variable to store the length of the array
        var st = [Int]()  // stack to store the indices
        var result = 0  // variable to store the result
        for i in 0..<n{  // iterate through the array
            while !st.isEmpty && height[i] > height[st.last!]{
                let top = st.popLast()!
                if st.isEmpty{
                    break
                }
                let distance = i - st.last! - 1
                let boundedHeight = min(height[i], height[st.last!]) - height[top]
                result += distance * boundedHeight
            }
            st.append(i)
        }
        return result
    }
}













43. Multiply Strings in c++  using karatsuba algorithm








// Time Complexity : O(n * m) where n is the length of the first string and m is the length of the second string and space complexity is O(n + m)












class Solution {
public:
    string multiply(string num1, string num2) {
        int n = num1.length();  // variable to store the length of the first string
        int m = num2.length();  // variable to store the length of the second string

        if(num1 == "0" || num2 == "0"){  // if any of the strings is zero
            return "0";  // return zero
        }

        vector<int> result(n + m);  // vector to store the result
        for(int i = n - 1; i >= 0; i--){  // iterate through the first string
            for(int j = m - 1; j >= 0; j--){  // iterate through the second string
                int product = (num1[i] - '0') * (num2[j] - '0');  // variable to store the product
                int sum = product + result[i + j + 1];  // variable to store the sum
                result[i + j + 1] = sum % 10;  // update the result
                result[i + j] += sum / 10;  // update the result
            }
        }
        
        string res = "";  // variable to store the result
        for(int i = 0; i < n + m; i++){  // iterate through the result
            if(result[i] == 0 && res.length() == 0){  // if the current value is zero and the result is empty
                continue;  // continue
            }
            res += to_string(result[i]);  // update the result
        }
        return res;  // return the result
    }
};


2nd Method using  "Long Multiplication" algorithm






// Time Complexity : O(n * m) where n is the length of the first string and m is the length of the second string and space complexity is O(n + m)


#include <string>

class Solution {
public:
    string multiply(string num1, string num2) {
        int n = num1.length();
        int m = num2.length();
        string ans(n + m, '0'); // Initialize ans with appropriate size and '0' characters

        for (int i = n - 1; i >= 0; i--) {
            int carry = 0;
            for (int j = m - 1; j >= 0; j--) {
                int temp = (num1[i] - '0') * (num2[j] - '0') + (ans[i + j + 1] - '0') + carry;
                ans[i + j + 1] = (temp % 10) + '0'; // Store the unit's digit in ans
                carry = temp / 10; // Carry over the tens digit to the next iteration
            }
            ans[i] += carry; // Add any remaining carry to the current position
        }

        // Trim leading zeroes
        int start_pos = ans.find_first_not_of('0');
        return (start_pos != string::npos) ? ans.substr(start_pos) : "0";
    }
};






43. Multiply Strings in java using karatsuba algorithm








// Time Complexity : O(n * m) where n is the length of the first string and m is the length of the second string and space complexity is O(n + m)







class Solution {
    public String multiply(String num1, String num2) {
        int n = num1.length();  // variable to store the length of the first string
        int m = num2.length();  // variable to store the length of the second string

        if(num1.equals("0") || num2.equals("0")){  // if any of the strings is zero
            return "0";  // return zero
        }

        int[] result = new int[n + m];  // array to store the result
        for(int i = n - 1; i >= 0; i--){  // iterate through the first string
            for(int j = m - 1; j >= 0; j--){  // iterate through the second string
                int product = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');  // variable to store the product
                int sum = product + result[i + j + 1];  // variable to store the sum
                result[i + j + 1] = sum % 10;  // update the result
                result[i + j] += sum / 10;  // update the result
            }
        }
        
        StringBuilder res = new StringBuilder();  // variable to store the result
        for(int i = 0; i < n + m; i++){  // iterate through the result
            if(result[i] == 0 && res.length() == 0){  // if the current value is zero and the result is empty
                continue;  // continue
            }
            res.append(result[i]);  // update the result
        }
        return res.toString();  // return the result
    }
}







43. Multiply Strings in python using karatsuba algorithm








// Time Complexity : O(n * m) where n is the length of the first string and m is the length of the second string and space complexity is O(n + m)






class Solution(object):
    def multiply(self, num1, num2):
        """
        :type num1: str
        :type num2: str
        :rtype: str
        """
        n = len(num1)  # variable to store the length of the first string
        m = len(num2)  # variable to store the length of the second string

        if num1 == "0" or num2 == "0":  # if any of the strings is zero
            return "0"  # return zero

        result = [0] * (n + m)  # list to store the result
        for i in range(n - 1, -1, -1):  # iterate through the first string
            for j in range(m - 1, -1, -1):  # iterate through the second string
                product = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))  # variable to store the product
                sum = product + result[i + j + 1]  # variable to store the sum
                result[i + j + 1] = sum % 10  # update the result
                result[i + j] += sum // 10  # update the result

        res = ""  # variable to store the result
        for i in range(n + m):  # iterate through the result
            if result[i] == 0 and len(res) == 0:  # if the current value is zero and the result is empty
                continue  # continue
            res += str(result[i])  # update the result
        return res  # return the result









43. Multiply Strings in python3 using karatsuba algorithm








// Time Complexity : O(n * m) where n is the length of the first string and m is the length of the second string and space complexity is O(n + m)







class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        n = len(num1)  # variable to store the length of the first string
        m = len(num2)  # variable to store the length of the second string

        if num1 == "0" or num2 == "0":  # if any of the strings is zero
            return "0"  # return zero

        result = [0] * (n + m)  # list to store the result
        for i in range(n - 1, -1, -1):  # iterate through the first string
            for j in range(m - 1, -1, -1):  # iterate through the second string
                product = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))  # variable to store the product
                sum = product + result[i + j + 1]  # variable to store the sum
                result[i + j + 1] = sum % 10  # update the result
                result[i + j] += sum // 10  # update the result

        res = ""  # variable to store the result
        for i in range(n + m):  # iterate through the result
            if result[i] == 0 and len(res) == 0:  # if the current value is zero and the result is empty
                continue  # continue
            res += str(result[i])  # update the result
        return res  # return the result











43. Multiply Strings in c using karatsuba algorithm








// Time Complexity : O(n * m) where n is the length of the first string and m is the length of the second string and space complexity is O(n + m)












char * multiply(char * num1, char * num2){
    int n = strlen(num1);  // variable to store the length of the first string
    int m = strlen(num2);  // variable to store the length of the second string

    if(strcmp(num1, "0") == 0 || strcmp(num2, "0") == 0){  // if any of the strings is zero
        return "0";  // return zero
    }

    int * result = (int *)malloc(sizeof(int) * (n + m));  // array to store the result
    for(int i = n - 1; i >= 0; i--){  // iterate through the first string
        for(int j = m - 1; j >= 0; j--){  // iterate through the second string
            int product = (num1[i] - '0') * (num2[j] - '0');  // variable to store the product
            int sum = product + result[i + j + 1];  // variable to store the sum
            result[i + j + 1] = sum % 10;  // update the result
            result[i + j] += sum / 10;  // update the result
        }
    }
    
    char * res = (char *)malloc(sizeof(char) * (n + m + 1));  // variable to store the result
    int index = 0;  // variable to store the index
    for(int i = 0; i < n + m; i++){  // iterate through the result
        if(result[i] == 0 && index == 0){  // if the current value is zero and the result is empty
            continue;  // continue
        }
        res[index++] = result[i] + '0';  // update the result
    }
    res[index] = '\0';  // update the result
    return res;  // return the result
}








43. Multiply Strings in c# using karatsuba algorithm








// Time Complexity : O(n * m) where n is the length of the first string and m is the length of the second string and space complexity is O(n + m)







public class Solution {
    public string Multiply(string num1, string num2) {
        int n = num1.Length;  // variable to store the length of the first string
        int m = num2.Length;  // variable to store the length of the second string

        if(num1 == "0" || num2 == "0"){  // if any of the strings is zero
            return "0";  // return zero
        }

        int[] result = new int[n + m];  // array to store the result
        for(int i = n - 1; i >= 0; i--){  // iterate through the first string
            for(int j = m - 1; j >= 0; j--){  // iterate through the second string
                int product = (num1[i] - '0') * (num2[j] - '0');  // variable to store the product
                int sum = product + result[i + j + 1];  // variable to store the sum
                result[i + j + 1] = sum % 10;  // update the result
                result[i + j] += sum / 10;  // update the result
            }
        }
        
        StringBuilder res = new StringBuilder();  // variable to store the result
        for(int i = 0; i < n + m; i++){  // iterate through the result
            if(result[i] == 0 && res.Length == 0){  // if the current value is zero and the result is empty
                continue;  // continue
            }
            res.Append(result[i]);  // update the result
        }
        return res.ToString();  // return the result
    }
}










43. Multiply Strings in javascript using karatsuba algorithm








// Time Complexity : O(n * m) where n is the length of the first string and m is the length of the second string and space complexity is O(n + m)











/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */


var multiply = function(num1, num2) {
    let n = num1.length;  // variable to store the length of the first string
    let m = num2.length;  // variable to store the length of the second string

    if(num1 == "0" || num2 == "0"){  // if any of the strings is zero
        return "0";  // return zero
    }

    let result = new Array(n + m).fill(0);  // array to store the result
    for(let i = n - 1; i >= 0; i--){  // iterate through the first string
        for(let j = m - 1; j >= 0; j--){  // iterate through the second string
            let product = (num1[i] - '0') * (num2[j] - '0');  // variable to store the product
            let sum = product + result[i + j + 1];  // variable to store the sum
            result[i + j + 1] = sum % 10;  // update the result
            result[i + j] += Math.floor(sum / 10);  // update the result
        }
    }
    
    let res = "";  // variable to store the result
    for(let i = 0; i < n + m; i++){  // iterate through the result
        if(result[i] == 0 && res.length == 0){  // if the current value is zero and the result is empty
            continue;  // continue
        }
        res += result[i];  // update the result
    }
    return res;  // return the result
};




2nd Method 



/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var multiply = function(num1, num2) {
     return (BigInt(num1)*BigInt(num2)).toString();

};








43. Multiply Strings in Swift using karatsuba algorithm








// Time Complexity : O(n * m) where n is the length of the first string and m is the length of the second string and space complexity is O(n + m)







class Solution {
    func multiply(_ num1: String, _ num2: String) -> String {
        let n = num1.count  // variable to store the length of the first string
        let m = num2.count  // variable to store the length of the second string

        if num1 == "0" || num2 == "0" {  // if any of the strings is zero
            return "0"  // return zero
        }

        var result = Array(repeating: 0, count: n + m)  // array to store the result
        for i in stride(from: n - 1, through: 0, by: -1) {  // iterate through the first string
            for j in stride(from: m - 1, through: 0, by: -1) {  // iterate through the second string
                let index1 = num1.index(num1.startIndex, offsetBy: i)
                let index2 = num2.index(num2.startIndex, offsetBy: j)
                
                let digit1 = Int(String(num1[index1]))!
                let digit2 = Int(String(num2[index2]))!
                
                let product = digit1 * digit2  // variable to store the product
                let sum = product + result[i + j + 1]  // variable to store the sum
                result[i + j + 1] = sum % 10  // update the result
                result[i + j] += sum / 10  // update the result
            }
        }
        
        var res = ""  // variable to store the result
        for i in 0..<n + m {  // iterate through the result
            if result[i] == 0 && res.isEmpty {  // if the current value is zero and the result is empty
                continue  // continue
            }
            res += String(result[i])  // update the result
        }
        return res  // return the result
    }
}









44. Wildcard Matching in c++



// Time Complexity : O(m * n) where m is the length of the string and n is the length of the pattern and space complexity is O(m * n)



class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.length();  // variable to store the length of the string
        int n = p.length();  // variable to store the length of the pattern
        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));  // 2d vector to store the dp values
        dp[0][0] = true;  // update the dp value
        for(int i = 1; i <= n; i++){  // iterate through the pattern
            if(p[i - 1] == '*'){  // if the current character is '*'
                dp[0][i] = dp[0][i - 1];  // update the dp value
            }
        }
        for(int i = 1; i <= m; i++){  // iterate through the string
            for(int j = 1; j <= n; j++){  // iterate through the pattern
                if(p[j - 1] == '*'){  // if the current character is '*'
                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];  // update the dp value
                }
                else if(p[j - 1] == '?' || s[i - 1] == p[j - 1]){  // if the current character is '?' or the current character of the string is equal to the current character of the pattern
                    dp[i][j] = dp[i - 1][j - 1];  // update the dp value
                }
            }
        }
        return dp[m][n];  // return the dp value
    }
};



44. Wildcard Matching in java



// Time Complexity : O(m * n) where m is the length of the string and n is the length of the pattern and space complexity is O(m * n)





class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length();  // variable to store the length of the string
        int n = p.length();  // variable to store the length of the pattern
        boolean[][] dp = new boolean[m + 1][n + 1];  // 2d array to store the dp values
        dp[0][0] = true;  // update the dp value
        for(int i = 1; i <= n; i++){  // iterate through the pattern
            if(p.charAt(i - 1) == '*'){  // if the current character is '*'
                dp[0][i] = dp[0][i - 1];  // update the dp value
            }
        }
        for(int i = 1; i <= m; i++){  // iterate through the string
            for(int j = 1; j <= n; j++){  // iterate through the pattern
                if(p.charAt(j - 1) == '*'){  // if the current character is '*'
                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];  // update the dp value
                }
                else if(p.charAt(j - 1) == '?' || s.charAt(i - 1) == p.charAt(j - 1)){  // if the current character is '?' or the current character of the string is equal to the current character of the pattern
                    dp[i][j] = dp[i - 1][j - 1];  // update the dp value
                }
            }
        }
        return dp[m][n];  // return the dp value
    }
}





44. Wildcard Matching in python






// Time Complexity : O(m * n) where m is the length of the string and n is the length of the pattern and space complexity is O(m * n)







class Solution(object):
    def isMatch(self, s, p):
        m = len(s)  # variable to store the length of the string
        n = len(p)  # variable to store the length of the pattern
        dp = [[False for i in range(n + 1)] for j in range(m + 1)]  # 2d array to store the dp values
        dp[0][0] = True  # update the dp value
        for i in range(1, n + 1):  # iterate through the pattern
            if p[i - 1] == '*':  # if the current character is '*'
                dp[0][i] = dp[0][i - 1]  # update the dp value
        for i in range(1, m + 1):  # iterate through the string
            for j in range(1, n + 1):  # iterate through the pattern
                if p[j - 1] == '*':  # if the current character is '*'
                    dp[i][j] = dp[i - 1][j] or dp[i][j - 1]  # update the dp value
                elif p[j - 1] == '?' or s[i - 1] == p[j - 1]:  # if the current character is '?' or the current character of the string is equal to the current character of the pattern
                    dp[i][j] = dp[i - 1][j - 1]  # update the dp value
        return dp[m][n]  # return the dp value











44. Wildcard Matching in python3






// Time Complexity : O(m * n) where m is the length of the string and n is the length of the pattern and space complexity is O(m * n)







class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        m = len(s)  # variable to store the length of the string
        n = len(p)  # variable to store the length of the pattern
        dp = [[False for i in range(n + 1)] for j in range(m + 1)]  # 2d array to store the dp values
        dp[0][0] = True  # update the dp value
        for i in range(1, n + 1):  # iterate through the pattern
            if p[i - 1] == '*':  # if the current character is '*'
                dp[0][i] = dp[0][i - 1]  # update the dp value
        for i in range(1, m + 1):  # iterate through the string
            for j in range(1, n + 1):  # iterate through the pattern
                if p[j - 1] == '*':  # if the current character is '*'
                    dp[i][j] = dp[i - 1][j] or dp[i][j - 1]  # update the dp value
                elif p[j - 1] == '?' or s[i - 1] == p[j - 1]:  # if the current character is '?' or the current character of the string is equal to the current character of the pattern
                    dp[i][j] = dp[i - 1][j - 1]  # update the dp value
        return dp[m][n]  # return the dp value





44. Wildcard Matching in c







// Time Complexity : O(m * n) where m is the length of the string and n is the length of the pattern and space complexity is O(m * n)










bool isMatch(char * s, char * p){
    int m = strlen(s);  // variable to store the length of the string
    int n = strlen(p);  // variable to store the length of the pattern
    bool dp[m + 1][n + 1];  // 2d array to store the dp values
    memset(dp, false, sizeof(dp));  // update the dp value
    dp[0][0] = true;  // update the dp value
    for(int i = 1; i <= n; i++){  // iterate through the pattern
        if(p[i - 1] == '*'){  // if the current character is '*'
            dp[0][i] = dp[0][i - 1];  // update the dp value
        }
    }
    for(int i = 1; i <= m; i++){  // iterate through the string
        for(int j = 1; j <= n; j++){  // iterate through the pattern
            if(p[j - 1] == '*'){  // if the current character is '*'
                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];  // update the dp value
            }
            else if(p[j - 1] == '?' || s[i - 1] == p[j - 1]){  // if the current character is '?' or the current character of the string is equal to the current character of the pattern
                dp[i][j] = dp[i - 1][j - 1];  // update the dp value
            }
        }
    }
    return dp[m][n];  // return the dp value
}







44. Wildcard Matching in c#








// Time Complexity : O(m * n) where m is the length of the string and n is the length of the pattern and space complexity is O(m * n)










public class Solution {
    public bool IsMatch(string s, string p) {
        int m = s.Length;  // variable to store the length of the string
        int n = p.Length;  // variable to store the length of the pattern
        bool[,] dp = new bool[m + 1, n + 1];  // 2d array to store the dp values
        dp[0, 0] = true;  // update the dp value
        for(int i = 1; i <= n; i++){  // iterate through the pattern
            if(p[i - 1] == '*'){  // if the current character is '*'
                dp[0, i] = dp[0, i - 1];  // update the dp value
            }
        }
        for(int i = 1; i <= m; i++){  // iterate through the string
            for(int j = 1; j <= n; j++){  // iterate through the pattern
                if(p[j - 1] == '*'){  // if the current character is '*'
                    dp[i, j] = dp[i - 1, j] || dp[i, j - 1];  // update the dp value
                }
                else if(p[j - 1] == '?' || s[i - 1] == p[j - 1]){  // if the current character is '?' or the current character of the string is equal to the current character of the pattern
                    dp[i, j] = dp[i - 1, j - 1];  // update the dp value
                }
            }
        }
        return dp[m, n];  // return the dp value
    }
}










44. Wildcard Matching in javascript








// Time Complexity : O(m * n) where m is the length of the string and n is the length of the pattern and space complexity is O(m * n)











/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */



var isMatch = function(s, p) {
    let m = s.length;  // variable to store the length of the string
    let n = p.length;  // variable to store the length of the pattern
    let dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(false));  // 2d array to store the dp values
    dp[0][0] = true;  // update the dp value
    for(let i = 1; i <= n; i++){  // iterate through the pattern
        if(p[i - 1] == '*'){  // if the current character is '*'
            dp[0][i] = dp[0][i - 1];  // update the dp value
        }
    }
    for(let i = 1; i <= m; i++){  // iterate through the string
        for(let j = 1; j <= n; j++){  // iterate through the pattern
            if(p[j - 1] == '*'){  // if the current character is '*'
                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];  // update the dp value
            }
            else if(p[j - 1] == '?' || s[i - 1] == p[j - 1]){  // if the current character is '?' or the current character of the string is equal to the current character of the pattern
                dp[i][j] = dp[i - 1][j - 1];  // update the dp value
            }
        }
    }
    return dp[m][n];  // return the dp value
};









44. Wildcard Matching in Swift









// Time Complexity : O(m * n) where m is the length of the string and n is the length of the pattern and space complexity is O(m * n)










class Solution {
    func isMatch(_ s: String, _ p: String) -> Bool {
        var memo = [[Bool?]](repeating: [Bool?](repeating: nil, count: p.count + 1), count: s.count + 1)
        return isMatchHelper(Array(s), Array(p), 0, 0, &memo)
    }
    
    func isMatchHelper(_ s: [Character], _ p: [Character], _ i: Int, _ j: Int, _ memo: inout [[Bool?]]) -> Bool {
        if let cachedResult = memo[i][j] {
            return cachedResult
        }
        
        if j == p.count {
            memo[i][j] = i == s.count
            return memo[i][j]!
        }
        
        var result = false
        if i < s.count {
            if p[j] == s[i] || p[j] == "?" {
                result = isMatchHelper(s, p, i + 1, j + 1, &memo)
            } else if p[j] == "*" {
                result = isMatchHelper(s, p, i + 1, j, &memo) || isMatchHelper(s, p, i, j + 1, &memo)
            }
        } else if p[j] == "*" {
            result = isMatchHelper(s, p, i, j + 1, &memo)
        }
        
        memo[i][j] = result
        return result
    }
}



2nd Method 



class Solution {
    func isMatch(_ s: String, _ p: String) -> Bool {
    var s = Array(s)
        var p = Array(p)
        var dp = [[Bool]](repeating: [Bool](repeating: false, count: s.count+1), count: p.count+1)

        for i in 0...p.count{
            for j in 0...s.count {
                if i == 0 && j == 0 {
                    dp[i][j] = true
                } else if i == 0 {
                    dp[i][j] = false
                } else if j == 0 {
                    if p[i-1] == "*" {
                        dp[i][j] = dp[i-1][j]
                    } else {
                        dp[i][j] = false
                    }
                } else {
                    if p[i-1] == "*" {
                        dp[i][j] = dp[i][j-1] || dp[i-1][j-1] || dp[i-1][j]
                    } else if p[i-1] == s[j-1] || p[i-1] == "?" {
                        dp[i][j] = dp[i-1][j-1] 
                    } else {
                        dp[i][j] = false
                    }
                }
            }
        }
        return dp[p.count][s.count]
    }
}
 





45. Jump Game II in c++

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size();  // variable to store the length of the vector nums
        int res = 0;  // variable to store the result
        int i = 0;  // variable to store the start index of the window
        int j = 0;  // variable to store the end index of the window
        while(j < n - 1){  // while the end index of the window is less than the length of the vector nums
            int maxIndex = j;  // variable to store the maximum index
            for(int k=i; k<=j; k++){  // for each element in the window
                maxIndex = max(maxIndex, k + nums[k]);  // update the maximum index 
            }
            i = j + 1;  // update the start index of the window
            j = maxIndex;  // update the end index of the window
            res++;  // increment the result
        }
        return res;  // return the result
    }
};

45. Jump Game II in Java

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
    public int jump(int[] nums) {
        int n = nums.length;  // variable to store the length of the vector nums
        int res = 0;  // variable to store the result
        int i = 0;  // variable to store the start index of the window
        int j = 0;  // variable to store the end index of the window
        while(j < n - 1){  // while the end index of the window is less than the length of the vector nums
            int maxIndex = j;  // variable to store the maximum index
            for(int k=i; k<=j; k++){  // for each element in the window
                maxIndex = Math.max(maxIndex, k + nums[k]);  // update the maximum index
            }
            i = j + 1;  // update the start index of the window
            j = maxIndex;  // update the end index of the window
            res++;  // increment the result
        }
        return res;  // return the result
    }
}


45. Jump Game II in python

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution(object):
    def jump(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums)  # variable to store the length of the vector nums
        res = 0  # variable to store the result
        i = 0  # variable to store the start index of the window
        j = 0  # variable to store the end index of the window
        while(j < n - 1):  # while the end index of the window is less than the length of the vector nums
            maxIndex = j  # variable to store the maximum index
            for k in range(i, j + 1):  # for each element in the window
                maxIndex = max(maxIndex, k + nums[k])  # update the maximum index
            i = j + 1  # update the start index of the window
            j = maxIndex  # update the end index of the window
            res += 1  # increment the result
        return res  # return the result


45. Jump Game II in python3


// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)  # variable to store the length of the vector nums
        res = 0  # variable to store the result
        i = 0  # variable to store the start index of the window
        j = 0  # variable to store the end index of the window
        while(j < n - 1):  # while the end index of the window is less than the length of the vector nums
            maxIndex = j  # variable to store the maximum index
            for k in range(i, j + 1):  # for each element in the window
                maxIndex = max(maxIndex, k + nums[k])  # update the maximum index
            i = j + 1  # update the start index of the window
            j = maxIndex  # update the end index of the window
            res += 1  # increment the result
        return res  # return the result


45. Jump Game II in c

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

int jump(int* nums, int numsSize){
    int n = numsSize;  // variable to store the length of the vector nums
    int res = 0;  // variable to store the result
    int i = 0;  // variable to store the start index of the window
    int j = 0;  // variable to store the end index of the window
    while(j < n - 1){  // while the end index of the window is less than the length of the vector nums
        int maxIndex = j;  // variable to store the maximum index
        for(int k=i; k<=j; k++){  // for each element in the window
            maxIndex = fmax(maxIndex, k + nums[k]);  // update the maximum index
        }
        i = j + 1;  // update the start index of the window
        j = maxIndex;  // update the end index of the window
        res++;  // increment the result
    }
    return res;  // return the result
}

45. Jump Game II in c#

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

public class Solution {
    public int Jump(int[] nums) {
        int n = nums.Length;  // variable to store the length of the vector nums
        int res = 0;  // variable to store the result
        int i = 0;  // variable to store the start index of the window
        int j = 0;  // variable to store the end index of the window
        while(j < n - 1){  // while the end index of the window is less than the length of the vector nums
            int maxIndex = j;  // variable to store the maximum index
            for(int k=i; k<=j; k++){  // for each element in the window
                maxIndex = Math.Max(maxIndex, k + nums[k]);  // update the maximum index
            }
            i = j + 1;  // update the start index of the window
            j = maxIndex;  // update the end index of the window
            res++;  // increment the result
        }
        return res;  // return the result
    }
}

45. Jump Game II in javascript

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

var jump = function(nums) {
    let n = nums.length;  // variable to store the length of the vector nums
    let res = 0;  // variable to store the result
    let i = 0;  // variable to store the start index of the window
    let j = 0;  // variable to store the end index of the window
    while(j < n - 1){  // while the end index of the window is less than the length of the vector nums
        let maxIndex = j;  // variable to store the maximum index
        for(let k=i; k<=j; k++){  // for each element in the window
            maxIndex = Math.max(maxIndex, k + nums[k]);  // update the maximum index
        }
        i = j + 1;  // update the start index of the window
        j = maxIndex;  // update the end index of the window
        res++;  // increment the result
    }
    return res;  // return the result
};

45. Jump Game II in Swift

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
    func jump(_ nums: [Int]) -> Int {
        let n = nums.count;  // variable to store the length of the vector nums
        var res = 0;  // variable to store the result
        var i = 0;  // variable to store the start index of the window
        var j = 0;  // variable to store the end index of the window
        while(j < n - 1){  // while the end index of the window is less than the length of the vector nums
            var maxIndex = j;  // variable to store the maximum index
            for k in i...j{  // for each element in the window
                maxIndex = max(maxIndex, k + nums[k]);  // update the maximum index
            }
            i = j + 1;  // update the start index of the window
            j = maxIndex;  // update the end index of the window
            res += 1;  // increment the result
        }
        return res;  // return the result
    }
}


46. Permutations

// Time Complexity : O(n!) where n is the length of the vector nums and space complexity is O(n)

class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;  // vector to store the result
        vector<int> temp;  // vector to store the temporary result
        vector<bool> visited(nums.size(), false);  // vector to store the visited values
        permuteHelper(nums, res, temp, visited);  // call the function to find the permutations
        return res;  // return the result
    }
    
    void permuteHelper(vector<int>& nums, vector<vector<int>>& res, vector<int>& temp, vector<bool>& visited){
        if(temp.size() == nums.size()){  // if the size of the temporary result is equal to the size of the vector nums
            res.push_back(temp);  // push the temporary result into the result
            return;  // return
        }
        for(int i = 0; i < nums.size(); i++){  // iterate through the vector nums
            if(visited[i]){  // if the current value is visited
                continue;  // continue
            }
            visited[i] = true;  // update the visited value
            temp.push_back(nums[i]);  // push the current value into the temporary result
            permuteHelper(nums, res, temp, visited);  // call the function to find the permutations
            temp.pop_back();  // pop the current value from the temporary result
            visited[i] = false;  // update the visited value
        }
    }
};

46. Permutations in Java

// Time Complexity : O(n!) where n is the length of the vector nums and space complexity is O(n)

class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();  // list to store the result
        List<Integer> temp = new ArrayList<>();  // list to store the temporary result
        boolean[] visited = new boolean[nums.length];  // array to store the visited values
        permuteHelper(nums, res, temp, visited);  // call the function to find the permutations
        return res;  // return the result
    }
    
    public void permuteHelper(int[] nums, List<List<Integer>> res, List<Integer> temp, boolean[] visited){
        if(temp.size() == nums.length){  // if the size of the temporary result is equal to the size of the vector nums
            res.add(new ArrayList<>(temp));  // push the temporary result into the result
            return;  // return
        }
        for(int i = 0; i < nums.length; i++){  // iterate through the vector nums
            if(visited[i]){  // if the current value is visited
                continue;  // continue
            }
            visited[i] = true;  // update the visited value
            temp.add(nums[i]);  // push the current value into the temporary result
            permuteHelper(nums, res, temp, visited);  // call the function to find the permutations
            temp.remove(temp.size() - 1);  // pop the current value from the temporary result
            visited[i] = false;  // update the visited value
        }
    }
}

46. Permutations in python

// Time Complexity : O(n!) where n is the length of the vector nums and space complexity is O(n)

class Solution(object):
    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """ 
        res = []  # list to store the result
        temp = []  # list to store the temporary result
        visited = [False] * len(nums)  # array to store the visited values
        self.permuteHelper(nums, res, temp, visited)  # call the function to find the permutations
        return res  # return the result
    
    def permuteHelper(self, nums, res, temp, visited):
        if len(temp) == len(nums):  # if the size of the temporary result is equal to the size of the vector nums
            res.append(temp[:])  # push the temporary result into the result
            return  # return
        for i in range(len(nums)):  # iterate through the vector nums
            if visited[i]:  # if the current value is visited
                continue  # continue
            visited[i] = True  # update the visited value
            temp.append(nums[i])  # push the current value into the temporary result
            self.permuteHelper(nums, res, temp, visited)  # call the function to find the permutations
            temp.pop()  # pop the current value from the temporary result
            visited[i] = False  # update the visited value
    
46. Permutations in python3

// Time Complexity : O(n!) where n is the length of the vector nums and space complexity is O(n)

class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []  # list to store the result
        temp = []  # list to store the temporary result
        visited = [False] * len(nums)  # array to store the visited values
        self.permuteHelper(nums, res, temp, visited)  # call the function to find the permutations
        return res  # return the result
    
    def permuteHelper(self, nums, res, temp, visited):
        if len(temp) == len(nums):  # if the size of the temporary result is equal to the size of the vector nums
            res.append(temp[:])  # push the temporary result into the result
            return  # return
        for i in range(len(nums)):  # iterate through the vector nums
            if visited[i]:  # if the current value is visited
                continue  # continue
            visited[i] = True  # update the visited value
            temp.append(nums[i])  # push the current value into the temporary result
            self.permuteHelper(nums, res, temp, visited)  # call the function to find the permutations
            temp.pop()  # pop the current value from the temporary result
            visited[i] = False  # update the visited value

46. Permutations in c

// Time Complexity : O(n!) where n is the length of the vector nums and space complexity is O(n)

void permuteHelper(int* nums, int numsSize, int** res, int* returnSize, int* temp, bool* visited, int index){
    if(index == numsSize){  // if the size of the temporary result is equal to the size of the vector nums
        res[*returnSize] = (int*)malloc(sizeof(int) * numsSize);  // push the temporary result into the result
        memcpy(res[*returnSize], temp, sizeof(int) * numsSize);  // push the temporary result into the result
        (*returnSize)++;  // increment the result
        return;  // return
    }
    for(int i = 0; i < numsSize; i++){  // iterate through the vector nums
        if(visited[i]){  // if the current value is visited
            continue;  // continue
        }
        visited[i] = true;  // update the visited value
        temp[index] = nums[i];  // push the current value into the temporary result
        permuteHelper(nums, numsSize, res, returnSize, temp, visited, index + 1);  // call the function to find the permutations
        visited[i] = false;  // update the visited value
    }
}

int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    int** res = (int**)malloc(sizeof(int*) * 10000);  // vector to store the result
    int* temp = (int*)malloc(sizeof(int) * numsSize);  // vector to store the temporary result
    bool* visited = (bool*)malloc(sizeof(bool) * numsSize);  // array to store the visited values
    memset(visited, false, sizeof(bool) * numsSize);  // update the visited value
    *returnSize = 0;  // update the result
    permuteHelper(nums, numsSize, res, returnSize, temp, visited, 0);  // call the function to find the permutations
    *returnColumnSizes = (int*)malloc(sizeof(int) * (*returnSize));  // vector to store the result
    for(int i = 0; i < *returnSize; i++){  // iterate through the vector nums
        (*returnColumnSizes)[i] = numsSize;  // update the result
    }
    return res;  // return the result
}

46. Permutations in c#

// Time Complexity : O(n!) where n is the length of the vector nums and space complexity is O(n)

public class Solution {
    public IList<IList<int>> Permute(int[] nums) {
        IList<IList<int>> res = new List<IList<int>>();  // list to store the result
        List<int> temp = new List<int>();  // list to store the temporary result
        bool[] visited = new bool[nums.Length];  // array to store the visited values
        permuteHelper(nums, res, temp, visited);  // call the function to find the permutations
        return res;  // return the result
    }
    
    public void permuteHelper(int[] nums, IList<IList<int>> res, List<int> temp, bool[] visited){
        if(temp.Count == nums.Length){  // if the size of the temporary result is equal to the size of the vector nums
            res.Add(new List<int>(temp));  // push the temporary result into the result
            return;  // return
        }
        for(int i = 0; i < nums.Length; i++){  // iterate through the vector nums
            if(visited[i]){  // if the current value is visited
                continue;  // continue
            }
            visited[i] = true;  // update the visited value
            temp.Add(nums[i]);  // push the current value into the temporary result
            permuteHelper(nums, res, temp, visited);  // call the function to find the permutations
            temp.RemoveAt(temp.Count - 1);  // pop the current value from the temporary result
            visited[i] = false;  // update the visited value
        }
    }
}

46. Permutations in javascript

// Time Complexity : O(n!) where n is the length of the vector nums and space complexity is O(n)

var permute = function(nums) {
    let res = [];  // list to store the result
    let temp = [];  // list to store the temporary result
    let visited = new Array(nums.length).fill(false);  // array to store the visited values
    permuteHelper(nums, res, temp, visited);  // call the function to find the permutations
    return res;  // return the result
};

var permuteHelper = function(nums, res, temp, visited){
    if(temp.length == nums.length){  // if the size of the temporary result is equal to the size of the vector nums
        res.push(temp.slice());  // push the temporary result into the result
        return;  // return
    }
    for(let i = 0; i < nums.length; i++){  // iterate through the vector nums
        if(visited[i]){  // if the current value is visited
            continue;  // continue
        }
        visited[i] = true;  // update the visited value
        temp.push(nums[i]);  // push the current value into the temporary result
        permuteHelper(nums, res, temp, visited);  // call the function to find the permutations
        temp.pop();  // pop the current value from the temporary result
        visited[i] = false;  // update the visited value
    }
};

46. Permutations in Swift

// Time Complexity : O(n!) where n is the length of the vector nums and space complexity is O(n)

class Solution {
    func permute(_ nums: [Int]) -> [[Int]] {
        var res = [[Int]]();  // list to store the result
        var temp = [Int]();  // list to store the temporary result
        var visited = [Bool](repeating: false, count: nums.count);  // array to store the visited values
        permuteHelper(nums, &res, &temp, &visited);  // call the function to find the permutations
        return res;  // return the resul
    }
    
    func permuteHelper(_ nums: [Int], _ res: inout [[Int]], _ temp: inout [Int], _ visited: inout [Bool]){
        if(temp.count == nums.count){  // if the size of the temporary result is equal to the size of the vector nums
            res.append(temp);  // push the temporary result into the result
            return;  // return
        }
        for i in 0..<nums.count{  // iterate through the vector nums
            if(visited[i]){  // if the current value is visited
                continue;  // continue
            }
            visited[i] = true;  // update the visited value
            temp.append(nums[i]);  // push the current value into the temporary result
            permuteHelper(nums, &res, &temp, &visited);  // call the function to find the permutations
            temp.removeLast();  // pop the current value from the temporary result
            visited[i] = false;  // update the visited value
        }
    }
}



47. Permutations II

// Time Complexity : O(n!) where n is the length of the vector nums and space complexity is O(n)

class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        vector<vector<int>> res;  // vector to store the result
        vector<int> temp;  // vector to store the temporary result
        vector<bool> visited(nums.size(), false);  // vector to store the visited values
        sort(nums.begin(), nums.end());  // sort the vector nums
        permuteHelper(nums, res, temp, visited);  // call the function to find the permutations
        return res;  // return the result
    }
    
    void permuteHelper(vector<int>& nums, vector<vector<int>>& res, vector<int>& temp, vector<bool>& visited){
        if(temp.size() == nums.size()){  // if the size of the temporary result is equal to the size of the vector nums
            res.push_back(temp);  // push the temporary result into the result
            return;  // return
        }
        for(int i = 0; i < nums.size(); i++){  // iterate through the vector nums
            if(visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])){  // if the current value is visited or the current value is equal to the previous value and the previous value is not visited
                continue;  // continue
            }
            visited[i] = true;  // update the visited value
            temp.push_back(nums[i]);  // push the current value into the temporary result
            permuteHelper(nums, res, temp, visited);  // call the function to find the permutations
            temp.pop_back();  // pop the current value from the temporary result
            visited[i] = false;  // update the visited value
        }
    }
};


47. Permutations II in Java

// Time Complexity : O(n!) where n is the length of the vector nums and space complexity is O(n)

class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();  // list to store the result
        List<Integer> temp = new ArrayList<>();  // list to store the temporary result
        boolean[] visited = new boolean[nums.length];  // array to store the visited values
        Arrays.sort(nums);  // sort the vector nums
        permuteHelper(nums, res, temp, visited);  // call the function to find the permutations
        return res;  // return the result
    }
    
    public void permuteHelper(int[] nums, List<List<Integer>> res, List<Integer> temp, boolean[] visited){
        if(temp.size() == nums.length){  // if the size of the temporary result is equal to the size of the vector nums
            res.add(new ArrayList<>(temp));  // push the temporary result into the result
            return;  // return
        }
        for(int i = 0; i < nums.length; i++){  // iterate through the vector nums
            if(visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])){  // if the current value is visited or the current value is equal to the previous value and the previous value is not visited
                continue;  // continue
            }
            visited[i] = true;  // update the visited value
            temp.add(nums[i]);  // push the current value into the temporary result
            permuteHelper(nums, res, temp, visited);  // call the function to find the permutations
            temp.remove(temp.size() - 1);  // pop the current value from the temporary result
            visited[i] = false;  // update the visited value
        }
    }
}

47. Permutations II in python

// Time Complexity : O(n!) where n is the length of the vector nums and space complexity is O(n)

class Solution(object):
    def permuteUnique(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """ 
        res = []  # list to store the result
        temp = []  # list to store the temporary result
        visited = [False] * len(nums)  # array to store the visited values
        nums.sort()  # sort the vector nums
        self.permuteHelper(nums, res, temp, visited)  # call the function to find the permutations
        return res  # return the result
    
    def permuteHelper(self, nums, res, temp, visited):
        if len(temp) == len(nums):  # if the size of the temporary result is equal to the size of the vector nums
            res.append(temp[:])  # push the temporary result into the result
            return  # return
        for i in range(len(nums)):  # iterate through the vector nums
            if visited[i] or (i > 0 and nums[i] == nums[i - 1] and not visited[i - 1]):  # if the current value is visited or the current value is equal to the previous value and the previous value is not visited
                continue  # continue
            visited[i] = True  # update the visited value
            temp.append(nums[i])  # push the current value into the temporary result
            self.permuteHelper(nums, res, temp, visited)  # call the function to find the permutations
            temp.pop()  # pop the current value from the temporary result
            visited[i] = False  # update the visited value

47. Permutations II in python3

// Time Complexity : O(n!) where n is the length of the vector nums and space complexity is O(n)

class Solution:
    def permuteUnique(self, nums: List[int) -> List[List[int]]: // add the missing bracket after int
        res = []  # list to store the result
        temp = []  # list to store the temporary result
        visited = [False] * len(nums)  # array to store the visited values
        nums.sort()  # sort the vector nums
        self.permuteHelper(nums, res, temp, visited)  # call the function to find the permutations
        return res  # return the result
    
    def permuteHelper(self, nums, res, temp, visited):
        if len(temp) == len(nums):  # if the size of the temporary result is equal to the size of the vector nums
            res.append(temp[:])  # push the temporary result into the result
            return  # return
        for i in range(len(nums)):  # iterate through the vector nums
            if visited[i] or (i > 0 and nums[i] == nums[i - 1] and not visited[i - 1]):  # if the current value is visited or the current value is equal to the previous value and the previous value is not visited
                continue  # continue
            visited[i] = True  # update the visited value
            temp.append(nums[i])  # push the current value into the temporary result
            self.permuteHelper(nums, res, temp, visited)  # call the function to find the permutations
            temp.pop()  # pop the current value from the temporary result
            visited[i] = False  # update the visited value

47. Permutations II in c

// Time Complexity : O(n!) where n is the length of the vector nums and space complexity is O(n)

void permuteHelper(int* nums, int numsSize, int** res, int* returnSize, int* temp, bool* visited, int index){
    if(index == numsSize){  // if the size of the temporary result is equal to the size of the vector nums
        res[*returnSize] = (int*)malloc(sizeof(int) * numsSize);  // push the temporary result into the result
        memcpy(res[*returnSize], temp, sizeof(int) * numsSize);  // push the temporary result into the result
        (*returnSize)++;  // increment the result
        return;  // return
    }
    for(int i = 0; i < numsSize; i++){  // iterate through the vector nums
        if(visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])){  // if the current value is visited or the current value is equal to the previous value and the previous value is not visited
            continue;  // continue
        }
        visited[i] = true;  // update the visited value
        temp[index] = nums[i];  // push the current value into the temporary result
        permuteHelper(nums, numsSize, res, returnSize, temp, visited, index + 1);  // call the function to find the permutations
        visited[i] = false;  // update the visited value
    }
}

int** permuteUnique(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    int** res = (int**)malloc(sizeof(int*) * 10000);  // vector to store the result
    int* temp = (int*)malloc(sizeof(int) * numsSize);  // vector to store the temporary result
    bool* visited = (bool*)malloc(sizeof(bool) * numsSize);  // array to store the visited values
    memset(visited, false, sizeof(bool) * numsSize);  // update the visited value
    *returnSize = 0;  // update the result
    qsort(nums, numsSize, sizeof(int), cmpfunc);  // sort the vector nums
    permuteHelper(nums, numsSize, res, returnSize, temp, visited, 0);  // call the function to find the permutations
    *returnColumnSizes = (int*)malloc(sizeof(int) * (*returnSize));  // vector to store the result
    for(int i = 0; i < *returnSize; i++){  // iterate through the vector nums
        (*returnColumnSizes)[i] = numsSize;  // update the result
    }
    return res;  // return the result
}

int cmpfunc(const void* a, const void* b){
    return (*(int*)a - *(int*)b);  // return the result
}

47. Permutations II in c#

// Time Complexity : O(n!) where n is the length of the vector nums and space complexity is O(n)

public class Solution {
    public IList<IList<int>> PermuteUnique(int[] nums) {
        IList<IList<int>> res = new List<IList<int>>();  // list to store the result
        List<int> temp = new List<int>();  // list to store the temporary result
        bool[] visited = new bool[nums.Length];  // array to store the visited values
        Array.Sort(nums);  // sort the vector nums
        permuteHelper(nums, res, temp, visited);  // call the function to find the permutations
        return res;  // return the result
    }
    
    public void permuteHelper(int[] nums, IList<IList<int>> res, List<int> temp, bool[] visited){
        if(temp.Count == nums.Length){  // if the size of the temporary result is equal to the size of the vector nums
            res.Add(new List<int>(temp));  // push the temporary result into the result
            return;  // return
        }
        for(int i = 0; i < nums.Length; i++){  // iterate through the vector nums
            if(visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])){  // if the current value is visited or the current value is equal to the previous value and the previous value is not visited
                continue;  // continue
            }
            visited[i] = true;  // update the visited value
            temp.Add(nums[i]);  // push the current value into the temporary result
            permuteHelper(nums, res, temp, visited);  // call the function to find the permutations
            temp.RemoveAt(temp.Count - 1);  // pop the current value from the temporary result
            visited[i] = false;  // update the visited value
        }
    }
}

47. Permutations II in javascript

// Time Complexity : O(n!) where n is the length of the vector nums and space complexity is O(n)

var permuteUnique = function(nums) {
    let res = [];  // list to store the result
    let temp = [];  // list to store the temporary result
    let visited = new Array(nums.length).fill(false);  // array to store the visited values
    nums.sort();  // sort the vector nums
    permuteHelper(nums, res, temp, visited);  // call the function to find the permutations
    return res;  // return the result
};

var permuteHelper = function(nums, res, temp, visited){
    if(temp.length == nums.length){  // if the size of the temporary result is equal to the size of the vector nums
        res.push(temp.slice());  // push the temporary result into the result
        return;  // return
    }
    for(let i = 0; i < nums.length; i++){  // iterate through the vector nums
        if(visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])){  // if the current value is visited or the current value is equal to the previous value and the previous value is not visited
            continue;  // continue
        }
        visited[i] = true;  // update the visited value
        temp.push(nums[i]);  // push the current value into the temporary result
        permuteHelper(nums, res, temp, visited);  // call the function to find the permutations
        temp.pop();  // pop the current value from the temporary result
        visited[i] = false;  // update the visited value
    }
};

47. Permutations II in Swift

// Time Complexity : O(n!) where n is the length of the vector nums and space complexity is O(n)

class Solution {
    func permuteUnique(_ nums: [Int]) -> [[Int]] {
        var res = [[Int]]()  // list to store the result
        var temp = [Int]()  // list to store the temporary result
        var visited = [Bool](repeating: false, count: nums.count)  // array to store the visited values
        let sortedNums = nums.sorted()  // Sort the input array in ascending order
        permuteHelper(sortedNums, &res, &temp, &visited)  // call the function to find the permutations
        return res  // return the result
    }
    
    func permuteHelper(_ nums: [Int], _ res: inout [[Int]], _ temp: inout [Int], _ visited: inout [Bool]) {
        if temp.count == nums.count {  // if the size of the temporary result is equal to the size of the vector nums
            res.append(temp)  // push the temporary result into the result
            return  // return
        }
        for i in 0..<nums.count {  // iterate through the vector nums
            if visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) {  // if the current value is visited or the current value is equal to the previous value and the previous value is not visited
                continue  // continue
            }
            visited[i] = true  // update the visited value
            temp.append(nums[i])  // push the current value into the temporary result
            permuteHelper(nums, &res, &temp, &visited)  // call the function to find the permutations
            temp.removeLast()  // pop the current value from the temporary result
            visited[i] = false  // update the visited value
        }
    }
}


48. Rotate Image

// Time Complexity : O(n^2) where n is the length of the vector matrix and space complexity is O(1)

class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();  // variable to store the length of the vector matrix
        for(int i = 0; i < n; i++){  // iterate through the vector matrix
            for(int j = i; j < n; j++){  // iterate through the vector matrix
                swap(matrix[i][j], matrix[j][i]);  // swap the values
            }
        }
        for(int i = 0; i < n; i++){  // iterate through the vector matrix
            reverse(matrix[i].begin(), matrix[i].end());  // reverse the vector
        }
    }
};

48. Rotate Image in Java

// Time Complexity : O(n^2) where n is the length of the vector matrix and space complexity is O(1)

class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;  // variable to store the length of the vector matrix
        for(int i = 0; i < n; i++){  // iterate through the vector matrix
            for(int j = i; j < n; j++){  // iterate through the vector matrix
                int temp = matrix[i][j];  // variable to store the temporary result
                matrix[i][j] = matrix[j][i];  // swap the values
                matrix[j][i] = temp;  // swap the values
            }
        }
        for(int i = 0; i < n; i++){  // iterate through the vector matrix
            for(int j = 0; j < n / 2; j++){  // iterate through the vector matrix
                int temp = matrix[i][j];  // variable to store the temporary result
                matrix[i][j] = matrix[i][n - j - 1];  // swap the values
                matrix[i][n - j - 1] = temp;  // swap the values
            }
        }
    }
}

48. Rotate Image in python

// Time Complexity : O(n^2) where n is the length of the vector matrix and space complexity is O(1)

class Solution(object):
    def rotate(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: None Do not return anything, modify matrix in-place instead.
        """ 
        n = len(matrix)  # variable to store the length of the vector matrix
        for i in range(n):  # iterate through the vector matrix
            for j in range(i, n):  # iterate through the vector matrix
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]  # swap the values
        for i in range(n):  # iterate through the vector matrix
            matrix[i].reverse()  # reverse the vector

48. Rotate Image in python3

// Time Complexity : O(n^2) where n is the length of the vector matrix and space complexity is O(1)

class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """ 
        n = len(matrix)  # variable to store the length of the vector matrix
        for i in range(n):  # iterate through the vector matrix
            for j in range(i, n):  # iterate through the vector matrix
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]  # swap the values
        for i in range(n):  # iterate through the vector matrix
            matrix[i].reverse()  # reverse the vector

48. Rotate Image in c

// Time Complexity : O(n^2) where n is the length of the vector matrix and space complexity is O(1)

void rotate(int** matrix, int matrixSize, int* matrixColSize){
    int n = matrixSize;  // variable to store the length of the vector matrix
    for(int i = 0; i < n; i++){  // iterate through the vector matrix
        for(int j = i; j < n; j++){  // iterate through the vector matrix
            int temp = matrix[i][j];  // variable to store the temporary result
            matrix[i][j] = matrix[j][i];  // swap the values
            matrix[j][i] = temp;  // swap the values
        }
    }
    for(int i = 0; i < n; i++){  // iterate through the vector matrix
        for(int j = 0; j < n / 2; j++){  // iterate through the vector matrix
            int temp = matrix[i][j];  // variable to store the temporary result
            matrix[i][j] = matrix[i][n - j - 1];  // swap the values
            matrix[i][n - j - 1] = temp;  // swap the values
        }
    }
}

48. Rotate Image in c#

// Time Complexity : O(n^2) where n is the length of the vector matrix and space complexity is O(1)

public class Solution {
    public void Rotate(int[][] matrix) {
        int n = matrix.Length;  // variable to store the length of the vector matrix
        for(int i = 0; i < n; i++){  // iterate through the vector matrix
            for(int j = i; j < n; j++){  // iterate through the vector matrix
                int temp = matrix[i][j];  // variable to store the temporary result
                matrix[i][j] = matrix[j][i];  // swap the values
                matrix[j][i] = temp;  // swap the values
            }
        }
        for(int i = 0; i < n; i++){  // iterate through the vector matrix
            for(int j = 0; j < n / 2; j++){  // iterate through the vector matrix
                int temp = matrix[i][j];  // variable to store the temporary result
                matrix[i][j] = matrix[i][n - j - 1];  // swap the values
                matrix[i][n - j - 1] = temp;  // swap the values
            }
        }
    }
}

48. Rotate Image in javascript

// Time Complexity : O(n^2) where n is the length of the vector matrix and space complexity is O(1)

var rotate = function(matrix) {
    let n = matrix.length;  // variable to store the length of the vector matrix
    for(let i = 0; i < n; i++){  // iterate through the vector matrix
        for(let j = i; j < n; j++){  // iterate through the vector matrix
            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];  // swap the values
        }
    }
    for(let i = 0; i < n; i++){  // iterate through the vector matrix
        for(let j = 0; j < n / 2; j++){  // iterate through the vector matrix
            [matrix[i][j], matrix[i][n - j - 1]] = [matrix[i][n - j - 1], matrix[i][j]];  // swap the values
        }
    }
};

48. Rotate Image in Swift

// Time Complexity : O(n^2) where n is the length of the vector matrix and space complexity is O(1)

class Solution {
    func rotate(_ matrix: inout [[Int]]) {
        let n = matrix.count;  // variable to store the length of the vector matrix
        for i in 0..<n {  // iterate through the vector matrix
            for j in i..<n {  // iterate through the vector matrix
                let temp = matrix[i][j];  // variable to store the temporary result
                matrix[i][j] = matrix[j][i];  // swap the values
                matrix[j][i] = temp;  // swap the values
            }
        }
        for i in 0..<n {  // iterate through the vector matrix
            for j in 0..<n / 2 {  // iterate through the vector matrix
                let temp = matrix[i][j];  // variable to store the temporary result
                matrix[i][j] = matrix[i][n - j - 1];  // swap the values
                matrix[i][n - j - 1] = temp;  // swap the values
            }
        }
    }
}


49. Group Anagrams in c++

// Time Complexity : O(n * klogk) where n is the length of the vector strs and k is the length of the string in the vector strs and space complexity is O(n)

class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> res;  // vector to store the result
        unordered_map<string, vector<string>> map;  // map to store the temporary result
        for(string s : strs){  // iterate through the vector strs
            string temp = s;  // variable to store the temporary result
            sort(temp.begin(), temp.end());  // sort the string
            map[temp].push_back(s);  // push the string into the map
        }
        for(auto m : map){  // iterate through the map
            res.push_back(m.second);  // push the temporary result into the result
        }
        return res;  // return the result
    }
};


49. Group Anagrams in Java

// Time Complexity : O(n * klogk) where n is the length of the vector strs and k is the length of the string in the vector strs and space complexity is O(n)

class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> res = new ArrayList<>();  // list to store the result
        Map<String, List<String>> map = new HashMap<>();  // map to store the temporary result
        for(String s : strs){  // iterate through the vector strs
            char[] temp = s.toCharArray();  // variable to store the temporary result
            Arrays.sort(temp);  // sort the string
            String sorted = new String(temp);  // variable to store the temporary result
            if(!map.containsKey(sorted)){  // if the map does not contain the key
                map.put(sorted, new ArrayList<>());  // push the temporary result into the map
            }
            map.get(sorted).add(s);  // push the temporary result into the map
        }
        for(Map.Entry<String, List<String>> m : map.entrySet()){  // iterate through the map
            res.add(m.getValue());  // push the temporary result into the result
        }
        return res;  // return the result
    }
}

2nd Method

class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<Integer>> res = new ArrayList<>();
        Map<String , List<String>> mp = new HashMap<>();
        for(String s : strs){
            char[] temp = s.toCharArray();
            Arrays.sort(temp);
            String sorted = new String(temp);
            if(!mp.containsKey(sorted)) mp.put(sorted , new ArrayList<>());
            mp.get(sorted).add(s);
        }
        return new ArrayList<>(mp.values());
    }
}

49. Group Anagrams in python

// Time Complexity : O(n * klogk) where n is the length of the vector strs and k is the length of the string in the vector strs and space complexity is O(n)

class Solution(object):
    def groupAnagrams(self, strs):
        """
        :type strs: List[str]
        :rtype: List[List[str]]
        """ 
        res = []  # list to store the result
        map = {}  # map to store the temporary result
        for s in strs:  # iterate through the vector strs
            temp = ''.join(sorted(s))  # variable to store the temporary result
            if temp not in map:  # if the map does not contain the key
                map[temp] = []  # push the temporary result into the map
            map[temp].append(s)  # push the temporary result into the map
        for m in map:  # iterate through the map
            res.append(map[m])  # push the temporary result into the result
        return res  # return the result

49. Group Anagrams in python3

// Time Complexity : O(n * klogk) where n is the length of the vector strs and k is the length of the string in the vector strs and space complexity is O(n)

class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]: // add the missing bracket after List[str]
        res = []  # list to store the result
        map = {}  # map to store the temporary result
        for s in strs:  # iterate through the vector strs
            temp = ''.join(sorted(s))  # variable to store the temporary result
            if temp not in map:  # if the map does not contain the key
                map[temp] = []  # push the temporary result into the map
            map[temp].append(s)  # push the temporary result into the map
        for m in map:  # iterate through the map
            res.append(map[m])  # push the temporary result into the result
        return res  # return the result

49. Group Anagrams in c#

// Time Complexity : O(n * klogk) where n is the length of the vector strs and k is the length of the string in the vector strs and space complexity is O(n)

public class Solution {
    public IList<IList<string>> GroupAnagrams(string[] strs) {
        IList<IList<string>> res = new List<IList<string>>();  // list to store the result
        Dictionary<string, List<string>> map = new Dictionary<string, List<string>>();  // map to store the temporary result
        foreach(string s in strs){  // iterate through the vector strs
            char[] temp = s.ToCharArray();  // variable to store the temporary result
            Array.Sort(temp);  // sort the string
            string sorted = new string(temp);  // variable to store the temporary result
            if(!map.ContainsKey(sorted)){  // if the map does not contain the key
                map.Add(sorted, new List<string>());  // push the temporary result into the map
            }
            map[sorted].Add(s);  // push the temporary result into the map
        }
        foreach(KeyValuePair<string, List<string>> m in map){  // iterate through the map
            res.Add(m.Value);  // push the temporary result into the result
        }
        return res;  // return the result
    }
}

2nd Method 

public class Solution {
    public IList<IList<string>> GroupAnagrams(string[] strs) {
        IList<IList<string>> res = new List<IList<string>>();
        Dictionary<string, List<string>> map = new Dictionary<string, List<string>>();
        foreach(string s in strs){
            char[] temp = s.ToCharArray();
            Array.Sort(temp);
            string sorted = new string(temp);
            if(!map.ContainsKey(sorted)) map.Add(sorted, new List<string>());
            map[sorted].Add(s);
        }
        return new List<IList<string>>(map.Values);
    }
}

49. Group Anagrams in javascript

// Time Complexity : O(n * klogk) where n is the length of the vector strs and k is the length of the string in the vector strs and space complexity is O(n)

var groupAnagrams = function(strs) {
    let res = [];  // list to store the result
    let map = {};  // map to store the temporary result
    for(let s of strs){  // iterate through the vector strs
        let temp = s.split('').sort().join('');  // variable to store the temporary result
        if(!(temp in map)){  // if the map does not contain the key
            map[temp] = [];  // push the temporary result into the map
        }
        map[temp].push(s);  // push the temporary result into the map
    }
    for(let m in map){  // iterate through the map
        res.push(map[m]);  // push the temporary result into the result
    }
    return res;  // return the result
};

49. Group Anagrams in Swift

// Time Complexity : O(n * klogk) where n is the length of the vector strs and k is the length of the string in the vector strs and space complexity is O(n)

class Solution {
    func groupAnagrams(_ strs: [String]) -> [[String]] {
        var res = [[String]]();  // list to store the result
        var map = [String: [String]]();  // map to store the temporary result
        for s in strs {  // iterate through the vector strs
            let temp = String(s.sorted());  // variable to store the temporary result
            if map[temp] == nil {  // if the map does not contain the key
                map[temp] = [String]();  // push the temporary result into the map
            }
            map[temp]?.append(s);  // push the temporary result into the map
        }
        for m in map {  // iterate through the map
            res.append(m.value);  // push the temporary result into the result
        }
        return res;  // return the result
    }
}


50. Pow(x, n) in c++

// Time Complexity : O(logn) where n is the value of the variable n and space complexity is O(1)

class Solution {
public:
    double myPow(double x, int n) {
        double res = 1.0;  // variable to store the result
        long long int temp = n;  // variable to store the temporary result
        if(temp < 0){  // if the value of the variable temp is less than 0
            temp = -1 * temp;  // update the value of the variable temp
        }
        while(temp > 0){  // iterate until the value of the variable temp is greater than 0
            if(temp % 2 == 0){  // if the value of the variable temp is even
                x = x * x;  // update the value of the variable x
                temp = temp / 2;  // update the value of the variable temp
            }
            else{  // if the value of the variable temp is odd
                res = res * x;  // update the value of the variable res
                temp = temp - 1;  // update the value of the variable temp
            }
        }
        if(n < 0){  // if the value of the variable n is less than 0
            res = (double)(1.0) / (double)(res);  // update the value of the variable res
        }
        return res;  // return the result
    }
};

2nd Method 

class Solution {
public:
    double myPow(double x, int n) {
         return pow(x,n);
    }
};

50. Pow(x, n) in Java

// Time Complexity : O(logn) where n is the value of the variable n and space complexity is O(1)

class Solution {
    public double myPow(double x, int n) {
        double res = 1.0;  // variable to store the result
        long temp = n;  // variable to store the temporary result
        if(temp < 0){  // if the value of the variable temp is less than 0
            temp = -1 * temp;  // update the value of the variable temp
        }
        while(temp > 0){  // iterate until the value of the variable temp is greater than 0
            if(temp % 2 == 0){  // if the value of the variable temp is even
                x = x * x;  // update the value of the variable x
                temp = temp / 2;  // update the value of the variable temp
            }
            else{  // if the value of the variable temp is odd
                res = res * x;  // update the value of the variable res
                temp = temp - 1;  // update the value of the variable temp
            }
        }
        if(n < 0){  // if the value of the variable n is less than 0
            res = (double)(1.0) / (double)(res);  // update the value of the variable res
        }
        return res;  // return the result
    }
}

2nd Metthod

class Solution {
    public double myPow(double x, int n) {
        return Math.pow(x,n);
    }
}

50. Pow(x, n) in python

// Time Complexity : O(logn) where n is the value of the variable n and space complexity is O(1)

class Solution(object):
    def myPow(self, x, n):
        """
        :type x: float
        :type n: int
        :rtype: float
        """ 
        res = 1.0  # variable to store the result
        temp = n  # variable to store the temporary result
        if temp < 0:  # if the value of the variable temp is less than 0
            temp = -1 * temp  # update the value of the variable temp
        while temp > 0:  # iterate until the value of the variable temp is greater than 0
            if temp % 2 == 0:  # if the value of the variable temp is even
                x = x * x  # update the value of the variable x
                temp = temp / 2  # update the value of the variable temp
            else:  # if the value of the variable temp is odd
                res = res * x  # update the value of the variable res
                temp = temp - 1  # update the value of the variable temp
        if n < 0:  # if the value of the variable n is less than 0
            res = (float)(1.0) / (float)(res)  # update the value of the variable res
        return res  # return the result

2nd Method 

class Solution(object):
    def myPow(self, x, n):
        """
        :type x: float
        :type n: int
        :rtype: float
        """ 
        return x ** n

50. Pow(x, n) in python3

// Time Complexity : O(logn) where n is the value of the variable n and space complexity is O(1)

class Solution:
    def myPow(self, x: float, n: int) -> float:
        res = 1.0  # variable to store the result
        temp = n  # variable to store the temporary result
        if temp < 0:  # if the value of the variable temp is less than 0
            temp = -1 * temp  # update the value of the variable temp
        while temp > 0:  # iterate until the value of the variable temp is greater than 0
            if temp % 2 == 0:  # if the value of the variable temp is even
                x = x * x  # update the value of the variable x
                temp = temp / 2  # update the value of the variable temp
            else:  # if the value of the variable temp is odd
                res = res * x  # update the value of the variable res
                temp = temp - 1  # update the value of the variable temp
        if n < 0:  # if the value of the variable n is less than 0
            res = (float)(1.0) / (float)(res)  # update the value of the variable res
        return res  # return the result


2nd Method 

class Solution:
    def myPow(self, x: float, n: int) -> float:
        return x ** n

50. Pow(x, n) in c

// Time Complexity : O(logn) where n is the value of the variable n and space complexity is O(1)

double myPow(double x, int n){
    double res = 1.0;  // variable to store the result
    long long int temp = n;  // variable to store the temporary result
    if(temp < 0){  // if the value of the variable temp is less than 0
        temp = -1 * temp;  // update the value of the variable temp
    }
    while(temp > 0){  // iterate until the value of the variable temp is greater than 0
        if(temp % 2 == 0){  // if the value of the variable temp is even
            x = x * x;  // update the value of the variable x
            temp = temp / 2;  // update the value of the variable temp
        }
        else{  // if the value of the variable temp is odd
            res = res * x;  // update the value of the variable res
            temp = temp - 1;  // update the value of the variable temp
        }
    }
    if(n < 0){  // if the value of the variable n is less than 0
        res = (double)(1.0) / (double)(res);  // update the value of the variable res
    }
    return res;  // return the result
}

2nd Method

double myPow(double x, int n){
    return pow(x, n);
}

50. Pow(x, n) in c#

// Time Complexity : O(logn) where n is the value of the variable n and space complexity is O(1)

public class Solution {
    public double MyPow(double x, int n) {
        double res = 1.0;  // variable to store the result
        long temp = n;  // variable to store the temporary result
        if(temp < 0){  // if the value of the variable temp is less than 0
            temp = -1 * temp;  // update the value of the variable temp
        }
        while(temp > 0){  // iterate until the value of the variable temp is greater than 0
            if(temp % 2 == 0){  // if the value of the variable temp is even
                x = x * x;  // update the value of the variable x
                temp = temp / 2;  // update the value of the variable temp
            }
            else{  // if the value of the variable temp is odd
                res = res * x;  // update the value of the variable res
                temp = temp - 1;  // update the value of the variable temp
            }
        }
        if(n < 0){  // if the value of the variable n is less than 0
            res = (double)(1.0) / (double)(res);  // update the value of the variable res
        }
        return res;  // return the result
    }
}


2nd Method

public class Solution {
    public double MyPow(double x, int n) {
        return Math.Pow(x, n);
    }
}


50. Pow(x, n) in javascript

// Time Complexity : O(logn) where n is the value of the variable n and space complexity is O(1)

var myPow = function(x, n) {
    let res = 1.0;  // variable to store the result
    let temp = n;  // variable to store the temporary result
    if(temp < 0){  // if the value of the variable temp is less than 0
        temp = -1 * temp;  // update the value of the variable temp
    }
    while(temp > 0){  // iterate until the value of the variable temp is greater than 0
        if(temp % 2 == 0){  // if the value of the variable temp is even
            x = x * x;  // update the value of the variable x
            temp = temp / 2;  // update the value of the variable temp
        }
        else{  // if the value of the variable temp is odd
            res = res * x;  // update the value of the variable res
            temp = temp - 1;  // update the value of the variable temp
        }
    }
    if(n < 0){  // if the value of the variable n is less than 0
        res = (float)(1.0) / (float)(res);  // update the value of the variable res
    }
    return res;  // return the result
};

2nd Method

var myPow = function(x, n) {
    return Math.pow(x, n);
};


50. Pow(x, n) in Swift

// Time Complexity : O(logn) where n is the value of the variable n and space complexity is O(1)


class Solution {
    func myPow(_ x: Double, _ n: Int) -> Double {
        var res = 1.0
        var temp = n

        if temp < 0 {
            temp = -temp
            // If the exponent is negative, we take the reciprocal of the base
            // instead of using the absolute value of 'n'.
            return 1.0 / powHelper(x, temp)
        }

        return powHelper(x, temp)
    }

    private func powHelper(_ x: Double, _ n: Int) -> Double {
        if n == 0 {
            return 1.0
        }

        let half = powHelper(x, n / 2)

        if n % 2 == 0 {
            return half * half
        } else {
            return half * half * x
        }
    }
}



2nd Method 



class Solution {
    func myPow(_ x: Double, _ n: Int) -> Double {
         pow(x, Double(n))
    }
}


51. N-Queens in c++


// Time Complexity : O(n!) where n is the value of the variable n and space complexity is O(n)


class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> res;  // vector to store the result
        vector<string> temp(n, string(n, '.'));  // vector to store the temporary result
        solveHelper(res, temp, 0, n);  // call the function to find the solution
        return res;  // return the result
    }
    
    void solveHelper(vector<vector<string>>& res, vector<string>& temp, int row, int& n){
        if(row == n){  // if the value of the variable row is equal to the value of the variable n
            res.push_back(temp);  // push the temporary result into the result
            return;  // return
        }
        for(int col = 0; col < n; col++){  // iterate through the vector temp
            if(isValid(temp, row, col, n)){  // if the current position is valid
                temp[row][col] = 'Q';  // update the value of the vector temp
                solveHelper(res, temp, row + 1, n);  // call the function to find the solution
                temp[row][col] = '.';  // update the value of the vector temp
            }
        }
    }
    
    bool isValid(vector<string>& temp, int row, int col, int& n){
        for(int i = 0; i < row; i++){  // iterate through the vector temp
            if(temp[i][col] == 'Q'){  // if the current position is valid
                return false;  // return false
            }          
        }
        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--){  // iterate through the vector temp
            if(temp[i][j] == 'Q'){  // if the current position is valid
                return false;  // return false
            }
        }
        for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++){  // iterate through the vector temp
            if(temp[i][j] == 'Q'){  // if the current position is valid
                return false;  // return false
            }
        }
        return true;  // return true
    }
};

51. N-Queens in Java

// Time Complexity : O(n!) where n is the value of the variable n and space complexity is O(n)

class Solution {
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> res = new ArrayList<>();  // list to store the result
        List<String> temp = new ArrayList<>();  // list to store the temporary result
        for(int i = 0; i < n; i++){  // iterate through the vector temp
            StringBuilder sb = new StringBuilder();  // variable to store the temporary result
            for(int j = 0; j < n; j++){  // iterate through the vector temp
                sb.append('.');  // append the value into the string builder
            }
            temp.add(sb.toString());  // push the temporary result into the list
        }
        solveHelper(res, temp, 0, n);  // call the function to find the solution
        return res;  // return the result
    }
    
    void solveHelper(List<List<String>> res, List<String> temp, int row, int n){
        if(row == n){  // if the value of the variable row is equal to the value of the variable n
            res.add(new ArrayList<>(temp));  // push the temporary result into the result
            return;  // return
        }
        for(int col = 0; col < n; col++){  // iterate through the vector temp
            if(isValid(temp, row, col, n)){  // if the current position is valid
                StringBuilder sb = new StringBuilder(temp.get(row));  // variable to store the temporary result
                sb.setCharAt(col, 'Q');  // update the value of the vector temp
                temp.set(row, sb.toString());  // update the value of the vector temp
                solveHelper(res, temp, row + 1, n);  // call the function to find the solution
                sb.setCharAt(col, '.');  // update the value of the vector temp
                temp.set(row, sb.toString());  // update the value of the vector temp
            }
        }
    }
    
    boolean isValid(List<String> temp, int row, int col, int n){
        for(int i = 0; i < row; i++){  // iterate through the vector temp
            if(temp.get(i).charAt(col) == 'Q'){  // if the current position is valid
                return false;  // return false
            }
        }
        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--){  // iterate through the vector temp
            if(temp.get(i).charAt(j) == 'Q'){  // if the current position is valid
                return false;  // return false
            }
        }
        for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++){  // iterate through the vector temp
            if(temp.get(i).charAt(j) == 'Q'){  // if the current position is valid
                return false;  // return false
            }
        }
        return true;  // return true
    }
}

2nd Method

class Solution {
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> res = new ArrayList<>();  // list to store the result
        char[][] board = new char[n][n];  // 2D character array to represent the board
        
        // Initialize the board with dots (empty cells)
        for (int i = 0; i < n; i++) {
            Arrays.fill(board[i], '.');
        }
        
        solveHelper(res, board, 0, n);  // call the function to find the solution
        return res;  // return the result
    }
    
    void solveHelper(List<List<String>> res, char[][] board, int row, int n) {
        if (row == n) {  // if the value of the variable row is equal to the value of the variable n
            List<String> solution = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                solution.add(String.valueOf(board[i])); // Convert the row to a string and add to the solution list
            }
            res.add(solution);  // push the temporary result into the result
            return;  // return
        }
        
        for (int col = 0; col < n; col++) {  // iterate through the board
            if (isValid(board, row, col, n)) {  // if the current position is valid
                board[row][col] = 'Q';  // place the queen at the current position
                solveHelper(res, board, row + 1, n);  // call the function to find the solution
                board[row][col] = '.';  // remove the queen at the current position
            }
        }
    }
    
    boolean isValid(char[][] board, int row, int col, int n) {
        // Check for queens in the same column
        for (int i = 0; i < row; i++) {
            if (board[i][col] == 'Q') {
                return false;
            }
        }
        
        // Check for queens in the left diagonal
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q') {
                return false;
            }
        }
        
        // Check for queens in the right diagonal
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (board[i][j] == 'Q') {
                return false;
            }
        }
        
        return true;
    }
}

51. N-Queens in python

// Time Complexity : O(n!) where n is the value of the variable n and space complexity is O(n)

class Solution(object):
    def solveNQueens(self, n):
        """
        :type n: int
        :rtype: List[List[str]]
        """ 
        res = []  # list to store the result
        temp = ['.' * n for _ in range(n)]  # list to store the temporary result
        self.solveHelper(res, temp, 0, n)  # call the function to find the solution
        return res  # return the result
    
    def solveHelper(self, res, temp, row, n):
        if row == n:  # if the value of the variable row is equal to the value of the variable n
            res.append(list(temp))  # push the temporary result into the result
            return  # return
        for col in range(n):  # iterate through the vector temp
            if self.isValid(temp, row, col, n):  # if the current position is valid
                temp[row] = temp[row][:col] + 'Q' + temp[row][col + 1:]  # update the value of the vector temp
                self.solveHelper(res, temp, row + 1, n)  # call the function to find the solution
                temp[row] = temp[row][:col] + '.' + temp[row][col + 1:]  # update the value of the vector temp
    
    def isValid(self, temp, row, col, n):
        for i in range(row):  # iterate through the vector temp
            if temp[i][col] == 'Q':  # if the current position is valid
                return False  # return false
        for i, j in zip(range(row - 1, -1, -1), range(col - 1, -1, -1)):  # iterate through the vector temp
            if temp[i][j] == 'Q':  # if the current position is valid
                return False  # return false
        for i, j in zip(range(row - 1, -1, -1), range(col + 1, n)):  # iterate through the vector temp
            if temp[i][j] == 'Q':  # if the current position is valid
                return False  # return false
        return True  # return true

51. N-Queens in python3

// Time Complexity : O(n!) where n is the value of the variable n and space complexity is O(n)

class Solution:
    def solveNQueens(self, n: int -> List[List[str]]: // add the missing bracket after int
        res = []  # list to store the result
        temp = ['.' * n for _ in range(n)]  # list to store the temporary result
        self.solveHelper(res, temp, 0, n)  # call the function to find the solution
        return res  # return the result
    
    def solveHelper(self, res, temp, row, n):
        if row == n:  # if the value of the variable row is equal to the value of the variable n
            res.append(list(temp))  # push the temporary result into the result
            return  # return
        for col in range(n):  # iterate through the vector temp
            if self.isValid(temp, row, col, n):  # if the current position is valid
                temp[row] = temp[row][:col] + 'Q' + temp[row][col + 1:]  # update the value of the vector temp
                self.solveHelper(res, temp, row + 1, n)  # call the function to find the solution
                temp[row] = temp[row][:col] + '.' + temp[row][col + 1:]  # update the value of the vector temp
    
    def isValid(self, temp, row, col, n):
        for i in range(row):  # iterate through the vector temp
            if temp[i][col] == 'Q':  # if the current position is valid
                return False  # return false
        for i, j in zip(range(row - 1, -1, -1), range(col - 1, -1, -1)):  # iterate through the vector temp
            if temp[i][j] == 'Q':  # if the current position is valid
                return False  # return false
        for i, j in zip(range(row - 1, -1, -1), range(col + 1, n)):  # iterate through the vector temp
            if temp[i][j] == 'Q':  # if the current position is valid
                return False  # return false
        return True  # return true

51. N-Queens in c

// Time Complexity : O(n!) where n is the value of the variable n and space complexity is O(n)

void solveHelper(char*** res, char** temp, int row, int n, int* returnSize);
bool isValid(char** temp, int row, int col, int n);

char*** solveNQueens(int n, int* returnSize, int** returnColumnSizes){
    char*** res = (char***)malloc(sizeof(char**) * 1000);  // vector to store the result
    char** temp = (char**)malloc(sizeof(char*) * n);  // vector to store the temporary result
    for(int i = 0; i < n; i++){  // iterate through the vector temp
        temp[i] = (char*)malloc(sizeof(char) * (n + 1));  // vector to store the temporary result
        for(int j = 0; j < n; j++){  // iterate through the vector temp
            temp[i][j] = '.';  // update the value of the vector temp
        }
        temp[i][n] = '\0';  // update the value of the vector temp

    *returnSize = 0;  // update the value of the variable returnSize
    solveHelper(res, temp, 0, n, returnSize);  // call the function to find the solution
    *returnColumnSizes = (int*)malloc(sizeof(int) * (*returnSize));  // vector to store the result
    for(int i = 0; i < *returnSize; i++){  // iterate through the vector temp
        (*returnColumnSizes)[i] = n;  // update the value of the vector temp
    }
    return res;  // return the result
}

void solveHelper(char*** res, char** temp, int row, int n, int* returnSize){
    if(row == n){  // if the value of the variable row is equal to the value of the variable n
        res[*returnSize] = (char**)malloc(sizeof(char*) * n);  // vector to store the result
        for(int i = 0; i < n; i++){  // iterate through the vector temp
            res[*returnSize][i] = (char*)malloc(sizeof(char) * (n + 1));  // vector to store the result
            strcpy(res[*returnSize][i], temp[i]);  // copy the value of the vector temp
        }
        (*returnSize)++;  // update the value of the variable returnSize
        return;  // return
    }
    for(int col = 0; col < n; col++){  // iterate through the vector temp
        if(isValid(temp, row, col, n)){  // if the current position is valid
            temp[row][col] = 'Q';  // update the value of the vector temp
            solveHelper(res, temp, row + 1, n, returnSize);  // call the function to find the solution
            temp[row][col] = '.';  // update the value of the vector temp
        }
    }
}

bool isValid(char** temp, int row, int col, int n){
    for(int i = 0; i < row; i++){  // iterate through the vector temp
        if(temp[i][col] == 'Q'){  // if the current position is valid
            return false;  // return false
        }
    }
    for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--){  // iterate through the vector temp
        if(temp[i][j] == 'Q'){  // if the current position is valid
            return false;  // return false
        }
    }
    for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++){  // iterate through the vector temp
        if(temp[i][j] == 'Q'){  // if the current position is valid
            return false;  // return false
        }
    }
    return true;  // return true
}

51. N-Queens in c#

// Time Complexity : O(n!) where n is the value of the variable n and space complexity is O(n)

public class Solution {
    public IList<IList<string>> SolveNQueens(int n) {
        IList<IList<string>> res = new List<IList<string>>();  // list to store the result
        IList<string> temp = new List<string>();  // list to store the temporary result
        for(int i = 0; i < n; i++){  // iterate through the vector temp
            StringBuilder sb = new StringBuilder();  // variable to store the temporary result
            for(int j = 0; j < n; j++){  // iterate through the vector temp
                sb.Append('.');  // append the value into the string builder
            }
            temp.Add(sb.ToString());  // push the temporary result into the list
        }
        solveHelper(res, temp, 0, n);  // call the function to find the solution
        return res;  // return the result
    }
    
    void solveHelper(IList<IList<string>> res, IList<string> temp, int row, int n){
        if(row == n){  // if the value of the variable row is equal to the value of the variable n
            res.Add(new List<string>(temp));  // push the temporary result into the result
            return;  // return
        }
        for(int col = 0; col < n; col++){  // iterate through the vector temp
            if(isValid(temp, row, col, n)){  // if the current position is valid
                StringBuilder sb = new StringBuilder(temp[row]);  // variable to store the temporary result
                sb[col] = 'Q';  // update the value of the vector temp
                temp[row] = sb.ToString();  // update the value of the vector temp
                solveHelper(res, temp, row + 1, n);  // call the function to find the solution
                sb[col] = '.';  // update the value of the vector temp
                temp[row] = sb.ToString();  // update the value of the vector temp
            }
        }
    }
    
    bool isValid(IList<string> temp, int row, int col, int n){
        for(int i = 0; i < row; i++){  // iterate through the vector temp
            if(temp[i][col] == 'Q'){  // if the current position is valid
                return false;  // return false
            }
        }
        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--){  // iterate through the vector temp
            if(temp[i][j] == 'Q'){  // if the current position is valid
                return false;  // return false
            }
        }
        for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++){  // iterate through the vector temp
            if(temp[i][j] == 'Q'){  // if the current position is valid
                return false;  // return false
            }
        }
        return true;  // return true
    }
}

51. N-Queens in javascript

// Time Complexity : O(n!) where n is the value of the variable n and space complexity is O(n)

var solveNQueens = function(n) {
    let res = [];  // list to store the result
    let temp = new Array(n).fill(new Array(n).fill('.'));  // list to store the temporary result
    solveHelper(res, temp, 0, n);  // call the function to find the solution
    return res;  // return the result
};

function solveHelper(res, temp, row, n){
    if(row == n){  // if the value of the variable row is equal to the value of the variable n
        res.push(temp.map((x) => x.join('')));  // push the temporary result into the result
        return;  // return
    }
    for(let col = 0; col < n; col++){  // iterate through the vector temp
        if(isValid(temp, row, col, n)){  // if the current position is valid
            temp[row][col] = 'Q';  // update the value of the vector temp
            solveHelper(res, temp, row + 1, n);  // call the function to find the solution
            temp[row][col] = '.';  // update the value of the vector temp
        }
    }
}

function isValid(temp, row, col, n){
    for(let i = 0; i < row; i++){  // iterate through the vector temp
        if(temp[i][col] == 'Q'){  // if the current position is valid
            return false;  // return false
        }
    }
    for(let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--){  // iterate through the vector temp
        if(temp[i][j] == 'Q'){  // if the current position is valid
            return false;  // return false
        }
    }
    for(let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++){  // iterate through the vector temp
        if(temp[i][j] == 'Q'){  // if the current position is valid
            return false;  // return false
        }
    }
    return true;  // return true
}


51. N-Queens in Swift
 
// Time Complexity : O(n!) where n is the value of the variable n and space complexity is O(n)

class Solution {
    func solveNQueens(_ n: Int) -> [[String]] {
        var res = [[String]]()  // list to store the result
        var temp = [[String]](repeating: [String](repeating: ".", count: n), count: n)  // list to store the temporary result
        solveHelper(&res, &temp, 0, n)  // call the function to find the solution
        return res  // return the result
    }
    
    func solveHelper(_ res: inout [[String]], _ temp: inout [[String]], _ row: Int, _ n: Int) {
        if row == n {  // if the value of the variable row is equal to the value of the variable n
            res.append(temp.map { $0.joined() })  // push the temporary result into the result
            return  // return
        }
        for col in 0..<n {  // iterate through the vector temp
            if isValid(temp, row, col, n) {  // if the current position is valid
                temp[row][col] = "Q"  // update the value of the vector temp
                solveHelper(&res, &temp, row + 1, n)  // call the function to find the solution
                temp[row][col] = "."  // update the value of the vector temp
            }
        }
    }
    
    func isValid(_ temp: [[String]], _ row: Int, _ col: Int, _ n: Int) -> Bool {
        for i in 0..<row {  // iterate through the vector temp
            if temp[i][col] == "Q" {  // if the current position is valid
                return false  // return false
            }
        }
        for (i, j) in zip((0..<row).reversed(), (0..<col).reversed()) {  // iterate through the vector temp
            if temp[i][j] == "Q" {  // if the current position is valid
                return false  // return false
            }
        }
        for (i, j) in zip((0..<row).reversed(), col + 1..<n) {  // iterate through the vector temp
            if temp[i][j] == "Q" {  // if the current position is valid
                return false  // return false
            }
        }
        return true  // return true
    }
}



52. N-Queens II in c++


// Time Complexity : O(n!) where n is the value of the variable n and space complexity is O(n)


class Solution {
public:
    int totalNQueens(int n) {
        int res = 0;  // variable to store the result
        vector<string> temp(n, string(n, '.'));  // vector to store the temporary result
        solveHelper(res, temp, 0, n);  // call the function to find the solution
        return res;  // return the result
    }
    
    void solveHelper(int& res, vector<string>& temp, int row, int& n){
        if(row == n){  // if the value of the variable row is equal to the value of the variable n
            res++;  // update the value of the variable res
            return;  // return
        }
        for(int col = 0; col < n; col++){  // iterate through the vector temp
            if(isValid(temp, row, col, n)){  // if the current position is valid
                temp[row][col] = 'Q';  // update the value of the vector temp
                solveHelper(res, temp, row + 1, n);  // call the function to find the solution
                temp[row][col] = '.';  // update the value of the vector temp
            }
        }
    }
    
    bool isValid(vector<string>& temp, int row, int col, int& n){
        for(int i = 0; i < row; i++){  // iterate through the vector temp
            if(temp[i][col] == 'Q'){  // if the current position is valid
                return false;  // return false
            }          
        }
        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--){  // iterate through the vector temp
            if(temp[i][j] == 'Q'){  // if the current position is valid
                return false;  // return false
            }
        }
        for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++){  // iterate through the vector temp
            if(temp[i][j] == 'Q'){  // if the current position is valid
                return false;  // return false
            }
        }
        return true;  // return true
    }
};

52. N-Queens II in Java

// Time Complexity : O(n!) where n is the value of the variable n and space complexity is O(n)

class Solution {
    public int totalNQueens(int n) {
        int[] res = new int[1];  // variable to store the result
        List<String> temp = new ArrayList<>();  // list to store the temporary result
        for(int i = 0; i < n; i++){  // iterate through the vector temp
            StringBuilder sb = new StringBuilder();  // variable to store the temporary result
            for(int j = 0; j < n; j++){  // iterate through the vector temp
                sb.append('.');  // append the value into the string builder
            }
            temp.add(sb.toString());  // push the temporary result into the list
        }
        solveHelper(res, temp, 0, n);  // call the function to find the solution
        return res[0];  // return the result
    }
    
    void solveHelper(int[] res, List<String> temp, int row, int n){
        if(row == n){  // if the value of the variable row is equal to the value of the variable n
            res[0]++;  // update the value of the variable res
            return;  // return
        }
        for(int col = 0; col < n; col++){  // iterate through the vector temp
            if(isValid(temp, row, col, n)){  // if the current position is valid
                StringBuilder sb = new StringBuilder(temp.get(row));  // variable to store the temporary result
                sb.setCharAt(col, 'Q');  // update the value of the vector temp
                temp.set(row, sb.toString());  // update the value of the vector temp
                solveHelper(res, temp, row + 1, n);  // call the function to find the solution
                sb.setCharAt(col, '.');  // update the value of the vector temp
                temp.set(row, sb.toString());  // update the value of the vector temp
            }
        }
    }
    
    boolean isValid(List<String> temp, int row, int col, int n){
        for(int i = 0; i < row; i++){  // iterate through the vector temp
            if(temp.get(i).charAt(col) == 'Q'){  // if the current position is valid
                return false;  // return false
            }
        }
        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--){  // iterate through the vector temp
            if(temp.get(i).charAt(j) == 'Q'){  // if the current position is valid
                return false;  // return false
            }
        }
        for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++){  // iterate through the vector temp
            if(temp.get(i).charAt(j) == 'Q'){  // if the current position is valid
                return false;  // return false
            }
        }
        return true;  // return true
    }
}

2nd Method

class Solution {
    public int totalNQueens(int n) {
        int[] res = new int[1];  // variable to store the result
        char[][] board = new char[n][n];  // 2D character array to represent the board
        
        // Initialize the board with dots (empty cells)
        for (int i = 0; i < n; i++) {
            Arrays.fill(board[i], '.');
        }
        
        solveHelper(res, board, 0, n);  // call the function to find the solution
        return res[0];  // return the result
    }
    
    void solveHelper(int[] res, char[][] board, int row, int n) {
        if (row == n) {  // if the value of the variable row is equal to the value of the variable n
            res[0]++;  // update the value of the variable res
            return;  // return
        }
        
        for (int col = 0; col < n; col++) {  // iterate through the board
            if (isValid(board, row, col, n)) {  // if the current position is valid
                board[row][col] = 'Q';  // place the queen at the current position
                solveHelper(res, board, row + 1, n);  // call the function to find the solution
                board[row][col] = '.';  // remove the queen at the current position
            }
        }
    }
    
    boolean isValid(char[][] board, int row, int col, int n) {
        // Check for queens in the same column
        for (int i = 0; i < row; i++) {
            if (board[i][col] == 'Q') {
                return false;
            }
        }
        
        // Check for queens in the left diagonal
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q') {
                return false;
            }
        }
        
        // Check for queens in the right diagonal
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (board[i][j] == 'Q') {
                return false;
            }
        }

        return true;
    }
}

52. N-Queens II in python

// Time Complexity : O(n!) where n is the value of the variable n and space complexity is O(n)

class Solution(object):
    def totalNQueens(self, n):
        """
        :type n: int
        :rtype: int
        """ 
        res = [0]  # variable to store the result
        temp = ['.' * n for _ in range(n)]  # list to store the temporary result
        self.solveHelper(res, temp, 0, n)  # call the function to find the solution
        return res[0]  # return the result
    
    def solveHelper(self, res, temp, row, n):
        if row == n:  # if the value of the variable row is equal to the value of the variable n
            res[0] += 1  # update the value of the variable res
            return  # return
        for col in range(n):  # iterate through the vector temp
            if self.isValid(temp, row, col, n):  # if the current position is valid
                temp[row] = temp[row][:col] + 'Q' + temp[row][col + 1:]  # update the value of the vector temp
                self.solveHelper(res, temp, row + 1, n)  # call the function to find the solution
                temp[row] = temp[row][:col] + '.' + temp[row][col + 1:]  # update the value of the vector temp
    
    def isValid(self, temp, row, col, n):
        for i in range(row):  # iterate through the vector temp
            if temp[i][col] == 'Q':  # if the current position is valid
                return False  # return false
        for i, j in zip(range(row - 1, -1, -1), range(col - 1, -1, -1)):  # iterate through the vector temp
            if temp[i][j] == 'Q':  # if the current position is valid
                return False  # return false
        for i, j in zip(range(row - 1, -1, -1), range(col + 1, n)):  # iterate through the vector temp
            if temp[i][j] == 'Q':  # if the current position is valid
                return False  # return false
        return True  # return true

52. N-Queens II in python3

// Time Complexity : O(n!) where n is the value of the variable n and space complexity is O(n)

class Solution:
    def totalNQueens(self, n: int -> int:  // add the missing bracket after int
        res = [0]  # variable to store the result
        temp = ['.' * n for _ in range(n)]  # list to store the temporary result
        self.solveHelper(res, temp, 0, n)  # call the function to find the solution
        return res[0]  # return the result
    
    def solveHelper(self, res, temp, row, n):
        if row == n:  # if the value of the variable row is equal to the value of the variable n
            res[0] += 1  # update the value of the variable res
            return  # return
        for col in range(n):  # iterate through the vector temp
            if self.isValid(temp, row, col, n):  # if the current position is valid
                temp[row] = temp[row][:col] + 'Q' + temp[row][col + 1:]  # update the value of the vector temp
                self.solveHelper(res, temp, row + 1, n)  # call the function to find the solution
                temp[row] = temp[row][:col] + '.' + temp[row][col + 1:]  # update the value of the vector temp
    
    def isValid(self, temp, row, col, n):
        for i in range(row):  # iterate through the vector temp
            if temp[i][col] == 'Q':  # if the current position is valid
                return False  # return false
        for i, j in zip(range(row - 1, -1, -1), range(col - 1, -1, -1)):  # iterate through the vector temp
            if temp[i][j] == 'Q':  # if the current position is valid
                return False  # return false
        for i, j in zip(range(row - 1, -1, -1), range(col + 1, n)):  # iterate through the vector temp
            if temp[i][j] == 'Q':  # if the current position is valid
                return False  # return false
        return True  # return true

52. N-Queens II in c

// Time Complexity : O(n!) where n is the value of the variable n and space complexity is O(n)

void solveHelper(int* res, char** temp, int row, int n);
bool isValid(char** temp, int row, int col, int n);

int totalNQueens(int n){
    int res = 0;  // variable to store the result
    char** temp = (char**)malloc(sizeof(char*) * n);  // vector to store the temporary result
    for(int i = 0; i < n; i++){  // iterate through the vector temp
        temp[i] = (char*)malloc(sizeof(char) * (n + 1));  // vector to store the temporary result
        for(int j = 0; j < n; j++){  // iterate through the vector temp
            temp[i][j] = '.';  // update the value of the vector temp
        }
        temp[i][n] = '\0';  // update the value of the vector temp
    }
    solveHelper(&res, temp, 0, n);  // call the function to find the solution
    return res;  // return the result
}

void solveHelper(int* res, char** temp, int row, int n){
    if(row == n){  // if the value of the variable row is equal to the value of the variable n
        (*res)++;  // update the value of the variable res
        return;  // return
    }
    for(int col = 0; col < n; col++){  // iterate through the vector temp
        if(isValid(temp, row, col, n)){  // if the current position is valid
            temp[row][col] = 'Q';  // update the value of the vector temp
            solveHelper(res, temp, row + 1, n);  // call the function to find the solution
            temp[row][col] = '.';  // update the value of the vector temp
        }
    }
}

bool isValid(char** temp, int row, int col, int n){
    for(int i = 0; i < row; i++){  // iterate through the vector temp
        if(temp[i][col] == 'Q'){  // if the current position is valid
            return false;  // return false
        }
    }
    for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--){  // iterate through the vector temp
        if(temp[i][j] == 'Q'){  // if the current position is valid
            return false;  // return false
        }
    }
    for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++){  // iterate through the vector temp
        if(temp[i][j] == 'Q'){  // if the current position is valid
            return false;  // return false
        }
    }
    return true;  // return true
}

52. N-Queens II in c#

// Time Complexity : O(n!) where n is the value of the variable n and space complexity is O(n)

public class Solution {
    public int TotalNQueens(int n) {
        int[] res = new int[1];  // variable to store the result
        IList<string> temp = new List<string>();  // list to store the temporary result
        for(int i = 0; i < n; i++){  // iterate through the vector temp
            StringBuilder sb = new StringBuilder();  // variable to store the temporary result
            for(int j = 0; j < n; j++){  // iterate through the vector temp
                sb.Append('.');  // append the value into the string builder
            }
            temp.Add(sb.ToString());  // push the temporary result into the list
        }
        solveHelper(res, temp, 0, n);  // call the function to find the solution
        return res[0];  // return the result
    }
    
    void solveHelper(int[] res, IList<string> temp, int row, int n){
        if(row == n){  // if the value of the variable row is equal to the value of the variable n
            res[0]++;  // update the value of the variable res
            return;  // return
        }
        for(int col = 0; col < n; col++){  // iterate through the vector temp
            if(isValid(temp, row, col, n)){  // if the current position is valid
                StringBuilder sb = new StringBuilder(temp[row]);  // variable to store the temporary result
                sb[col] = 'Q';  // update the value of the vector temp
                temp[row] = sb.ToString();  // update the value of the vector temp
                solveHelper(res, temp, row + 1, n);  // call the function to find the solution
                sb[col] = '.';  // update the value of the vector temp
                temp[row] = sb.ToString();  // update the value of the vector temp
            }
        }
    }
    
    bool isValid(IList<string> temp, int row, int col, int n){
        for(int i = 0; i < row; i++){  // iterate through the vector temp
            if(temp[i][col] == 'Q'){  // if the current position is valid
                return false;  // return false
            }
        }
        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--){  // iterate through the vector temp
            if(temp[i][j] == 'Q'){  // if the current position is valid
                return false;  // return false
            }
        }
        for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++){  // iterate through the vector temp
            if(temp[i][j] == 'Q'){  // if the current position is valid
                return false;  // return false
            }
        }
        return true;  // return true
    }
}

52. N-Queens II in javascript

// Time Complexity : O(n!) where n is the value of the variable n and space complexity is O(n)

var totalNQueens = function(n) {
    let res = [0];  // variable to store the result
    let temp = new Array(n).fill(new Array(n).fill('.'));  // list to store the temporary result
    solveHelper(res, temp, 0, n);  // call the function to find the solution
    return res[0];  // return the result
};

function solveHelper(res, temp, row, n){
    if(row == n){  // if the value of the variable row is equal to the value of the variable n
        res[0]++;  // update the value of the variable res
        return;  // return
    }
    for(let col = 0; col < n; col++){  // iterate through the vector temp
        if(isValid(temp, row, col, n)){  // if the current position is valid
            temp[row][col] = 'Q';  // update the value of the vector temp
            solveHelper(res, temp, row + 1, n);  // call the function to find the solution
            temp[row][col] = '.';  // update the value of the vector temp
        }
    }
}

function isValid(temp, row, col, n){
    for(let i = 0; i < row; i++){  // iterate through the vector temp
        if(temp[i][col] == 'Q'){  // if the current position is valid
            return false;  // return false
        }
    }
    for(let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--){  // iterate through the vector temp
        if(temp[i][j] == 'Q'){  // if the current position is valid
            return false;  // return false
        }
    }
    for(let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++){  // iterate through the vector temp
        if(temp[i][j] == 'Q'){  // if the current position is valid
            return false;  // return false
        }
    }
    return true;  // return true
}

52. N-Queens II in Swift

// Time Complexity : O(n!) where n is the value of the variable n and space complexity is O(n)

class Solution {
    func totalNQueens(_ n: Int) -> Int {
        var res = 0  // variable to store the result
        var temp = [[String]](repeating: [String](repeating: ".", count: n), count: n)  // list to store the temporary result
        solveHelper(&res, &temp, 0, n)  // call the function to find the solution
        return res  // return the result
    }
    
    func solveHelper(_ res: inout Int, _ temp: inout [[String]], _ row: Int, _ n: Int) {
        if row == n {  // if the value of the variable row is equal to the value of the variable n
            res += 1  // update the value of the variable res
            return  // return
        }
        for col in 0..<n {  // iterate through the vector temp
            if isValid(temp, row, col, n) {  // if the current position is valid
                temp[row][col] = "Q"  // update the value of the vector temp
                solveHelper(&res, &temp, row + 1, n)  // call the function to find the solution
                temp[row][col] = "."  // update the value of the vector temp
            }
        }
    }
    
    func isValid(_ temp: [[String]], _ row: Int, _ col: Int, _ n: Int) -> Bool {
        for i in 0..<row {  // iterate through the vector temp
            if temp[i][col] == "Q" {  // if the current position is valid
                return false  // return false
            }
        }
        for (i, j) in zip((0..<row).reversed(), (0..<col).reversed()) {  // iterate through the vector temp
            if temp[i][j] == "Q" {  // if the current position is valid
                return false  // return false
            }
        }
        for (i, j) in zip((0..<row).reversed(), col + 1..<n) {  // iterate through the vector temp
            if temp[i][j] == "Q" {  // if the current position is valid
                return false  // return false
            }
        }
        return true  // return true
    }
}

53. Maximum Subarray in c++

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int maxSum = nums[0];  // variable to store the maximum sum
        int currSum = nums[0];  // variable to store the current sum
        for(int i = 1; i < nums.size(); i++){  // iterate through the vector nums
            currSum = max(nums[i], currSum + nums[i]);  // update the value of the variable currSum
            maxSum = max(maxSum, currSum);  // update the value of the variable maxSum
        }
        return maxSum;  // return the maximum sum
    }
};

53. Maximum Subarray in Java

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public int maxSubArray(int[] nums) {
        int maxSum = nums[0];  // variable to store the maximum sum
        int currSum = nums[0];  // variable to store the current sum
        for(int i = 1; i < nums.length; i++){  // iterate through the vector nums
            currSum = Math.max(nums[i], currSum + nums[i]);  // update the value of the variable currSum
            maxSum = Math.max(maxSum, currSum);  // update the value of the variable maxSum
        }
        return maxSum;  // return the maximum sum
    }
}

53. Maximum Subarray in python

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution(object):
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """ 
        maxSum = nums[0]  # variable to store the maximum sum
        currSum = nums[0]  # variable to store the current sum
        for i in range(1, len(nums)):  # iterate through the vector nums
            currSum = max(nums[i], currSum + nums[i])  # update the value of the variable currSum
            maxSum = max(maxSum, currSum)  # update the value of the variable maxSum
        return maxSum  # return the maximum sum

53. Maximum Subarray in python3

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        maxSum = nums[0]  # variable to store the maximum sum
        currSum = nums[0]  # variable to store the current sum
        for i in range(1, len(nums)):  # iterate through the vector nums
            currSum = max(nums[i], currSum + nums[i])  # update the value of the variable currSum
            maxSum = max(maxSum, currSum)  # update the value of the variable maxSum
        return maxSum  # return the maximum sum

53. Maximum Subarray in c

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

int maxSubArray(int* nums, int numsSize){
    int maxSum = nums[0];  // variable to store the maximum sum
    int currSum = nums[0];  // variable to store the current sum
    for(int i = 1; i < numsSize; i++){  // iterate through the vector nums
        currSum = fmax(nums[i], currSum + nums[i]);  // update the value of the variable currSum
        maxSum = fmax(maxSum, currSum);  // update the value of the variable maxSum
    }
    return maxSum;  // return the maximum sum
}

53. Maximum Subarray in c#

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

public class Solution {
    public int MaxSubArray(int[] nums) {
        int maxSum = nums[0];  // variable to store the maximum sum
        int currSum = nums[0];  // variable to store the current sum
        for(int i = 1; i < nums.Length; i++){  // iterate through the vector nums
            currSum = Math.Max(nums[i], currSum + nums[i]);  // update the value of the variable currSum
            maxSum = Math.Max(maxSum, currSum);  // update the value of the variable maxSum
        }
        return maxSum;  // return the maximum sum
    }
}

53. Maximum Subarray in javascript

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

var maxSubArray = function(nums) {
    let maxSum = nums[0];  // variable to store the maximum sum
    let currSum = nums[0];  // variable to store the current sum
    for(let i = 1; i < nums.length; i++){  // iterate through the vector nums
        currSum = Math.max(nums[i], currSum + nums[i]);  // update the value of the variable currSum
        maxSum = Math.max(maxSum, currSum);  // update the value of the variable maxSum
    }
    return maxSum;  // return the maximum sum
};

53. Maximum Subarray in Swift

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    func maxSubArray(_ nums: [Int]) -> Int {
        var maxSum = nums[0]  // variable to store the maximum sum
        var currSum = nums[0]  // variable to store the current sum
        for i in 1..<nums.count {  // iterate through the vector nums
            currSum = max(nums[i], currSum + nums[i])  // update the value of the variable currSum
            maxSum = max(maxSum, currSum)  // update the value of the variable maxSum
        }
        return maxSum  // return the maximum sum
    }
}

54. Spiral Matrix in c++

// Time Complexity : O(m * n) where m is the number of rows and n is the number of columns and space complexity is O(1)

class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> result;  // vector to store the result
        if(matrix.size() == 0){  // if the matrix is empty
            return result;  // return the result
        }
        int m = matrix.size();  // variable to store the number of rows
        int n = matrix[0].size();  // variable to store the number of columns
        int top = 0;  // variable to store the top row
        int bottom = m - 1;  // variable to store the bottom row
        int left = 0;  // variable to store the left column
        int right = n - 1;  // variable to store the right column
        while(top <= bottom && left <= right){  // iterate until the top row is less than or equal to the bottom row and the left column is less than or equal to the right column
            for(int i = left; i <= right; i++){  // iterate through the top row
                result.push_back(matrix[top][i]);  // push the element to the result
            }
            top++;  // increment the top row
            for(int i = top; i <= bottom; i++){  // iterate through the right column
                result.push_back(matrix[i][right]);  // push the element to the result
            }
            right--;  // decrement the right column
            if(top <= bottom){  // if the top row is less than or equal to the bottom row
                for(int i = right; i >= left; i--){  // iterate through the bottom row
                    result.push_back(matrix[bottom][i]);  // push the element to the result
                }
                bottom--;  // decrement the bottom row
            }
            if(left <= right){  // if the left column is less than or equal to the right column
                for(int i = bottom; i >= top; i--){  // iterate through the left column
                    result.push_back(matrix[i][left]);  // push the element to the result
                }
                left++;  // increment the left column
            }
        }
        return result;  // return the result
    }
};

54. Spiral Matrix in java

// Time Complexity : O(m * n) where m is the number of rows and n is the number of columns and space complexity is O(1)

class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> result = new ArrayList<>();  // list to store the result
        if(matrix.length == 0){  // if the matrix is empty
            return result;  // return the result
        }
        int m = matrix.length;  // variable to store the number of rows
        int n = matrix[0].length;  // variable to store the number of columns
        int top = 0;  // variable to store the top row
        int bottom = m - 1;  // variable to store the bottom row
        int left = 0;  // variable to store the left column
        int right = n - 1;  // variable to store the right column
        while(top <= bottom && left <= right){  // iterate until the top row is less than or equal to the bottom row and the left column is less than or equal to the right column
            for(int i = left; i <= right; i++){  // iterate through the top row
                result.add(matrix[top][i]);  // add the element to the result
            }
            top++;  // increment the top row
            for(int i = top; i <= bottom; i++){  // iterate through the right column
                result.add(matrix[i][right]);  // add the element to the result
            }
            right--;  // decrement the right column
            if(top <= bottom){  // if the top row is less than or equal to the bottom row
                for(int i = right; i >= left; i--){  // iterate through the bottom row
                    result.add(matrix[bottom][i]);  // add the element to the result
                }
                bottom--;  // decrement the bottom row
            }
            if(left <= right){  // if the left column is less than or equal to the right column
                for(int i = bottom; i >= top; i--){  // iterate through the left column
                    result.add(matrix[i][left]);  // add the element to the result
                }
                left++;  // increment the left column
            }
        }
        return result;  // return the result
    }
}

54. Spiral Matrix in python

// Time Complexity : O(m * n) where m is the number of rows and n is the number of columns and space complexity is O(1)

class Solution(object):
    def spiralOrder(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """ 
        result = []  # list to store the result
        if len(matrix) == 0:  # if the matrix is empty
            return result  # return the result
        m = len(matrix)  # variable to store the number of rows
        n = len(matrix[0])  # variable to store the number of columns
        top = 0  # variable to store the top row
        bottom = m - 1  # variable to store the bottom row
        left = 0  # variable to store the left column
        right = n - 1  # variable to store the right column
        while top <= bottom and left <= right:  # iterate until the top row is less than or equal to the bottom row and the left column is less than or equal to the right column
            for i in range(left, right + 1):  # iterate through the top row
                result.append(matrix[top][i])  # append the element to the result
            top += 1  # increment the top row
            for i in range(top, bottom + 1):  # iterate through the right column
                result.append(matrix[i][right])  # append the element to the result
            right -= 1  # decrement the right column
            if top <= bottom:  # if the top row is less than or equal to the bottom row
                for i in range(right, left - 1, -1):  # iterate through the bottom row
                    result.append(matrix[bottom][i])  # append the element to the result
                bottom -= 1  # decrement the bottom row
            if left <= right:  # if the left column is less than or equal to the right column
                for i in range(bottom, top - 1, -1):  # iterate through the left column
                    result.append(matrix[i][left])  # append the element to the result
                left += 1  # increment the left column
        return result  # return the result

54. Spiral Matrix in python3

// Time Complexity : O(m * n) where m is the number of rows and n is the number of columns and space complexity is O(1)

class Solution:
    def spiralOrder(self, matrix: List[List[int]) -> List[int]:  // add the missing bracket after List[int] and add the missing colon after List[int] and add the missing colon after List[int]
        result = []  # list to store the result
        if len(matrix) == 0:  # if the matrix is empty
            return result  # return the result
        m = len(matrix)  # variable to store the number of rows
        n = len(matrix[0])  # variable to store the number of columns
        top = 0  # variable to store the top row
        bottom = m - 1  # variable to store the bottom row
        left = 0  # variable to store the left column
        right = n - 1  # variable to store the right column
        while top <= bottom and left <= right:  # iterate until the top row is less than or equal to the bottom row and the left column is less than or equal to the right column
            for i in range(left, right + 1):  # iterate through the top row
                result.append(matrix[top][i])  # append the element to the result
            top += 1  # increment the top row
            for i in range(top, bottom + 1):  # iterate through the right column
                result.append(matrix[i][right])  # append the element to the result
            right -= 1  # decrement the right column
            if top <= bottom:  # if the top row is less than or equal to the bottom row
                for i in range(right, left - 1, -1):  # iterate through the bottom row
                    result.append(matrix[bottom][i])  # append the element to the result
                bottom -= 1  # decrement the bottom row
            if left <= right:  # if the left column is less than or equal to the right column
                for i in range(bottom, top - 1, -1):  # iterate through the left column
                    result.append(matrix[i][left])  # append the element to the result
                left += 1  # increment the left column
        return result  # return the result

54. Spiral Matrix in c

// Time Complexity : O(m * n) where m is the number of rows and n is the number of columns and space complexity is O(1)

int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize){
    int* result = (int*)malloc(sizeof(int) * matrixSize * matrixColSize[0]);  // vector to store the result
    *returnSize = 0;  // variable to store the size of the result
    if(matrixSize == 0){  // if the matrix is empty
        return result;  // return the result
    }
    int m = matrixSize;  // variable to store the number of rows
    int n = matrixColSize[0];  // variable to store the number of columns
    int top = 0;  // variable to store the top row
    int bottom = m - 1;  // variable to store the bottom row
    int left = 0;  // variable to store the left column
    int right = n - 1;  // variable to store the right column
    while(top <= bottom && left <= right){  // iterate until the top row is less than or equal to the bottom row and the left column is less than or equal to the right column
        for(int i = left; i <= right; i++){  // iterate through the top row
            result[(*returnSize)++] = matrix[top][i];  // push the element to the result
        }
        top++;  // increment the top row
        for(int i = top; i <= bottom; i++){  // iterate through the right column
            result[(*returnSize)++] = matrix[i][right];  // push the element to the result
        }
        right--;  // decrement the right column
        if(top <= bottom){  // if the top row is less than or equal to the bottom row
            for(int i = right; i >= left; i--){  // iterate through the bottom row
                result[(*returnSize)++] = matrix[bottom][i];  // push the element to the result
            }
            bottom--;  // decrement the bottom row
        }
        if(left <= right){  // if the left column is less than or equal to the right column
            for(int i = bottom; i >= top; i--){  // iterate through the left column
                result[(*returnSize)++] = matrix[i][left];  // push the element to the result
            }
            left++;  // increment the left column
        }
    }
    return result;  // return the result
}

54. Spiral Matrix in c#

// Time Complexity : O(m * n) where m is the number of rows and n is the number of columns and space complexity is O(1)

public class Solution {
    public IList<int> SpiralOrder(int[][] matrix) {
        IList<int> result = new List<int>();  // list to store the result
        if(matrix.Length == 0){  // if the matrix is empty
            return result;  // return the result
        }
        int m = matrix.Length;  // variable to store the number of rows
        int n = matrix[0].Length;  // variable to store the number of columns
        int top = 0;  // variable to store the top row
        int bottom = m - 1;  // variable to store the bottom row
        int left = 0;  // variable to store the left column
        int right = n - 1;  // variable to store the right column
        while(top <= bottom && left <= right){  // iterate until the top row is less than or equal to the bottom row and the left column is less than or equal to the right column
            for(int i = left; i <= right; i++){  // iterate through the top row
                result.Add(matrix[top][i]);  // add the element to the result
            }
            top++;  // increment the top row
            for(int i = top; i <= bottom; i++){  // iterate through the right column
                result.Add(matrix[i][right]);  // add the element to the result
            }
            right--;  // decrement the right column
            if(top <= bottom){  // if the top row is less than or equal to the bottom row
                for(int i = right; i >= left; i--){  // iterate through the bottom row
                    result.Add(matrix[bottom][i]);  // add the element to the result
                }
                bottom--;  // decrement the bottom row
            }
            if(left <= right){  // if the left column is less than or equal to the right column
                for(int i = bottom; i >= top; i--){  // iterate through the left column
                    result.Add(matrix[i][left]);  // add the element to the result
                }
                left++;  // increment the left column
            }
        }
        return result;  // return the result
    }
}

54. Spiral Matrix in javascript

// Time Complexity : O(m * n) where m is the number of rows and n is the number of columns and space complexity is O(1)

var spiralOrder = function(matrix) {
    let result = [];  // list to store the result
    if(matrix.length == 0){  // if the matrix is empty
        return result;  // return the result
    }
    let m = matrix.length;  // variable to store the number of rows
    let n = matrix[0].length;  // variable to store the number of columns
    let top = 0;  // variable to store the top row
    let bottom = m - 1;  // variable to store the bottom row
    let left = 0;  // variable to store the left column
    let right = n - 1;  // variable to store the right column
    while(top <= bottom && left <= right){  // iterate until the top row is less than or equal to the bottom row and the left column is less than or equal to the right column
        for(let i = left; i <= right; i++){  // iterate through the top row
            result.push(matrix[top][i]);  // push the element to the result
        }
        top++;  // increment the top row
        for(let i = top; i <= bottom; i++){  // iterate through the right column
            result.push(matrix[i][right]);  // push the element to the result
        }
        right--;  // decrement the right column
        if(top <= bottom){  // if the top row is less than or equal to the bottom row
            for(let i = right; i >= left; i--){  // iterate through the bottom row
                result.push(matrix[bottom][i]);  // push the element to the result
            }
            bottom--;  // decrement the bottom row
        }
        if(left <= right){  // if the left column is less than or equal to the right column
            for(let i = bottom; i >= top; i--){  // iterate through the left column
                result.push(matrix[i][left]);  // push the element to the result
            }
            left++;  // increment the left column
        }
    }
    return result;  // return the result
};

54. Spiral Matrix in Swift

// Time Complexity : O(m * n) where m is the number of rows and n is the number of columns and space complexity is O(1)

class Solution {
    func spiralOrder(_ matrix: [[Int]]) -> [Int] {
        guard !matrix.isEmpty else {  // if the matrix is empty
            return []  // return the result
        }
        var result = [Int]()  // list to store the result
        let m = matrix.count  // variable to store the number of rows
        let n = matrix[0].count  // variable to store the number of columns
        var top = 0  // variable to store the top row
        var bottom = m - 1  // variable to store the bottom row
        var left = 0  // variable to store the left column
        var right = n - 1  // variable to store the right column
        var count  = matrix.count * matrix[0].count  // variable to store the size of the result
        while result.count <  count  { // iterate until the size of the result is less than the size of the result
            if result.count < count{ // if the size of the result is less than the size of the result
                for i in left...right {  // iterate through the top row
                    result.append(matrix[top][i])  // append the element to the result
                }
                top += 1  // increment the top row
            }
            if result.count < count{  // if the size of the result is less than the size of the result
                for i in top...bottom {  // iterate through the right column
                    result.append(matrix[i][right])  // append the element to the result
                }
                right -= 1  // decrement the right column
            }
            if result.count < count{  // if the size of the result is less than the size of the result
                for i in (left...right).reversed() {  // iterate through the bottom row
                    result.append(matrix[bottom][i])  // append the element to the result
                }
                bottom -= 1  // decrement the bottom row
            }
            if result.count < count{  // if the size of the result is less than the size of the result
                for i in (top...bottom).reversed() {  // iterate through the left column
                    result.append(matrix[i][left])  // append the element to the result
                }
                left += 1  // increment the left column
            }
        }
        return result  // return the result
    }
}

2nd Method 

// Time Complexity : O(m * n) where m is the number of rows and n is the number of columns and space complexity is O(1)

class Solution {
    func spiralOrder(_ matrix: [[Int]]) -> [Int] {
        guard !matrix.isEmpty else {
            return []
        }
        
        var result = [Int]()
        var top = 0
        var bottom = matrix.count - 1
        var left = 0
        var right = matrix[0].count - 1
        var count = matrix.count * matrix[0].count
        
        while result.count <  count  {
            // Traverse top row
            if result.count < count{
                for i in left...right {
                result.append(matrix[top][i])
            }
            }
            top += 1
            
            // Traverse rightmost column
            if result.count < count{
                for i in top...bottom {
                result.append(matrix[i][right])
            }
            }
            right -= 1
            
            if result.count < count{
                // Traverse bottom row
                for i in stride(from: right, through: left, by: -1) {
                    result.append(matrix[bottom][i])
                }
                bottom -= 1
            }
            
            if result.count < count {
                // Traverse leftmost column
                for i in stride(from: bottom, through: top, by: -1) {
                    result.append(matrix[i][left])
                }
                left += 1
            }
        }
        
        return result
    }
}

55. Jump Game in c++

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    bool canJump(vector<int>& nums) {    // canJump function
        int n = nums.size();  // n = nums.size()
        int maxReach = 0;  //   maxReach = 0
        for(int i=0; i<n; i++){ //   loop for i
            if(i>maxReach) return false;  //  if condition is true
            maxReach = max(maxReach, i+nums[i]);   // maxReach = max(maxReach, i+nums[i])  
        }
        return true; // return true
    }
};

55. Jump Game in java

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public boolean canJump(int[] nums) {    // canJump function
        int n = nums.length;  // n = nums.length
        int maxReach = 0;  //   maxReach = 0
        for(int i=0; i<n; i++){ //   loop for i
            if(i>maxReach) return false;  //  if condition is true
            maxReach = Math.max(maxReach, i+nums[i]);   // maxReach = max(maxReach, i+nums[i])  
        }
        return true; // return true
    }
}

55. Jump Game in python

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution(object):
    def canJump(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """ 
        n = len(nums)  # n = len(nums)
        maxReach = 0  # maxReach = 0
        for i in range(n):  # loop for i
            if i > maxReach:  # if condition is true
                return False  # return False
            maxReach = max(maxReach, i + nums[i])  # maxReach = max(maxReach, i+nums[i])  
        return True  # return True

55. Jump Game in python3

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution:
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)  # n = len(nums)
        maxReach = 0  # maxReach = 0
        for i in range(n):  # loop for i
            if i > maxReach:  # if condition is true
                return False  # return False
            maxReach = max(maxReach, i + nums[i])  # maxReach = max(maxReach, i+nums[i])  
        return True  # return True

55. Jump Game in c

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

bool canJump(int* nums, int numsSize){
    int n = numsSize;  // n = numsSize
    int maxReach = 0;  // maxReach = 0
    for(int i=0; i<n; i++){ //   loop for i
        if(i>maxReach) return false;  //  if condition is true
        maxReach = fmax(maxReach, i+nums[i]);   // maxReach = max(maxReach, i+nums[i])  
    }
    return true; // return true
}

55. Jump Game in c#

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

public class Solution {
    public bool CanJump(int[] nums) {    // canJump function
        int n = nums.Length;  // n = nums.Length
        int maxReach = 0;  //   maxReach = 0
        for(int i=0; i<n; i++){ //   loop for i
            if(i>maxReach) return false;  //  if condition is true
            maxReach = Math.Max(maxReach, i+nums[i]);   // maxReach = max(maxReach, i+nums[i])  
        }
        return true; // return true
    }
}

55. Jump Game in javascript

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

var canJump = function(nums) {
    let n = nums.length;  // n = nums.length
    let maxReach = 0;  //   maxReach = 0
    for(let i=0; i<n; i++){ //   loop for i
        if(i>maxReach) return false;  //  if condition is true
        maxReach = Math.max(maxReach, i+nums[i]);   // maxReach = max(maxReach, i+nums[i])  
    }
    return true; // return true
};

55. Jump Game in Swift

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    func canJump(_ nums: [Int]) -> Bool {
        var n = nums.count  // n = nums.count
        var maxReach = 0  //   maxReach = 0
        for i in 0..<n { //   loop for i
            if i > maxReach {  //  if condition is true
                return false  //  return false
            }
            maxReach = max(maxReach, i + nums[i])  // maxReach = max(maxReach, i+nums[i])  
        }
        return true  // return true
    }
}

56. Merge Intervals in c++

// Time Complexity : O(nlogn) where n is the size of the vector intervals and space complexity is O(1)

class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
         vector<vector<int>> merge; // vector to store the result
         sort(intervals.begin(), intervals.end()); // sort the vector intervals
         for(auto it : intervals){ // iterate through the vector intervals
             if(merge.empty() || merge.back()[1] < it[0]){ // if the vector merge is empty or the last elemet of the vector merge is less than the first element of the vector it
                 merge.push_back(it); // push the vector it to the vector merge
             }
             else{ // else
                 merge.back()[1] = max(merge.back()[1], it[1]); // update the last element of the vector merge
             }
         }
        return merge; // return the vector merge
    }
};

56. Merge Intervals in java

// Time Complexity : O(nlogn) where n is the size of the vector intervals and space complexity is O(1)

class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0])); // sort the vector intervals
        LinkedList<int[]> merge = new LinkedList<>(); // vector to store the result
        for(int[] it : intervals){ // iterate through the vector intervals
            if(merge.isEmpty() || merge.getLast()[1] < it[0]){ // if the vector merge is empty or the last element of the vector merge is less than the first element of the vector it
                merge.add(it); // push the vector it to the vector merge
            }
            else{ // else
                merge.getLast()[1] = Math.max(merge.getLast()[1], it[1]); // update the last element of the vector merge
            }
        }
        return merge.toArray(new int[merge.size()][]); // return the vector merge
    }
}

56. Merge Intervals in python

// Time Complexity : O(nlogn) where n is the size of the vector intervals and space complexity is O(1)

class Solution(object):
    def merge(self, intervals):
        """
        :type intervals: List[List[int]]
        :rtype: List[List[int]]
        """ 
        intervals.sort(key = lambda x: x[0])  # sort the vector intervals
        merge = []  # vector to store the result
        for it in intervals:  # iterate through the vector intervals
            if not merge or merge[-1][1] < it[0]:  # if the vector merge is empty or the last element of the vector merge is less than the first element of the vector it
                merge.append(it)  # push the vector it to the vector merge
            else:  # else
                merge[-1][1] = max(merge[-1][1], it[1])  # update the last element of the vector merge
        return merge  # return the vector merge

56. Merge Intervals in python3

// Time Complexity : O(nlogn) where n is the size of the vector intervals and space complexity is O(1)

class Solution:
    def merge(self, intervals: List[List[int]) -> List[List[int]]:  // add the missing bracket after List[int] and add the missing colon after List[int] and add the missing colon after List[int]
        intervals.sort(key = lambda x: x[0])  # sort the vector intervals
        merge = []  # vector to store the result
        for it in intervals:  # iterate through the vector intervals
            if not merge or merge[-1][1] < it[0]:  # if the vector merge is empty or the last element of the vector merge is less than the first element of the vector it
                merge.append(it)  # push the vector it to the vector merge
            else:  # else
                merge[-1][1] = max(merge[-1][1], it[1])  # update the last element of the vector merge
        return merge  # return the vector merge

56. Merge Intervals in c

// Time Complexity : O(nlogn) where n is the size of the vector intervals and space complexity is O(1)

int compare(const void* a, const void* b){  // compare function
    return (*(int**)a)[0] - (*(int**)b)[0];  // return the difference of the first element of the vector a and the first element of the vector b
}

int** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes){
    qsort(intervals, intervalsSize, sizeof(int*), compare);  // sort the vector intervals
    int** merge = (int**)malloc(sizeof(int*) * intervalsSize);  // vector to store the result
    *returnSize = 0;  // variable to store the size of the result
    for(int i = 0; i < intervalsSize; i++){  // iterate through the vector intervals
        if(*returnSize == 0 || merge[*returnSize - 1][1] < intervals[i][0]){  // if the vector merge is empty or the last element of the vector merge is less than the first element of the vector it
            merge[*returnSize] = intervals[i];  // push the vector it to the vector merge
            (*returnSize)++;  // increment the size of the result
        }
        else{  // else
            merge[*returnSize - 1][1] = fmax(merge[*returnSize - 1][1], intervals[i][1]);  // update the last element of the vector merge
        }
    }
    *returnColumnSizes = (int*)malloc(sizeof(int) * (*returnSize));  // variable to store the size of the result
    for(int i = 0; i < *returnSize; i++){  // iterate through the vector intervals
        (*returnColumnSizes)[i] = 2;  // update the size of the result
    }
    return merge;  // return the vector merge
}

56. Merge Intervals in c#

// Time Complexity : O(nlogn) where n is the size of the vector intervals and space complexity is O(1)

public class Solution {
    public int[][] Merge(int[][] intervals) {
        Array.Sort(intervals, (a, b) => a[0] - b[0]);  // sort the vector intervals
        List<int[]> merge = new List<int[]>();  // vector to store the result
        foreach(int[] it in intervals){  // iterate through the vector intervals
            if(merge.Count == 0 || merge[merge.Count - 1][1] < it[0]){  // if the vector merge is empty or the last element of the vector merge is less than the first element of the vector it
                merge.Add(it);  // push the vector it to the vector merge
            }
            else{  // else
                merge[merge.Count - 1][1] = Math.Max(merge[merge.Count - 1][1], it[1]);  // update the last element of the vector merge
            }
        }
        return merge.ToArray();  // return the vector merge
    }
}

56. Merge Intervals in javascript

// Time Complexity : O(nlogn) where n is the size of the vector intervals and space complexity is O(1)

var merge = function(intervals) {
    intervals.sort((a, b) => a[0] - b[0]);  // sort the vector intervals
    let merge = [];  // vector to store the result
    for(let it of intervals){  // iterate through the vector intervals
        if(merge.length == 0 || merge[merge.length - 1][1] < it[0]){  // if the vector merge is empty or the last element of the vector merge is less than the first element of the vector it
            merge.push(it);  // push the vector it to the vector merge
        }
        else{  // else
            merge[merge.length - 1][1] = Math.max(merge[merge.length - 1][1], it[1]);  // update the last element of the vector merge
        }
    }
    return merge;  // return the vector merge
};

56. Merge Intervals in Swift

// Time Complexity : O(nlogn) where n is the size of the vector intervals and space complexity is O(1)

class Solution {
    func merge(_ intervals: [[Int]]) -> [[Int]] {
        var intervals = intervals.sorted(by: { $0[0] < $1[0] })  // sort the vector intervals
        var merge = [[Int]]()  // vector to store the result
        for it in intervals{  // iterate through the vector intervals
            if merge.isEmpty || merge[merge.count - 1][1] < it[0]{  // if the vector merge is empty or the last element of the vector merge is less than the first element of the vector it
                merge.append(it)  // push the vector it to the vector merge
            }
            else{  // else
                merge[merge.count - 1][1] = max(merge[merge.count - 1][1], it[1])  // update the last element of the vector merge
            }
        }
        return merge  // return the vector merge
    }
}

57. Insert Interval in c++

// Time Complexity : O(n) where n is the size of the vector intervals and space complexity is O(1)

class Solution { // Time Complexity O(N) and Space Complexity O(1)
public:  // function to insert the interval in the vector of intervals
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {  // function to insert the interval in the vector of intervals
        int n = intervals.size();  // n is the size of the vector of intervals
        int start = newInterval[0]; // start is the start of the interval
        int end = newInterval[1]; // end is the end of the interval
        int i = 0; // i is the index of the interval
        vector<vector<int>> result;  // result is the vector of intervals after inserting the interval
        while(i<n && intervals[i][1] < start){  // while the end of the interval is less than the start of the interval
            result.push_back(intervals[i]);   // push the interval in the result    
            i++;                      // increment the index of the interval
        }
        while(i<n && intervals[i][0] <= end){       // while the start of the interval is less than or equal to the end of the interval
            start = min(start, intervals[i][0]);        // update the start of the interval
            end = max(end, intervals[i][1]);        // update the end of the interval
            i++;              // increment the in interval
        }
        result.push_back({start, end});     // push the interval in the result
        while(i<n){                         // while the index of the interval is less than the size of the vector of intervals
            result.push_back(intervals[i]);     // push the interval in the result
            i++;          // increment the index of the interval
        }
        return result;      // return the result
    }
};

57. Insert Interval in java

// Time Complexity : O(n) where n is the size of the vector intervals and space complexity is O(1)

class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {  // function to insert the interval in the vector of intervals
        int n = intervals.length;  // n is the size of the vector of intervals
        int start = newInterval[0]; // start is the start of the interval
        int end = newInterval[1]; // end is the end of the interval
        int i = 0; // i is the index of the interval
        List<int[]> result = new ArrayList<>();  // result is the vector of intervals after inserting the interval
        while(i<n && intervals[i][1] < start){  // while the end of the interval is less than the start of the interval
            result.add(intervals[i]);   // push the interval in the result    
            i++;                      // increment the index of the interval
        }
        while(i<n && intervals[i][0] <= end){       // while the start of the interval is less than or equal to the end of the interval
            start = Math.min(start, intervals[i][0]);        // update the start of the interval
            end = Math.max(end, intervals[i][1]);        // update the end of the interval
            i++;              // increment the in interval
        }
        result.add(new int[]{start, end});     // push the interval in the result
        while(i<n){                         // while the index of the interval is less than the size of the vector of intervals
            result.add(intervals[i]);     // push the interval in the result
            i++;          // increment the index of the interval
        }
        return result.toArray(new int[result.size()][]);      // return the result
    }
}

57. Insert Interval in python

// Time Complexity : O(n) where n is the size of the vector intervals and space complexity is O(1)

class Solution(object):
    def insert(self, intervals, newInterval):
        """
        :type intervals: List[List[int]]
        :type newInterval: List[int]
        :rtype: List[List[int]]
        """ 
        n = len(intervals)  # n is the size of the vector of intervals
        start = newInterval[0]  # start is the start of the interval
        end = newInterval[1]  # end is the end of the interval
        i = 0  # i is the index of the interval
        result = []  # result is the vector of intervals after inserting the interval
        while i < n and intervals[i][1] < start:  # while the end of the interval is less than the start of the interval
            result.append(intervals[i])  # push the interval in the result    
            i += 1  # increment the index of the interval
        while i < n and intervals[i][0] <= end:  # while the start of the interval is less than or equal to the end of the interval
            start = min(start, intervals[i][0])  # update the start of the interval
            end = max(end, intervals[i][1])  # update the end of the interval
            i += 1  # increment the in interval
        result.append([start, end])  # push the interval in the result
        while i < n:  # while the index of the interval is less than the size of the vector of intervals
            result.append(intervals[i])  # push the interval in the result
            i += 1  # increment the index of the interval
        return result  # return the result

57. Insert Interval in python3

// Time Complexity : O(n) where n is the size of the vector intervals and space complexity is O(1)

class Solution:
    def insert(self, intervals: List[List[int], newInterval: List[int]) -> List[List[int]]:  // add the missing bracket after List[int] and add the missing colon after List[int] and add the missing colon after List[int]
        n = len(intervals)  # n is the size of the vector of intervals
        start = newInterval[0]  # start is the start of the interval
        end = newInterval[1]  # end is the end of the interval
        i = 0  # i is the index of the interval
        result = []  # result is the vector of intervals after inserting the interval
        while i < n and intervals[i][1] < start:  # while the end of the interval is less than the start of the interval
            result.append(intervals[i])  # push the interval in the result    
            i += 1  # increment the index of the interval
        while i < n and intervals[i][0] <= end:  # while the start of the interval is less than or equal to the end of the interval
            start = min(start, intervals[i][0])  # update the start of the interval
            end = max(end, intervals[i][1])  # update the end of the interval
            i += 1  # increment the in interval
        result.append([start, end])  # push the interval in the result
        while i < n:  # while the index of the interval is less than the size of the vector of intervals
            result.append(intervals[i])  # push the interval in the result
            i += 1  # increment the index of the interval
        return result  # return the result

57. Insert Interval in c#

// Time Complexity : O(n) where n is the size of the vector intervals and space complexity is O(1)

public class Solution {
    public int[][] Insert(int[][] intervals, int[]   newInterval) {
        int n = intervals.Length;  // n is the size of the vector of intervals
        int start = newInterval[0];  // start is the start of the interval
        int end = newInterval[1];  // end is the end of the interval
        int i = 0;  // i is the index of the interval
        List<int[]> result = new List<int[]>();  // result is the vector of intervals after inserting the interval
        while(i < n && intervals[i][1] < start){  // while the end of the interval is less than the start of the interval
            result.Add(intervals[i]);  // push the interval in the result    
            i++;  // increment the index of the interval
        }
        while(i < n && intervals[i][0] <= end){  // while the start of the interval is less than or equal to the end of the interval
            start = Math.Min(start, intervals[i][0]);  // update the start of the interval
            end = Math.Max(end, intervals[i][1]);  // update the end of the interval
            i++;  // increment the in interval
        }
        result.Add(new int[]{start, end});  // push the interval in the result
        while(i < n){  // while the index of the interval is less than the size of the vector of intervals
            result.Add(intervals[i]);  // push the interval in the result
            i++;  // increment the index of the interval
        }
        return result.ToArray();  // return the result
    }
}

57. Insert Interval in javascript

// Time Complexity : O(n) where n is the size of the vector intervals and space complexity is O(1)

var insert = function(intervals, newInterval) {
    let n = intervals.length;  // n is the size of the vector of intervals
    let start = newInterval[0];  // start is the start of the interval
    let end = newInterval[1];  // end is the end of the interval
    let i = 0;  // i is the index of the interval
    let result = [];  // result is the vector of intervals after inserting the interval
    while(i < n && intervals[i][1] < start){  // while the end of the interval is less than the start of the interval
        result.push(intervals[i]);  // push the interval in the result    
        i++;  // increment the index of the interval
    }
    while(i < n && intervals[i][0] <= end){  // while the start of the interval is less than or equal to the end of the interval
        start = Math.min(start, intervals[i][0]);  // update the start of the interval
        end = Math.max(end, intervals[i][1]);  // update the end of the interval
        i++;  // increment the in interval
    }
    result.push([start, end]);  // push the interval in the result
    while(i < n){  // while the index of the interval is less than the size of the vector of intervals
        result.push(intervals[i]);  // push the interval in the result
        i++;  // increment the index of the interval
    }
    return result;  // return the result
};

57. Insert Interval in Swift

// Time Complexity : O(n) where n is the size of the vector intervals and space complexity is O(1)

class Solution {
    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {
        var n = intervals.count;  // n is the size of the vector of intervals
        var start = newInterval[0];  // start is the start of the interval
        var end = newInterval[1];  // end is the end of the interval
        var i = 0;  // i is the index of the interval
        var result = [[Int]]();  // result is the vector of intervals after inserting the interval
        while i < n && intervals[i][1] < start {  // while the end of the interval is less than the start of the interval
            result.append(intervals[i]);  // push the interval in the result    
            i += 1;  // increment the index of the interval
        }
        while i < n && intervals[i][0] <= end {  // while the start of the interval is less than or equal to the end of the interval
            start = min(start, intervals[i][0]);  // update the start of the interval
            end = max(end, intervals[i][1]);  // update the end of the interval
            i += 1;  // increment the in interval
        }
        result.append([start, end]);  // push the interval in the result
        while i < n {  // while the index of the interval is less than the size of the vector of intervals
            result.append(intervals[i]);  // push the interval in the result
            i += 1;  // increment the index of the interval
        }
        return result;  // return the result
    }
}

58. Length of Last Word in c++

// Time Complexity : O(n) where n is the size of the string s and space complexity is O(1)

class Solution {
public:
    int lengthOfLastWord(string s) {
        int n = s.size(); // n is the size of the string s
        int count = 0; // count is the length of the last word
        for(int i=n-1; i>=0; i--){ // loop for i
            if(s[i] == ' ' && count > 0) break; // if the character is space and count is greater than 0
            else if(s[i] != ' ') count++; // else if the character is not space
        }
        return count; // return the count
    }
};

58. Length of Last Word in java

// Time Complexity : O(n) where n is the size of the string s and space complexity is O(1)

class Solution {
    public int lengthOfLastWord(String s) {
        int n = s.length(); // n is the size of the string s
        int count = 0; // count is the length of the last word
        for(int i=n-1; i>=0; i--){ // loop for i
            if(s.charAt(i) == ' ' && count > 0) break; // if the character is space and count is greater than 0
            else if(s.charAt(i) != ' ') count++; // else if the character is not space
        }
        return count; // return the count
    }
}

58. Length of Last Word in python

// Time Complexity : O(n) where n is the size of the string s and space complexity is O(1)

class Solution(object):
    def lengthOfLastWord(self, s):
        """
        :type s: str
        :rtype: int
        """ 
        n = len(s)  # n is the size of the string s
        count = 0  # count is the length of the last word
        for i in range(n-1, -1, -1):  # loop for i
            if s[i] == ' ' and count > 0:  # if the character is space and count is greater than 0
                break  # break
            elif s[i] != ' ':  # else if the character is not space
                count += 1  # increment the count
        return count  # return the count

58. Length of Last Word in python3

// Time Complexity : O(n) where n is the size of the string s and space complexity is O(1)

class Solution:
    def lengthOfLastWord(self, s: str) -> int:  // add the missing colon after str
        n = len(s)  # n is the size of the string s
        count = 0  # count is the length of the last word
        for i in range(n-1, -1, -1):  # loop for i
            if s[i] == ' ' and count > 0:  # if the character is space and count is greater than 0
                break  # break
            elif s[i] != ' ':  # else if the character is not space
                count += 1  # increment the count
        return count  # return the count

58. Length of Last Word in c

// Time Complexity : O(n) where n is the size of the string s and space complexity is O(1)

int lengthOfLastWord(char * s){
    int n = strlen(s);  // n is the size of the string s
    int count = 0;  // count is the length of the last word
    for(int i=n-1; i>=0; i--){  // loop for i
        if(s[i] == ' ' && count > 0) break;  // if the character is space and count is greater than 0
        else if(s[i] != ' ') count++;  // else if the character is not space
    }
    return count;  // return the count
}

58. Length of Last Word in c#

// Time Complexity : O(n) where n is the size of the string s and space complexity is O(1)

public class Solution {
    public int LengthOfLastWord(string s) {
        int n = s.Length;  // n is the size of the string s
        int count = 0;  // count is the length of the last word
        for(int i=n-1; i>=0; i--){  // loop for i
            if(s[i] == ' ' && count > 0) break;  // if the character is space and count is greater than 0
            else if(s[i] != ' ') count++;  // else if the character is not space
        }
        return count;  // return the count
    }
}

58. Length of Last Word in javascript

// Time Complexity : O(n) where n is the size of the string s and space complexity is O(1)

var lengthOfLastWord = function(s) {
    let n = s.length;  // n is the size of the string s
    let count = 0;  // count is the length of the last word
    for(let i=n-1; i>=0; i--){  // loop for i
        if(s[i] == ' ' && count > 0) break;  // if the character is space and count is greater than 0
        else if(s[i] != ' ') count++;  // else if the character is not space
    }
    return count;  // return the count
};

58. Length of Last Word in Swift

// Time Complexity : O(n) where n is the size of the string s and space complexity is O(1)

class Solution {
    func lengthOfLastWord(_ s: String) -> Int {
        let n = s.count;  // n is the size of the string s
        var count = 0;  // count is the length of the last word
        for i in stride(from: n-1, through: 0, by: -1){  // loop for i
            if s[s.index(s.startIndex, offsetBy: i)] == " " && count > 0{  // if the character is space and count is greater than 0
                break;  // break
            }
            else if s[s.index(s.startIndex, offsetBy: i)] != " "{  // else if the character is not space
                count += 1;  // increment the count
            }
        }
        return count;  // return the count
    }
}

2nd Method

// Time Complexity : O(n) where n is the size of the string s and space complexity is O(1)

class Solution {
    func lengthOfLastWord(_ s: String) -> Int {
        guard let word = s.split(separator: " ").last else { return 0 }
        return word.count
    }
}

3rd Method

// Time Complexity : O(n) where n is the size of the string s and space complexity is O(1)

class Solution {
    func lengthOfLastWord(_ s: String) -> Int {
        var count = 0
        for char in s.reversed() {
            if char == " " && count > 0 {
                break
            } else if char != " " {
                count += 1
            }
        }
        return count
    }
}

59. Spiral Matrix II in c++

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(1)

class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> matrix(n, vector<int>(n)); // vector to store the result
        int top = 0, bottom = n-1, left = 0, right = n-1; // variables to store the top, bottom, left and right
        int count = 1; // variable to store the count
        while(top <= bottom && left <= right){ // while top is less than or equal to bottom and left is less than or equal to right
            for(int i=left; i<=right; i++){ // loop for i
                matrix[top][i] = count++; // update the matrix
            }
            top++; // increment the top
            for(int i=top; i<=bottom; i++){ // loop for i
                matrix[i][right] = count++; // update the matrix
            }
            right--; // decrement the right
            for(int i=right; i>=left; i--){ // loop for i
                matrix[bottom][i] = count++; // update the matrix
            }
            bottom--; // decrement the bottom
            for(int i=bottom; i>=top; i--){ // loop for i
                matrix[i][left] = count++; // update the matrix
            }
            left++; // increment the left
        }
        return matrix; // return the matrix
    }
};

59. Spiral Matrix II in java

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(1)

class Solution {
    public int[][] generateMatrix(int n) {
        int[][] matrix = new int[n][n]; // vector to store the result
        int top = 0, bottom = n-1, left = 0, right = n-1; // variables to store the top, bottom, left and right
        int count = 1; // variable to store the count
        while(top <= bottom && left <= right){ // while top is less than or equal to bottom and left is less than or equal to right
            for(int i=left; i<=right; i++){ // loop for i
                matrix[top][i] = count++; // update the matrix
            }
            top++; // increment the top
            for(int i=top; i<=bottom; i++){ // loop for i
                matrix[i][right] = count++; // update the matrix
            }
            right--; // decrement the right
            for(int i=right; i>=left; i--){ // loop for i
                matrix[bottom][i] = count++; // update the matrix
            }
            bottom--; // decrement the bottom
            for(int i=bottom; i>=top; i--){ // loop for i
                matrix[i][left] = count++; // update the matrix
            }
            left++; // increment the left
        }
        return matrix; // return the matrix
    }
}

59. Spiral Matrix II in python

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(1)

class Solution(object):
    def generateMatrix(self, n):
         """
         :type n: int
         :rtype: List[List[int]]
         """ 
        // matrix = [[0 for i in range(n)] for j in range(n)]  # vector to store the result
        top = 0  # variables to store the top
        bottom = n-1  # variables to store the bottom
        left = 0  # variables to store the left
        right = n-1  # variables to store the right
        count = 1  # variable to store the count
        while top <= bottom and left <= right:  # while top is less than or equal to bottom and left is less than or equal to right
            for i in range(left, right+1):  # loop for i
                matrix[top][i] = count  # update the matrix
                count += 1  # increment the count
            top += 1  # increment the top
            for i in range(top, bottom+1):  # loop for i
                matrix[i][right] = count  # update the matrix
                count += 1  # increment the count
            right -= 1  # decrement the right
            for i in range(right, left-1, -1):  # loop for i
                matrix[bottom][i] = count  # update the matrix
                count += 1  # increment the count
            bottom -= 1  # decrement the bottom
            for i in range(bottom, top-1, -1):  # loop for i
                matrix[i][left] = count  # update the matrix
                count += 1  # increment the count
            left += 1  # increment the left
        return matrix  # return the matrix

59. Spiral Matrix II in python3

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(1)

class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:  // add the missing colon after int
       // matrix = [[0 for i in range(n)] for j in range(n)]  # vector to store the result
        top = 0  # variables to store the top
        bottom = n-1  # variables to store the bottom
        left = 0  # variables to store the left
        right = n-1  # variables to store the right
        count = 1  # variable to store the count
        while top <= bottom and left <= right:  # while top is less than or equal to bottom and left is less than or equal to right
            for i in range(left, right+1):  # loop for i
                matrix[top][i] = count  # update the matrix
                count += 1  # increment the count
            top += 1  # increment the top
            for i in range(top, bottom+1):  # loop for i
                matrix[i][right] = count  # update the matrix
                count += 1  # increment the count
            right -= 1  # decrement the right
            for i in range(right, left-1, -1):  # loop for i
                matrix[bottom][i] = count  # update the matrix
                count += 1  # increment the count
            bottom -= 1  # decrement the bottom
            for i in range(bottom, top-1, -1):  # loop for i
                matrix[i][left] = count  # update the matrix
                count += 1  # increment the count
            left += 1  # increment the left
        return matrix  # return the matrix

59. Spiral Matrix II in c

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(1)

int** generateMatrix(int n, int* returnSize, int** returnColumnSizes){
    int** matrix = (int**)malloc(sizeof(int*)*n);  // vector to store the result
    for(int i=0; i<n; i++){  // loop for i
        matrix[i] = (int*)malloc(sizeof(int)*n);  // vector to store the result
    }
    int top = 0, bottom = n-1, left = 0, right = n-1;  // variables to store the top, bottom, left and right
    int count = 1;  // variable to store the count
    while(top <= bottom && left <= right){  // while top is less than or equal to bottom and left is less than or equal to right
        for(int i=left; i<=right; i++){  // loop for i
            matrix[top][i] = count++;  // update the matrix
        }
        top++;  // increment the top
        for(int i=top; i<=bottom; i++){  // loop for i
            matrix[i][right] = count++;  // update the matrix
        }
        right--;  // decrement the right
        for(int i=right; i>=left; i--){  // loop for i
            matrix[bottom][i] = count++;  // update the matrix
        }
        bottom--;  // decrement the bottom
        for(int i=bottom; i>=top; i--){  // loop for i
            matrix[i][left] = count++;  // update the matrix
        }f
        left++;  // increment the left
    }
    *returnSize = n;  // update the returnSize
    *returnColumnSizes = (int*)malloc(sizeof(int)*n);  // vector to store the result
    for(int i=0; i<n; i++){  // loop for i
        (*returnColumnSizes)[i] = n;  // update the returnColumnSizes
    }
    return matrix;  // return the matrix
}

59. Spiral Matrix II in c#

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(1)

public class Solution {
    public int[][] GenerateMatrix(int n) {
        int[][] matrix = new int[n][];  // vector to store the result
        for(int i=0; i<n; i++){  // loop for i
            matrix[i] = new int[n];  // vector to store the result
        }
        int top = 0, bottom = n-1, left = 0, right = n-1;  // variables to store the top, bottom, left and right
        int count = 1;  // variable to store the count
        while(top <= bottom && left <= right){  // while top is less than or equal to bottom and left is less than or equal to right
            for(int i=left; i<=right; i++){  // loop for i
                matrix[top][i] = count++;  // update the matrix
            }
            top++;  // increment the top
            for(int i=top; i<=bottom; i++){  // loop for i
                matrix[i][right] = count++;  // update the matrix
            }
            right--;  // decrement the right
            for(int i=right; i>=left; i--){  // loop for i
                matrix[bottom][i] = count++;  // update the matrix
            }
            bottom--;  // decrement the bottom
            for(int i=bottom; i>=top; i--){  // loop for i
                matrix[i][left] = count++;  // update the matrix
            }
            left++;  // increment the left
        }
        return matrix;  // return the matrix
    }
}

59. Spiral Matrix II in javascript

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(1)

var generateMatrix = function(n) {
    let matrix = new Array(n);  // vector to store the result
    for(let i=0; i<n; i++){  // loop for i
        matrix[i] = new Array(n);  // vector to store the result
    }
    let top = 0, bottom = n-1, left = 0, right = n-1;  // variables to store the top, bottom, left and right
    let count = 1;  // variable to store the count
    while(top <= bottom && left <= right){  // while top is less than or equal to bottom and left is less than or equal to right
        for(let i=left; i<=right; i++){  // loop for i
            matrix[top][i] = count++;  // update the matrix
        }
        top++;  // increment the top
        for(let i=top; i<=bottom; i++){  // loop for i
            matrix[i][right] = count++;  // update the matrix
        }
        right--;  // decrement the right
        for(let i=right; i>=left; i--){  // loop for i
            matrix[bottom][i] = count++;  // update the matrix
        }
        bottom--;  // decrement the bottom
        for(let i=bottom; i>=top; i--){  // loop for i
            matrix[i][left] = count++;  // update the matrix
        }
        left++;  // increment the left
    }
    return matrix;  // return the matrix
};

59. Spiral Matrix II in Swift

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(1)

class Solution {
    func generateMatrix(_ n: Int) -> [[Int]] {
        var matrix = [[Int]](repeating: [Int](repeating: 0, count: n), count: n)  // vector to store the result
        var top = 0, bottom = n-1, left = 0, right = n-1  // variables to store the top, bottom, left and right
        var count = 1  // variable to store the count
        while top <= bottom && left <= right {  // while top is less than or equal to bottom and left is less than or equal to right
            for i in stride(from: left, through: right, by: 1) {  // loop for i
                matrix[top][i] = count  // update the matrix
                count += 1  // increment the count
            }
            top += 1  // increment the top
            for i in stride(from: top, through: bottom, by: 1) {  // loop for i
                matrix[i][right] = count  // update the matrix
                count += 1  // increment the count
            }
            right -= 1  // decrement the right
            for i in stride(from: right, through: left, by: -1) {  // loop for i
                matrix[bottom][i] = count  // update the matrix
                count += 1  // increment the count
            }
            bottom -= 1  // decrement the bottom
            for i in stride(from: bottom, through: top, by: -1) {  // loop for i
                matrix[i][left] = count  // update the matrix
                count += 1  // increment the count
            }
            left += 1  // increment the left
        }
        return matrix  // return the matrix
    }
}

60. Permutation Sequence in c++

// Time Complexity : O(n) where n is the size of the string s and space complexity is O(1)

class Solution {
public:
    string getPermutation(int n, int k) {
        string s = ""; // string to store the result
        vector<int> nums; // vector to store the numbers
        int fact = 1; // variable to store the factorial
        for(int i=1; i<=n; i++){ // loop for i
            fact *= i; // update the factorial
            nums.push_back(i); // push the number in the vector nums
        }
        for(int i=0, l=k-1; i<n; i++){ // loop for i
            fact /= n-i; // update the factorial
            int index = (l/fact); // variable to store the index
            s += to_string(nums[index]); // update the string
            nums.erase(nums.begin()+index); // erase the number from the vector nums
            l -= index*fact; // update the l
        }
        return s; // return the string
        
    }
};

2nd Method

// Time Complexity : O(n) where n is the size of the string s and space complexity is O(1)

#include <algorithm>
#include <string>

class Solution {
public:
    string getPermutation(int n, int k) {
        string s = "";
        for (int i = 1; i <= n; i++) {
            s += to_string(i);
        }
        while (--k) {
            std::next_permutation(s.begin(), s.end());
        }
        return s;
    }
};


3rd Method 

// Time Complexity : O(n) where n is the size of the string s and space complexity is O(1)

class Solution {
public:
    string getPermutation(int n, int k) {
        string s = ""; // string to store the result
        vector<int> fact(n); // vector to store the factorial
        vector<int> nums(n); // vector to store the numbers
        fact[0] = 1; // initialize the factorial
        for(int i=1; i<n; i++){ // loop for i
            fact[i] = fact[i-1]*i; // update the factorial
        }
        for(int i=1; i<=n; i++){ // loop for i
            nums[i-1] = i; // update the numbers
        }
        k--; // decrement the k
        for(int i=1; i<=n; i++){ // loop for i
            int index = k/fact[n-i]; // index is the index of the number
            s += to_string(nums[index]); // update the string
            nums.erase(nums.begin()+index); // erase the number
            k -= index*fact[n-i]; // update the k
        }
        return s; // return the string
    }
};

60. Permutation Sequence in java

// Time Complexity : O(n) where n is the size of the string s and space complexity is O(1)

class Solution {
    public String getPermutation(int n, int k) {
        String s = ""; // string to store the result
        List<Integer> nums = new ArrayList<>(); // vector to store the numbers
        int fact = 1; // variable to store the factorial
        for(int i=1; i<=n; i++){ // loop for i
            fact *= i; // update the factorial
            nums.add(i); // push the number in the vector nums
        }
        for(int i=0, l=k-1; i<n; i++){ // loop for i
            fact /= n-i; // update the factorial
            int index = (l/fact); // variable to store the index
            s += nums.get(index); // update the string
            nums.remove(index); // erase the number from the vector nums
            l -= index*fact; // update the l
        }
        return s; // return the string
    }
}

60. Permutation Sequence in python

// Time Complexity : O(n) where n is the size of the string s and space complexity is O(1)

class Solution(object):
    def getPermutation(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: str
        """ 
        s = ""  # string to store the result
        nums = [i for i in range(1, n+1)]  # vector to store the numbers
        fact = 1  # variable to store the factorial
        for i in range(1, n+1):  # loop for i
            fact *= i  # update the factorial
        k-=1  # decrement the k
        for i in range(n):  # loop for i
            fact /= n-i  # update the factorial
            index = (k/fact)  # variable to store the index
            s += str(nums[index])  # update the string
            nums.remove(nums[index])  # erase the number from the vector nums
            k -= index*fact  # update the k
        return s  # return the string

60. Permutation Sequence in python3

// Time Complexity : O(n) where n is the size of the string s and space complexity is O(1)

class Solution:
    def getPermutation(self, n: int, k: int -> str:  // add the missing bracket after int
        s = ""  # string to store the result
        nums = [i for i in range(1, n+1)]  # vector to store the numbers
        fact = 1  # variable to store the factorial
        for i in range(1, n+1):  # loop for i
            fact *= i  # update the factorial
        k-=1 # decrement the k
        for i in range(n):  # loop for i
            fact /= n-i  # update the factorial
            index = int(k/fact)  # variable to store the index
            s += str(nums[index])  # update the string
            nums.remove(nums[index])  # erase the number from the vector nums
            k -= index*fact  # update the k
        return s  # return the string

60. Permutation Sequence in c

// Time Complexity : O(n) where n is the size of the string s and space complexity is O(1)

char * getPermutation(int n, int k){
    char *s = (char*)malloc(sizeof(char)*n);  // string to store the result
    int *nums = (int*)malloc(sizeof(int)*n);  // vector to store the numbers
    int fact = 1;  // variable to store the factorial
    for(int i=1; i<=n; i++){  // loop for i
        fact *= i;  // update the factorial
        nums[i-1] = i;  // update the numbers
    }
    for(int i=0, l=k-1; i<n; i++){  // loop for i
        fact /= n-i;  // update the factorial
        int index = (l/fact);  // variable to store the index
        s[i] = nums[index]+'0';  // update the string
        for(int j=index; j<n-i-1; j++){  // loop for j
            nums[j] = nums[j+1];  // update the numbers
        }
        l -= index*fact;  // update the l
    }
    return s;  // return the string
}

60. Permutation Sequence in c#

// Time Complexity : O(n) where n is the size of the string s and space complexity is O(1)

public class Solution {
    public string GetPermutation(int n, int k) {
        string s = "";  // string to store the result
        List<int> nums = new List<int>();  // vector to store the numbers
        int fact = 1;  // variable to store the factorial
        for(int i=1; i<=n; i++){  // loop for i
            fact *= i;  // update the factorial
            nums.Add(i);  // push the number in the vector nums
        }
        for(int i=0, l=k-1; i<n; i++){  // loop for i
            fact /= n-i;  // update the factorial
            int index = (l/fact);  // variable to store the index
            s += nums[index];  // update the string
            nums.RemoveAt(index);  // erase the number from the vector nums
            l -= index*fact;  // update the l
        }
        return s;  // return the string
    }
}

60. Permutation Sequence in javascript

// Time Complexity : O(n) where n is the size of the string s and space complexity is O(1)

var getPermutation = function(n, k) {
    let s = "";  // string to store the result
    let nums = [];  // vector to store the numbers
    let fact = 1;  // variable to store the factorial
    for(let i=1; i<=n; i++){  // loop for i
        fact *= i;  // update the factorial
        nums.push(i);  // push the number in the vector nums
    }
    for(let i=0, l=k-1; i<n; i++){  // loop for i
        fact /= n-i;  // update the factorial
        let index = Math.floor(l/fact);  // variable to store the index
        s += nums[index];  // update the string
        nums.splice(index, 1);  // erase the number from the vector nums
        l -= index*fact;  // update the l
    }
    return s;  // return the string
};

60. Permutation Sequence in Swift

// Time Complexity : O(n) where n is the size of the string s and space complexity is O(1)

class Solution {
    func getPermutation(_ n: Int, _ k: Int) -> String {
        var s = ""  // string to store the result
        var nums = [Int]()  // vector to store the numbers
        var fact = 1  // variable to store the factorial
        var k = k  // variable to store the k
        for i in 1...n {  // loop for i
            fact *= i  // update the factorial
            nums.append(i)  // push the number in the vector nums
        }
        k -=1 // decrement the k
        for i in 0..<n {  // loop for i
            fact /= n-i  // update the factorial
            let index = (k/fact)  // variable to store the index
            s += String(nums[index])  // update the string
            nums.remove(at: index)  // erase the number from the vector nums
            k -= index*fact  // update the k
        }
        return s  // return the string
    }
}









77. Combinations

// Time Complexity : O(n^k) where n is the number of elements and k is the size of the vector nums and space complexity is O(n^k)

class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
         vector<vector<int>> combs; // vector to store the result
            vector<int> comb; // vector to store the combination
            combine(combs, comb, 1, n, k); // call the combine function
            return combs; // return the vector combs
    }
    void combine(vector<vector<int>>& combs, vector<int>& comb, int start, int n, int k) {
        if(k==0){ // if k is equal to 0
            combs.push_back(comb); // push the vector comb to the vector combs
            return; // return
        }
        for(int i=start; i<=n; i++){ // loop for i
            comb.push_back(i); // push the element to the vector comb
            combine(combs, comb, i+1, n, k-1); // call the combine function
            comb.pop_back(); // pop the element from the vector comb
        }
    }
};

77. Combinations in java

// Time Complexity : O(n^k) where n is the number of elements and k is the size of the vector nums and space complexity is O(n^k)

class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> combs = new ArrayList<>(); // vector to store the result
        List<Integer> comb = new ArrayList<>(); // vector to store the combination
        combine(combs, comb, 1, n, k); // call the combine function
        return combs; // return the vector combs
    }
    public void combine(List<List<Integer>> combs, List<Integer> comb, int start, int n, int k) {
        if(k==0){ // if k is equal to 0
            combs.add(new ArrayList<Integer>(comb)); // push the vector comb to the vector combs
            return; // return
        }
        for(int i=start; i<=n; i++){ // loop for i
            comb.add(i); // push the element to the vector comb
            combine(combs, comb, i+1, n, k-1); // call the combine function
            comb.remove(comb.size()-1); // pop the element from the vector comb
        }
    }
}

77. Combinations in python

// Time Complexity : O(n^k) where n is the number of elements and k is the size of the vector nums and space complexity is O(n^k)

class Solution(object):
    def combine(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: List[List[int]]
        """ 
        combs = []  # vector to store the result
        comb = []  # vector to store the combination
        self.combineHelper(combs, comb, 1, n, k)  # call the combine function
        return combs  # return the vector combs
    def combineHelper(self, combs, comb, start, n, k):
        if k == 0:  # if k is equal to 0
            combs.append(comb[:])  # push the vector comb to the vector combs
            return  # return
        for i in range(start, n + 1):  # loop for i
            comb.append(i)  # push the element to the vector comb
            self.combineHelper(combs, comb, i + 1, n, k - 1)  # call the combine function
            comb.pop()  # pop the element from the vector comb

77. Combinations in python3

// Time Complexity : O(n^k) where n is the number of elements and k is the size of the vector nums and space complexity is O(n^k)

class Solution:
    def combine(self, n: int, k: int -> List[List[int]]:  // add the missing colon after List[int]
        combs = []  # vector to store the result
        comb = []  # vector to store the combination
        self.combineHelper(combs, comb, 1, n, k)  # call the combine function
        return combs  # return the vector combs
    def combineHelper(self, combs, comb, start, n, k):
        if k == 0:  # if k is equal to 0
            combs.append(comb[:])  # push the vector comb to the vector combs
            return  # return
        for i in range(start, n + 1):  # loop for i
            comb.append(i)  # push the element to the vector comb
            self.combineHelper(combs, comb, i + 1, n, k - 1)  # call the combine function
            comb.pop()  # pop the element from the vector comb

77. Combinations in c

// Time Complexity : O(n^k) where n is the number of elements and k is the size of the vector nums and space complexity is O(n^k)

void combineHelper(int** combs, int* comb, int start, int n, int k, int* returnSize, int** returnColumnSizes){
    if(k == 0){  // if k is equal to 0
        combs[*returnSize] = (int*)malloc(sizeof(int) * n);  // push the vector comb to the vector combs
        memcpy(combs[*returnSize], comb, sizeof(int) * n);  // push the vector comb to the vector combs
        (*returnColumnSizes)[*returnSize] = n;  // push the vector comb to the vector combs
        (*returnSize)++;  // push the vector comb to the vector combs
        return;  // return
    }
    for(int i = start; i <= n; i++){  // loop for i
        comb[n - k] = i;  // push the element to the vector comb
        combineHelper(combs, comb, i + 1, n, k - 1, returnSize, returnColumnSizes);  // call the combine function
    }
}

int** combine(int n, int k, int* returnSize, int** returnColumnSizes){
    int** combs = (int**)malloc(sizeof(int*) * 10000);  // vector to store the result
    int* comb = (int*)malloc(sizeof(int) * k);  // vector to store the combination
    *returnSize = 0;  // variable to store the size of the result
    *returnColumnSizes = (int*)malloc(sizeof(int) * 10000);  // variable to store the size of the result
    combineHelper(combs, comb, 1, n, k, returnSize, returnColumnSizes);  // call the combine function
    return combs;  // return the vector combs
}

77. Combinations in c#

// Time Complexity : O(n^k) where n is the number of elements and k is the size of the vector nums and space complexity is O(n^k)

public class Solution {
    public IList<IList<int>> Combine(int n, int k) {
        IList<IList<int>> combs = new List<IList<int>>();  // vector to store the result
        IList<int> comb = new List<int>();  // vector to store the combination
        CombineHelper(combs, comb, 1, n, k);  // call the combine function
        return combs;  // return the vector combs
    }
    public void CombineHelper(IList<IList<int>> combs, IList<int> comb, int start, int n, int k){
        if(k == 0){  // if k is equal to 0
            combs.Add(new List<int>(comb));  // push the vector comb to the vector combs
            return;  // return
        }
        for(int i = start; i <= n; i++){  // loop for i
            comb.Add(i);  // push the element to the vector comb
            CombineHelper(combs, comb, i + 1, n, k - 1);  // call the combine function
            comb.RemoveAt(comb.Count - 1);  // pop the element from the vector comb
        }
    }
}

77. Combinations in javascript

// Time Complexity : O(n^k) where n is the number of elements and k is the size of the vector nums and space complexity is O(n^k)

var combine = function(n, k) {
    let combs = [];  // vector to store the result
    let comb = [];  // vector to store the combination
    combineHelper(combs, comb, 1, n, k);  // call the combine function
    return combs;  // return the vector combs
};

var combineHelper = function(combs, comb, start, n, k){
    if(k == 0){  // if k is equal to 0
        combs.push(comb.slice());  // push the vector comb to the vector combs
        return;  // return
    }
    for(let i = start; i <= n; i++){  // loop for i
        comb.push(i);  // push the element to the vector comb
        combineHelper(combs, comb, i + 1, n, k - 1);  // call the combine function
        comb.pop();  // pop the element from the vector comb
    }
};

77. Combinations in Swift

// Time Complexity : O(n^k) where n is the number of elements and k is the size of the vector nums and space complexity is O(n^k)

class Solution {
    func combine(_ n: Int, _ k: Int) -> [[Int]] {
        var combs = [[Int]]()  // vector to store the result
        var comb = [Int]()  // vector to store the combination
        func combineHelper(start: Int, comb: inout[Int] , k: Int){ // call the combine function
            if k == 0{  // if k is equal to 0
            combs.append(comb)  // push the vector comb to the vector combs
            return  // return
        }
        if start > n{ return } // if start is greater than n then return 
        for i in start...n{  // loop for i
            comb.append(i)  // push the element to the vector comb
            combineHelper(start: i + 1, comb: &comb, k: k - 1)  // call the combine function
            comb.removeLast()  // pop the element from the vector comb
        }
        }
        combineHelper(start: 1, comb: &comb, k: k)  // call the combine function
        return combs  // return the vector combs
    }
}

95. Unique Binary Search Trees II in c++

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(n)

class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        if(n==0){ // if n is equal to 0
            return {}; // return empty vector
        }
        return generateTrees(1, n); // call the generateTrees function
    }
    vector<TreeNode*> generateTrees(int start, int end){
        vector<TreeNode*> trees; // vector to store the result
        if(start > end){ // if start is greater than end
            trees.push_back(NULL); // push the null in the vector trees
            return trees; // return the vector trees
        }
        for(int i=start; i<=end; i++){ // loop for i
            vector<TreeNode*> leftTrees = generateTrees(start, i-1); // vector to store the leftTrees
            vector<TreeNode*> rightTrees = generateTrees(i+1, end); // vector to store the rightTrees
            for(auto leftTree: leftTrees){ // loop for leftTreeT
                for(auto rightTree: rightTrees){ // loop for rightTree
                    TreeNode* root = new TreeNode(i); // create the root
                    root->left = leftTree; // update the left
                    root->right = rightTree; // update the right
                    trees.push_back(root); // push the root in the vector trees
                }
            }
        }
        return trees; // return the vector trees
    }
};

95. Unique Binary Search Trees II in java

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(n)

class Solution {
    public List<TreeNode> generateTrees(int n) {
        if(n==0){ // if n is equal to 0
            return new ArrayList<TreeNode>(); // return empty vector
        }
        return generateTrees(1, n); // call the generateTrees function
    }
    public List<TreeNode> generateTrees(int start, int end){
        List<TreeNode> trees = new ArrayList<>(); // vector to store the result
        if(start > end){ // if start is greater than end
            trees.add(null); // push the null in the vector trees
            return trees; // return the vector trees
        }
        for(int i=start; i<=end; i++){ // loop for i
            List<TreeNode> leftTrees = generateTrees(start, i-1); // vector to store the leftTrees
            List<TreeNode> rightTrees = generateTrees(i+1, end); // vector to store the rightTrees
            for(TreeNode leftTree: leftTrees){ // loop for leftTreeT
                for(TreeNode rightTree: rightTrees){ // loop for rightTree
                    TreeNode root = new TreeNode(i); // create the root
                    root.left = leftTree; // update the left
                    root.right = rightTree; // update the right
                    trees.add(root); // push the root in the vector trees
                }
            }
        }
        return trees; // return the vector trees
    }
}

95. Unique Binary Search Trees II in python

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(n)

class Solution(object):
    def generateTrees(self, n):
        """
        :type n: int
        :rtype: List[TreeNode]
        """ 
        if n == 0:  # if n is equal to 0
            return []  # return empty vector
        return self.generateTreesHelper(1, n)  # call the generateTrees function
    def generateTreesHelper(self, start, end):
        trees = []  # vector to store the result
        if start > end:  # if start is greater than end
            trees.append(None)  # push the null in the vector trees
            return trees  # return the vector trees
        for i in range(start, end + 1):  # loop for i
            leftTrees = self.generateTreesHelper(start, i - 1)  # vector to store the leftTrees
            rightTrees = self.generateTreesHelper(i + 1, end)  # vector to store the rightTrees
            for leftTree in leftTrees:  # loop for leftTreeT
                for rightTree in rightTrees:  # loop for rightTree
                    root = TreeNode(i)  # create the root
                    root.left = leftTree  # update the left
                    root.right = rightTree  # update the right
                    trees.append(root)  # push the root in the vector trees
        return trees  # return the vector trees


95. Unique Binary Search Trees II in python3

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(n)

class Solution:
    def generateTrees(self, n: int -> List[TreeNode]:  // add the missing bracket after int
        if n == 0:  # if n is equal to 0
            return []  # return empty vector
        return self.generateTreesHelper(1, n)  # call the generateTrees function
    def generateTreesHelper(self, start, end):
        trees = []  # vector to store the result
        if start > end:  # if start is greater than end
            trees.append(None)  # push the null in the vector trees
            return trees  # return the vector trees
        for i in range(start, end + 1):  # loop for i
            leftTrees = self.generateTreesHelper(start, i - 1)  # vector to store the leftTrees
            rightTrees = self.generateTreesHelper(i + 1, end)  # vector to store the rightTrees
            for leftTree in leftTrees:  # loop for leftTreeT
                for rightTree in rightTrees:  # loop for rightTree
                    root = TreeNode(i)  # create the root
                    root.left = leftTree  # update the left
                    root.right = rightTree  # update the right
                    trees.append(root)  # push the root in the vector trees
        return trees  # return the vector trees

95. Unique Binary Search Trees II in c

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(n)

struct TreeNode** generateTrees(int n, int* returnSize){
    if(n==0){  // if n is equal to 0
        *returnSize = 0;  // return empty vector
        return NULL;  // return empty vector
    }
    return generateTreesHelper(1, n, returnSize);  // call the generateTrees function
}

struct TreeNode** generateTreesHelper(int start, int end, int* returnSize){
    struct TreeNode** trees = (struct TreeNode**)malloc(sizeof(struct TreeNode*)*10000);  // vector to store the result
    if(start > end){  // if start is greater than end
        trees[0] = NULL;  // push the null in the vector trees
        *returnSize = 1;  // return the vector trees
        return trees;  // return the vector t
    }
    int index = 0;  // variable to store the index
    for(int i=start; i<=end; i++){  // loop for i
        int leftSize = 0;  // variable to store the size of the leftTrees
        struct TreeNode** leftTrees = generateTreesHelper(start, i-1, &leftSize);  // vector to store the leftTrees
        int rightSize = 0;  // variable to store the size of the rightTrees
        struct TreeNode** rightTrees = generateTreesHelper(i+1, end, &rightSize);  // vector to store the rightTrees
        for(int j=0; j<leftSize; j++){  // loop for leftTreeT
            for(int k=0; k<rightSize; k++){  // loop for rightTree
                struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));  // create the root
                root->val = i;  // update the root
                root->left = leftTrees[j];  // update the left
                root->right = rightTrees[k];  // update the right
                trees[index++] = root;  // push the root in the vector trees
            }
        }
    }
    *returnSize = index;  // return the vector trees
    return trees;  // return the vector trees
}

95. Unique Binary Search Trees II in c#

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(n)

public class Solution {
    public IList<TreeNode> GenerateTrees(int n) {
        if(n==0){  // if n is equal to 0
            return new List<TreeNode>();  // return empty vector
        }
        return GenerateTreesHelper(1, n);  // call the generateTrees function
    }
    public IList<TreeNode> GenerateTreesHelper(int start, int end){
        IList<TreeNode> trees = new List<TreeNode>();  // vector to store the result
        if(start > end){  // if start is greater than end
            trees.Add(null);  // push the null in the vector trees
            return trees;  // return the vector trees
        }
        for(int i=start; i<=end; i++){  // loop for i
            IList<TreeNode> leftTrees = GenerateTreesHelper(start, i-1);  // vector to store the leftTrees
            IList<TreeNode> rightTrees = GenerateTreesHelper(i+1, end);  // vector to store the rightTrees
            foreach(TreeNode leftTree in leftTrees){  // loop for leftTreeT
                foreach(TreeNode rightTree in rightTrees){  // loop for rightTree
                    TreeNode root = new TreeNode(i);  // create the root
                    root.left = leftTree;  // update the left
                    root.right = rightTree;  // update the right
                    trees.Add(root);  // push the root in the vector trees
                }
            }
        }
        return trees;  // return the vector trees
    }
}

95. Unique Binary Search Trees II in javascript

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(n)

var generateTrees = function(n) {
    if(n==0){  // if n is equal to 0
        return [];  // return empty vector
    }
    return generateTreesHelper(1, n);  // call the generateTrees function
};

var generateTreesHelper = function(start, end){
    let trees = [];  // vector to store the result
    if(start > end){  // if start is greater than end
        trees.push(null);  // push the null in the vector tree
        return trees;  // return the vector trees
    }
    for(let i=start; i<=end; i++){  // loop for i
        let leftTrees = generateTreesHelper(start, i-1);  // vector to store the leftTrees
        let rightTrees = generateTreesHelper(i+1, end);  // vector to store the rightTrees
        for(let leftTree of leftTrees){  // loop for leftTreeT
            for(let rightTree of rightTrees){  // loop for rightTree
                let root = new TreeNode(i);  // create the root
                root.left = leftTree;  // update the left
                root.right = rightTree;  // update the right
                trees.push(root);  // push the root in the vector trees
            }
        }
    }
    return trees;  // return the vector trees
};

95. Unique Binary Search Trees II in Swift

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(n)

class Solution {
    func generateTrees(_ n: Int) -> [TreeNode?] {
        if n==0{  // if n is equal to 0
            return [];  // return empty vector
        }
        return generateTreesHelper(1, n);  // call the generateTrees function
    }
    func generateTreesHelper(_ start: Int, _ end: Int) -> [TreeNode?]{
        var trees = [TreeNode?]();  // vector to store the result
        if start > end{  // if start is greater than end
            trees.append(nil);  // push the null in the vector trees
            return trees;  // return the vector trees
        }
        for i in start...end{  // loop for i
            let leftTrees = generateTreesHelper(start, i-1);  // vector to store the leftTrees
            let rightTrees = generateTreesHelper(i+1, end);  // vector to store theightTrees
            for leftTree in leftTrees{  // loop for leftTreeT
                for rightTree in rightTrees{  // loop for rightTree
                    let root = TreeNode(i);  // create the root
                    root.left = leftTree;  // update the left
                    root.right = rightTree;  // update the right
                    trees.append(root);  // push the root in the vector trees
                }
            }
        }
        return trees;  // return the vector trees
    }
}

95. Unique Binary Search Trees II in dart

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(n)

class Solution {
  List<TreeNode?> generateTrees(int n) {
    if (n == 0) {
      // if n is equal to 0
      return []; // return empty vector
    }
    return generateTreesHelper(1, n); // call the generateTrees function

  }

    List<TreeNode?> generateTreesHelper(int start, int end) {
        List<TreeNode?> trees = []; // vector to store the result
        if (start > end) {
        // if start is greater than end
        trees.add(null); // push the null in the vector trees
        return trees; // return the vector trees
        }
        for (int i = start; i <= end; i++) {
        // loop for i
        List<TreeNode?> leftTrees = generateTreesHelper(start, i - 1); // vector to store the leftTrees
        List<TreeNode?> rightTrees = generateTreesHelper(i + 1, end); // vector to store the rightTrees
        for (TreeNode? leftTree in leftTrees) {
            // loop for leftTreeT
            for (TreeNode? rightTree in rightTrees) {
            // loop for rightTree
            TreeNode root = TreeNode(i); // create the root
            root.left = leftTree; // update the left
            root.right = rightTree; // update the right
            trees.add(root); // push the root in the vector trees
            }
        }
        }
        return trees; // return the vector trees
    }
}

96. Unique Binary Search Trees in c++

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(n)

class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1, 0); // vector to store the result
        dp[0] = 1; // initialize the dp[0] to 1
        dp[1] = 1; // initialize the dp[1] to 1
        for(int i=2; i<=n; i++){ // loop for i
            for(int j=1; j<=i; j++){ // loop for j 
                dp[i] += dp[j-1] * dp[i-j]; // update the dp[i] ,  dp[j-1] used for left subtree and dp[i-j] used for right subtree 
            }
        }
        return dp[n]; // return the dp[n]
    }
};

96. Unique Binary Search Trees in java

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(n)

class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n+1]; // vector to store the result
        dp[0] = 1; // initialize the dp[0] to 1
        dp[1] = 1; // initialize the dp[1] to 1
        for(int i=2; i<=n; i++){ // loop for i
            for(int j=1; j<=i; j++){ // loop for j 
                dp[i] += dp[j-1] * dp[i-j]; // update the dp[i] ,  dp[j-1] used for left subtree and dp[i-j] used for right subtree 
            }
        }
        return dp[n]; // return the dp[n]
    }
}

96. Unique Binary Search Trees in python

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(n)

class Solution(object):
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """ 
        dp = [0] * (n+1)  # vector to store the result
        dp[0] = 1  # initialize the dp[0] to 1
        dp[1] = 1  # initialize the dp[1] to 1
        for i in range(2, n+1):  # loop for i
            for j in range(1, i+1):  # loop for j 
                dp[i] += dp[j-1] * dp[i-j]  # update the dp[i] ,  dp[j-1] used for left subtree and dp[i-j] used for right subtree 
        return dp[n]  # return the dp[n]

96. Unique Binary Search Trees in python3

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(n)

class Solution:
    def numTrees(self, n: int) -> int:  // add the missing colon after int
        dp = [0] * (n+1)  # vector to store the result
        dp[0] = 1  # initialize the dp[0] to 1
        dp[1] = 1  # initialize the dp[1] to 1
        for i in range(2, n+1):  # loop for i
            for j in range(1, i+1):  # loop for j 
                dp[i] += dp[j-1] * dp[i-j]  # update the dp[i] ,  dp[j-1] used for left subtree and dp[i-j] used for right subtree 
        return dp[n]  # return the dp[n]

96. Unique Binary Search Trees in c

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(n)

int numTrees(int n){
    int dp[n+1];  // vector to store the result
    memset(dp, 0, sizeof(dp));  // initialize the dp[0] to 1
    dp[0] = 1;  // initialize the dp[1] to 1
    dp[1] = 1;  // initialize the dp[1] to 1
    for(int i=2; i<=n; i++){  // loop for i
        for(int j=1; j<=i; j++){  // loop for j 
            dp[i] += dp[j-1] * dp[i-j];  // update the dp[i] ,  dp[j-1] used for left subtree and dp[i-j] used for right subtree 
        }
    }
    return dp[n];  // return the dp[n]
}

96. Unique Binary Search Trees in c#

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(n)

public class Solution {
    public int NumTrees(int n) {
        int[] dp = new int[n+1];  // vector to store the result
        Array.Fill(dp, 0);  // initialize the dp[0] to 1
        dp[0] = 1;  // initialize the dp[1] to 1
        dp[1] = 1;  // initialize the dp[1] to 1
        for(int i=2; i<=n; i++){  // loop for i
            for(int j=1; j<=i; j++){  // loop for j 
                dp[i] += dp[j-1] * dp[i-j];  // update the dp[i] ,  dp[j-1] used for left subtree and dp[i-j] used for right subtree 
            }
        }
        return dp[n];  // return the dp[n]
    }
}

96. Unique Binary Search Trees in javascript

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(n)

var numTrees = function(n) {
    let dp = new Array(n+1).fill(0);  // vector to store the resuk
    dp[0] = 1;  // initialize the dp[0] to 1
    dp[1] = 1;  // initialize the dp[1] to 1
    for(let i=2; i<=n; i++){  // loop for i
        for(let j=1; j<=i; j++){  // loop for j 
            dp[i] += dp[j-1] * dp[i-j];  // update the dp[i] ,  dp[j-1] used for left subtree and dp[i-j] used for right subtree 
        }
    }
    return dp[n];  // return the dp[n]
};

96. Unique Binary Search Trees in Swift

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(n)

class Solution {
    func numTrees(_ n: Int) -> Int {
        if n<2{  // if n is less than 2
            return 1;  // return 1
        }
        var dp = [Int](repeating: 0, count: n+1);  // vector to store the result
        dp[0] = 1;  // initialize the dp[0] to 1
        dp[1] = 1;  // initialize the dp[1] to 1
        for i in 2...n{  // loop for i
            for j in 1...i{  // loop for j 
                dp[i] += dp[j-1] * dp[i-j];  // update the dp[i] ,  dp[j-1] used for left subtree and dp[i-j] used for right subtree 
            }
        }
        return dp[n];  // return the dp[n]
    }
}

96. Unique Binary Search Trees in dart

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(n)

int numTrees(int n) {
    List<int> dp = new List<int>.filled(n+1, 0);  // vector to store the result
    dp[0] = 1;  // initialize the dp[0] to 1
    dp[1] = 1;  // initialize the dp[1] to 1
    for(int i=2; i<=n; i++){  // loop for i
        for(int j=1; j<=i; j++){  // loop for j 
            dp[i] += dp[j-1] * dp[i-j];  // update the dp[i] ,  dp[j-1] used for left subtree and dp[i-j] used for right subtree 
        }
    }
    return dp[n];  // return the dp[n]
}



















        

139. Word Break in c++

// Time Complexity : O(n^2) where n is the size of the string s and space complexity is O(n)

class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        int n = s.size(); // variable to store the size of the string s
        vector<bool> dp(n+1, false); // vector to store the result
        dp[0] = true; // initialize the dp[0] to true
        for(int i=1; i<=n; i++){ // loop for i
            for(int j=0; j<i; j++){ // loop for j
                if(dp[j] && find(wordDict.begin(), wordDict.end(), s.substr(j, i-j)) != wordDict.end()){ // if dp[j] is true and the word is present in the dictionary
                    dp[i] = true; // update the dp[i]
                    break; // break
                }
            }
        }
        return dp[n]; // return the dp[n]
    }
};

2nd Method using BFS

// Time Complexity : O(n^2) where n is the size of the string s and space complexity is O(n)

class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> dict(wordDict.begin(), wordDict.end()); // unordered_set to store the dictionary
        queue<int> q; // queue to store the index
        vector<bool> visited(s.size(), false); // vector to store the visited
        q.push(0); // push the index 0
        while(!q.empty()){ // while queue is not empty
            int start = q.front(); // variable to store the start
            q.pop(); // pop the element from the queue
            if(!visited[start]){ // if start is not visited
                for(int end=start+1; end<=s.size(); end++){ // loop for end
                    if(dict.find(s.substr(start, end-start)) != dict.end()){ // if the word is present in the dictionary
                        q.push(end); // push the end
                        if(end == s.size()){ // if end is equal to the size of the string s
                            return true; // return true
                        }
                    }
                }
                visited[start] = true; // update the visited
            }
        }
        return false; // return false
    }
};  

139. Word Break in java

// Time Complexity : O(n^2) where n is the size of the string s and space complexity is O(n)

class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        int n = s.length(); // variable to store the size of the string s
        boolean[] dp = new boolean[n+1]; // vector to store the result
        dp[0] = true; // initialize the dp[0] to true
        for(int i=1; i<=n; i++){ // loop for i
            for(int j=0; j<i; j++){ // loop for j
                if(dp[j] && wordDict.contains(s.substring(j, i))){ // if dp[j] is true and the word is present in the dictionary
                    dp[i] = true; // update the dp[i]
                    break; // break
                }
            }
        }
        return dp[n]; // return the dp[n]
    }
}

2nd Method using BFS

// Time Complexity : O(n^2) where n is the size of the string s and space complexity is O(n)

class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> dict = new HashSet<>(wordDict); // unordered_set to store the dictionary
        Queue<Integer> q = new LinkedList<>(); // queue to store the index
        boolean[] visited = new boolean[s.length()]; // vector to store the visited
        q.add(0); // push the index 0
        while(!q.isEmpty()){ // while queue is not empty
            int start = q.poll(); // variable to store the start
            if(!visited[start]){ // if start is not visited
                for(int end=start+1; end<=s.length(); end++){ // loop for end
                    if(dict.contains(s.substring(start, end))){ // if the word is present in the dictionary
                        q.add(end); // push the end
                        if(end == s.length()){ // if end is equal to the size of the string s
                            return true; // return true
                        }
                    }
                }
                visited[start] = true; // update the visited
            }
        }
        return false; // return false
    }
}

139. Word Break in python

// Time Complexity : O(n^2) where n is the size of the string s and space complexity is O(n)

class Solution(object):
    def wordBreak(self, s, wordDict):
        """
        :type s: str
        :type wordDict: List[str]
        :rtype: bool
        """ 
        n = len(s)  # variable to store the size of the string s
        dp = [False]*(n+1)  # vector to store the result
        dp[0] = True  # initialize the dp[0] to true
        for i in range(1, n+1):  # loop for i
            for j in range(i):  # loop for j
                if dp[j] and s[j:i] in wordDict:  # if dp[j] is true and the word is present in the dictionary
                    dp[i] = True  # update the dp[i]
                    break  # break
        return dp[n]  # return the dp[n]

139. Word Break in python3

// Time Complexity : O(n^2) where n is the size of the string s and space complexity is O(n)

class Solution:
    def wordBreak(self, s: str, wordDict: List[str) -> bool: // add the missing bracket after str
        n = len(s)  # variable to store the size of the string s
        dp = [False]*(n+1)  # vector to store the result
        dp[0] = True  # initialize the dp[0] to true
        for i in range(1, n+1):  # loop for i
            for j in range(i):  # loop for j
                if dp[j] and s[j:i] in wordDict:  # if dp[j] is true and the word is present in the dictionary
                    dp[i] = True  # update the dp[i]
                    break  # break
        return dp[n]  # return the dp[n]

139. Word Break in c

// Time Complexity : O(n^2) where n is the size of the string s and space complexity is O(n)

bool wordBreak(char * s, char ** wordDict, int wordDictSize){
    int n = strlen(s);  // variable to store the size of the string s
    bool dp[n+1];  // vector to store the result
    memset(dp, false, sizeof(dp));  // initialize the dp
    dp[0] = true;  // initialize the dp[0] to true
    for(int i=1; i<=n; i++){  // loop for i
        for(int j=0; j<i; j++){  // loop for j
            if(dp[j] && strstr(s+j, wordDict[i]) != NULL){  // if dp[j] is true and the word is present in the dictionary
                dp[i] = true;  // update the dp[i]
                break;  // break
            }
        }
    }
    return dp[n];  // return the dp[n]
}

139. Word Break in c#

// Time Complexity : O(n^2) where n is the size of the string s and space complexity is O(n)

public class Solution {
    public bool WordBreak(string s, IList<string> wordDict) {
        int n = s.Length;  // variable to store the size of the string s
        bool[] dp = new bool[n+1];  // vector to store the result
        dp[0] = true;  // initialize the dp[0] to true
        for(int i=1; i<=n; i++){  // loop for i
            for(int j=0; j<i; j++){  // loop for j
                if(dp[j] && wordDict.Contains(s.Substring(j, i-j))){  // if dp[j] is true and the word is present in the dictionary
                    dp[i] = true;  // update the dp[i]
                    break;  // break
                }
            }
        }
        return dp[n];  // return the dp[n]
    }
}

139. Word Break in javascript

// Time Complexity : O(n^2) where n is the size of the string s and space complexity is O(n)

var wordBreak = function(s, wordDict) {
    let n = s.length;  // variable to store the size of the string s
    let dp = new Array(n+1).fill(false);  // vector to store the result
    dp[0] = true;  // initialize the dp[0] to true
    for(let i=1; i<=n; i++){  // loop for i
        for(let j=0; j<i; j++){  // loop for j
            if(dp[j] && wordDict.includes(s.substring(j, i))){  // if dp[j] is true and the word is present in the dictionary
                dp[i] = true;  // update the dp[i]
                break;  // break
            }
        }
    }
    return dp[n];  // return the dp[n]
};

139. Word Break in Swift

// Time Complexity : O(n^2) where n is the size of the string s and space complexity is O(n)

class Solution {
    func wordBreak(_ s: String, _ wordDict: [String]) -> Bool {
        let n = s.count  // variable to store the size of the string s
        var dp = [Bool](repeating: false, count: n+1)  // vector to store the result
        dp[0] = true  // initialize the dp[0] to true
        for i in 1...n{  // loop for i
            for j in 0..<i{  // loop for j
                if dp[j] && wordDict.contains(String(s[s.index(s.startIndex, offsetBy: j)..<s.index(s.startIndex, offsetBy: i)])){  // if dp[j] is true and the word is present in the dictionary
                    dp[i] = true  // update the dp[i]
                    break  // break
                }
            }
        }
        return dp[n]  // return the dp[n]
    }
}

139. Word Break in dart 

// Time Complexity : O(n^2) where n is the size of the string s and space complexity is O(n)

bool wordBreak(String s, List<String> wordDict) {
    int n = s.length;  // variable to store the size of the string s
    List<bool> dp = new List<bool>.filled(n+1, false);  // vector to store the result
    dp[0] = true;  // initialize the dp[0] to true
    for(int i=1; i<=n; i++){  // loop for i
        for(int j=0; j<i; j++){  // loop for j
            if(dp[j] && wordDict.contains(s.substring(j, i))){  // if dp[j] is true and the word is present in the dictionary
                dp[i] = true;  // update the dp[i]
                break;  // break
            }
        }
    }
    return dp[n];  // return the dp[n]
}

2369. Check if There is a Valid Partition For The Array in c++

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
   bool validPartition(vector<int>& nums) {
        int n = nums.size(); // variable to store the size of the vector nums
        vector<bool> dp(n+1, false);  // vector to store the result
        dp[0] = true;
        for(int i=0; i<n; i++){
            bool ans = false; // variable to store the ans
            int index = i+1; // variable to store the dpindex
           if(i>0 && nums[i] == nums[i-1]) ans |= dp[(index-2)%3]; // if the current element is equal to the previous element
            if(i>1 && nums[i] == nums[i-1] && nums[i] == nums[i-2]) ans |= dp[(index-3)%3]; // if the current element is equal to the previous two elements
            if(i>1 && nums[i] == nums[i-1]+1 && nums[i] == nums[i-2]+2) ans |= dp[(index-3)%3]; // if the current element is equal to the previous two elements
            dp[index%3] = ans; // update the dp
    }
    return dp[n%3]; // return the dp[n%3]
    }

};

2369. Check if There is a Valid Partition For The Array in java

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public boolean validPartition(int[] nums) {
        int n = nums.length; // variable to store the size of the vector nums
        boolean[] dp = new boolean[3];  // vector to store the result
        dp[0] = true;  // initialize the dp[0] to true
        for(int i=0; i<n; i++){
            boolean ans = false; // variable to store the ans
            int index = i+1; // variable to store the dpindex
           if(i>0 && nums[i] == nums[i-1]) ans |= dp[(index-2)%3]; // if the current element is equal to the previous element
            if(i>1 && nums[i] == nums[i-1] && nums[i] == nums[i-2]) ans |= dp[(index-3)%3]; // if the current element is equal to the previous two elements
            if(i>1 && nums[i] == nums[i-1]+1 && nums[i] == nums[i-2]+2) ans |= dp[(index-3)%3]; // if the current element is equal to the previous two elements
            dp[index%3] = ans; // update the dp
    }
    return dp[n%3]; // return the dp[n%3]
    }
}

2369. Check if There is a Valid Partition For The Array in python

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution:
    def validPartition(self, nums: List[int]) -> bool:
        n = len(nums) # variable to store the size of the vector nums
        dp = [False]*3  # vector to store the result
        dp[0] = True
        for i in range(n):
            ans = False # variable to store the ans
            index = i+1 # variable to store the dpindex
            if i>0 and nums[i] == nums[i-1]: ans |= dp[(index-2)%3] # if the current element is equal to the previous element
            if i>1 and nums[i] == nums[i-1] and nums[i] == nums[i-2]: ans |= dp[(index-3)%3] # if the current element is equal to the previous two elements
            if i>1 and nums[i] == nums[i-1]+1 and nums[i] == nums[i-2]+2: ans |= dp[(index-3)%3] # if the current element is equal to the previous two elements
            dp[index%3] = ans # update the dp
        return dp[n%3] # return the dp[n%3]

2369. Check if There is a Valid Partition For The Array in python3

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution:
    def validPartition(self, nums: List[int) -> bool:  // add the missing bracket after int 
        n = len(nums) # variable to store the size of the vector nums
        dp = [False]*3  # vector to store the result
        dp[0] = True
        for i in range(n):
            ans = False # variable to store the ans
            index = i+1 # variable to store the dpindex
            if i>0 and nums[i] == nums[i-1]: ans |= dp[(index-2)%3] # if the current element is equal to the previous element
            if i>1 and nums[i] == nums[i-1] and nums[i] == nums[i-2]: ans |= dp[(index-3)%3] # if the current element is equal to the previous two elements
            if i>1 and nums[i] == nums[i-1]+1 and nums[i] == nums[i-2]+2: ans |= dp[(index-3)%3] # if the current element is equal to the previous two elements
            dp[index%3] = ans # update the dp
        return dp[n%3] # return the dp[n%3]

2369. Check if There is a Valid Partition For The Array in c

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

bool validPartition(int* nums, int numsSize){
    int n = numsSize; // variable to store the size of the vector nums
    bool dp[3];  // vector to store the result
    memset(dp, false, sizeof(dp));
    dp[0] = true;
    for(int i=0; i<n; i++){
        bool ans = false; // variable to store the ans
        int index = i+1; // variable to store the dpindex
        if(i>0 && nums[i] == nums[i-1]) ans |= dp[(index-2)%3]; // if the current element is equal to the previous element
        if(i>1 && nums[i] == nums[i-1] && nums[i] == nums[i-2]) ans |= dp[(index-3)%3]; // if the current element is equal to the previous two elements
        if(i>1 && nums[i] == nums[i-1]+1 && nums[i] == nums[i-2]+2) ans |= dp[(index-3)%3]; // if the current element is equal to the previous two elements
        dp[index%3] = ans; // update the dp
    }
    return dp[n%3]; // return the dp[n%3]
}

2369. Check if There is a Valid Partition For The Array in c#

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

public class Solution {
    public bool ValidPartition(int[] nums) {
        int n = nums.Length; // variable to store the size of the vector nums
        bool[] dp = new bool[3];  // vector to store the result
        dp[0] = true;
        for(int i=0; i<n; i++){
            bool ans = false; // variable to store the ans
            int index = i+1; // variable to store the dpindex
            if(i>0 && nums[i] == nums[i-1]) ans |= dp[(index-2)%3]; // if the current element is equal to the previous element
            if(i>1 && nums[i] == nums[i-1] && nums[i] == nums[i-2]) ans |= dp[(index-3)%3]; // if the current element is equal to the previous two elements
            if(i>1 && nums[i] == nums[i-1]+1 && nums[i] == nums[i-2]+2) ans |= dp[(index-3)%3]; // if the current element is equal to the previous two elements
            dp[index%3] = ans; // update the dp
    }
    return dp[n%3]; // return the dp[n%3]
    }
}

2369. Check if There is a Valid Partition For The Array in javascript

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

var validPartition = function(nums) {
    let n = nums.length; // variable to store the size of the vector nums
    let dp = new Array(3).fill(false);  // vector to store the result
    dp[0] = true;
    for(let i=0; i<n; i++){
        let ans = false; // variable to store the ans
        let index = i+1; // variable to store the dpindex
        if(i>0 && nums[i] == nums[i-1]) ans |= dp[(index-2)%3]; // if the current element is equal to the previous element
        if(i>1 && nums[i] == nums[i-1] && nums[i] == nums[i-2]) ans |= dp[(index-3)%3]; // if the current element is equal to the previous two elements
        if(i>1 && nums[i] == nums[i-1]+1 && nums[i] == nums[i-2]+2) ans |= dp[(index-3)%3]; // if the current element is equal to the previous two elements
        dp[index%3] = ans; // update the dp
    }
    return dp[n%3]; // return the dp[n%3]
};

2369. Check if There is a Valid Partition For The Array in Swift

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    func validPartition(_ nums: [Int]) -> Bool {
        let n = nums.count; // variable to store the size of the vector nums
        var dp = [Bool](repeating: false, count: 3);  // vector to store the result
        dp[0] = true;
        for i in 0..<n{
            var ans = false; // variable to store the ans
            let index = i+1; // variable to store the dpindex
            if i>0 && nums[i] == nums[i-1]{ ans = ans || dp[(index-2)%3]; } // if the current element is equal to the previous element
            if i>1 && nums[i] == nums[i-1] && nums[i] == nums[i-2]{ ans = ans || dp[(index-3)%3]; } // if the current element is equal to the previous two elements
            if i>1 && nums[i] == nums[i-1]+1 && nums[i] == nums[i-2]+2{ ans = ans || dp[(index-3)%3]; } // if the current element is equal to the previous two elements
            dp[index%3] = ans; // update the dp
        }
        return dp[n%3]; // return the dp[n%3]
    }
}


2369. Check if There is a Valid Partition For The Array in dart

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

bool validPartition(List<int> nums) {
    int n = nums.length; // variable to store the size of the vector nums
    List<bool> dp = new List<bool>.filled(3, false);  // vector to store the result
    dp[0] = true;
    for(int i=0; i<n; i++){
        bool ans = false; // variable to store the ans
        int index = i+1; // variable to store the dpindex
        if(i>0 && nums[i] == nums[i-1]) ans |= dp[(index-2)%3]; // if the current element is equal to the previous element
        if(i>1 && nums[i] == nums[i-1] && nums[i] == nums[i-2]) ans |= dp[(index-3)%3]; // if the current element is equal to the previous two elements
        if(i>1 && nums[i] == nums[i-1]+1 && nums[i] == nums[i-2]+2) ans |= dp[(index-3)%3]; // if the current element is equal to the previous two elements
        dp[index%3] = ans; // update the dp
    }
    return dp[n%3]; // return the dp[n%3]
}





2616. Minimize the Maximum Difference of Pairs in c++

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)


class Solution {
public:
    bool ispos(vector<int>nums,int diff,int pairs){ // function to check if the difference is possible or not
       int i =1; // variable to store the index
        int n = nums.size(); // variable to store the size of the vector nums
        int k = 0; // variable to store the number of pairs

        for(i;i<n && k<pairs;i++){ // loop for i
            if(nums[i]-nums[i-1]<=diff){ // if the difference is less than or equal to diff
                k++; // increment the k
                i++; // increment the i
            }
        }

        if(k>=pairs){ // if k is greater than or equal to pairs
            return true; // return true
        }
        return false; // return false

    }

    int minimizeMax(vector<int>& nums, int p) {
        sort(nums.begin(),nums.end()); // sort the vector nums
        int n = nums.size(); // variable to store the size of the vector nums
        int left = 0; // variable to store the left
        int right = nums[n-1]-nums[0]; // variable to store the right

        while(left<=right){ // loop till left is less than or equal to right

            int mid = (left+right)/2; // variable to store the mid

            if(ispos(nums,mid,p)){ // if the difference is possible
                right = mid-1; // update the right
            }
            else{
                left = mid+1; // update the left
            }
        }
        return left; // return the left
    }
};

2616. Minimize the Maximum Difference of Pairs in java

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public boolean ispos(int[] nums,int diff,int pairs){ // function to check if the difference is possible or not
        int i =1; // variable to store the index
        int n = nums.length; // variable to store the size of the vector nums
        int k = 0; // variable to store the number of pairs

        for(i=1;i<n && k<pairs;i++){ // loop for i
            if(nums[i]-nums[i-1]<=diff){ // if the difference is less than or equal to diff
                k++; // increment the k
                i++; // increment the i
            }
        }

        if(k>=pairs){ // if k is greater than or equal to pairs
            return true; // return true
        }
        return false; // return false

    }

    public int minimizeMax(int[] nums, int p) {
        Arrays.sort(nums); // sort the vector nums
        int n = nums.length; // variable to store the size of the vector nums
        int left = 0; // variable to store the left
        int right = nums[n-1]-nums[0]; // variable to store the right

        while(left<=right){ // loop till left is less than or equal to right

            int mid = (left+right)/2; // variable to store the mid

            if(ispos(nums,mid,p)){ // if the difference is possible
                right = mid-1; // update the right
            }
            else{
                left = mid+1; // update the left
            }
        }
        return left; // return the left
    }
}

2616. Minimize the Maximum Difference of Pairs in Python 

# Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution:
    def ispos(self,nums,diff,pairs): # function to check if the difference is possible or not
        i = 1 # variable to store the index
        n = len(nums) # variable to store the size of the vector nums
        k = 0 # variable to store the number of pairs

        while i<n: # loop for i
            if nums[i]-nums[i-1]<=diff: # if the difference is less than or equal to diff
                k+=1 # increment the k
                i+=1 # increment the i
            
            if k>=pairs: # if k is greater than or equal to pairs
                return True # return true
            i+=1
        return False # return false

    def minimizeMax(self, nums, p):
        """
        :type nums: List[int]
        :type p: int
        :rtype: int
        """
        nums.sort() # sort the vector nums
        n = len(nums) # variable to store the size of the vector nums
        left = 0 # variable to store the left
        right =  nums[n-1]-nums[0] # variable to store the right

        while left<right: # loop till left is less than or equal to right

            mid = left+(right-left)//2 # variable to store the mid

            if self.ispos(nums,mid,p): # if the difference is possible
                right = mid # update the right
            else:
                left = mid+1 # update the left
        return left # return the left

2616. Minimize the Maximum Difference of Pairs in python3

# Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution:
    def ispos(self,nums,diff,pairs): # function to check if the difference is possible or not
        i = 1 # variable to store the index
        n = len(nums) # variable to store the size of the vector nums
        k = 0 # variable to store the number of pairs

        while i<n: # loop for i
            if nums[i]-nums[i-1]<=diff: # if the difference is less than or equal to diff
                k+=1 # increment the k
                i+=1 # increment the i
            
            if k>=pairs: # if k is greater than or equal to pairs
                return True # return true
            i+=1
        return False # return false

    def minimizeMax(self, nums: List[int], p: int) -> int: # add the missing colon after List[int]
        nums.sort() # sort the vector nums
        n = len(nums) # variable to store the size of the vector nums
        left = 0 # variable to store the left
        right =  nums[n-1]-nums[0] # variable to store the right

        while left<right: # loop till left is less than or equal to right

            mid = left+(right-left)//2 # variable to store the mid

            if self.ispos(nums,mid,p): # if the difference is possible
                right = mid # update the right
            else:
                left = mid+1 # update the left
        return left # return the left

2616. Minimize the Maximum Difference of Pairs in c

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

int ispos(int* nums,int diff,int pairs,int n){ // function to check if the difference is possible or not
    int i =1; // variable to store the index
    int k = 0; // variable to store the number of pairs

    for(i=1;i<n && k<pairs;i++){ // loop for i
        if(nums[i]-nums[i-1]<=diff){ // if the difference is less than or equal to diff
            k++; // increment the k
            i++; // increment the i
        }
    }

    if(k>=pairs){ // if k is greater than or equal to pairs
        return 1; // return 1
    }
    return 0; // return 0

}

int minimizeMax(int* nums, int p, int n){
    qsort(nums,n,sizeof(int),cmpfunc); // sort the vector nums
    int left = 0; // variable to store the left
    int right = nums[n-1]-nums[0]; // variable to store the right

    while(left<=right){ // loop till left is less than or equal to right

        int mid = (left+right)/2; // variable to store the mid

        if(ispos(nums,mid,p,n)){ // if the difference is possible
            right = mid-1; // update the right
        }
        else{
            left = mid+1; // update the left
        }
    }
    return left; // return the left
}

2616. Minimize the Maximum Difference of Pairs in c#

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

public class Solution {
    public bool ispos(int[] nums,int diff,int pairs){ // function to check if the difference is possible or not
        int i =1; // variable to store the index
        int n = nums.Length; // variable to store the size of the vector nums
        int k = 0; // variable to store the number of pairs

        for(i=1;i<n && k<pairs;i++){ // loop for i
            if(nums[i]-nums[i-1]<=diff){ // if the difference is less than or equal to diff
                k++; // increment the k
                i++; // increment the i
            }
        }

        if(k>=pairs){ // if k is greater than or equal to pairs
            return true; // return true
        }
        return false; // return false

    }

    public int minimizeMax(int[] nums, int p) {
        Array.Sort(nums); // sort the vector nums
        int n = nums.Length; // variable to store the size of the vector nums
        int left = 0; // variable to store the left
        int right = nums[n-1]-nums[0]; // variable to store the right

        while(left<=right){ // loop till left is less than or equal to right

            int mid = (left+right)/2; // variable to store the mid

            if(ispos(nums,mid,p)){ // if the difference is possible
                right = mid-1; // update the right
            }
            else{
                left = mid+1; // update the left
            }
        }
        return left; // return the left
    }
}

2616. Minimize the Maximum Difference of Pairs in javascript

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

var ispos = function(nums,diff,pairs){ // function to check if the difference is possible or not
    let i =1; // variable to store the index
    let n = nums.length; // variable to store the size of the vector nums
    let k = 0; // variable to store the number of pairs

    for(i=1;i<n && k<pairs;i++){ // loop for i
        if(nums[i]-nums[i-1]<=diff){ // if the difference is less than or equal to diff
            k++; // increment the k
            i++; // increment the i
        }
    }

    if(k>=pairs){ // if k is greater than or equal to pairs
        return true; // return true
    }
    return false; // return false

}

var minimizeMax = function(nums, p) {
    nums.sort(function(a, b){return a - b}); // sort the vector nums
    let n = nums.length; // variable to store the size of the vector nums
    let left = 0; // variable to store the left
    let right = nums[n-1]-nums[0]; // variable to store the right

    while(left<=right){ // loop till left is less than or equal to right

        let mid = Math.floor((left+right)/2); // variable to store the mid

        if(ispos(nums,mid,p)){ // if the difference is possible
            right = mid-1; // update the right
        }
        else{
            left = mid+1; // update the left
        }
    }
    return left; // return the left
};

2616. Minimize the Maximum Difference of Pairs in Swift

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    func minimizeMax(_ nums: [Int], _ p: Int) -> Int {
        var nums = nums.sorted() // sort the vector nums
        var n = nums.count // variable to store the size of the vector nums
        var left = 0 , right = nums.last! - nums.first! // variable to store the left and right
        while left < right { // loop till left is less than right
            var mid = left + (right - left) / 2 // variable to store the mid
            var k = 0 , i = 1 // variable to store the k and i
            while i < n { // loop till i is less than n
                if nums[i] - nums[i-1] <= mid { // if the difference is less than or equal to mid
                    k += 1 // increment the k
                    i += 1 // increment the i
                }
                i += 1 // increment the i
            }
            if k >= p { // if k is greater than or equal to p
                right = mid // update the right
            }
            else { // else
                left = mid + 1 // update the left
            }
        }
        return left // return the left
    }
}

2616. Minimize the Maximum Difference of Pairs in dart

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution {
  bool ispos(List<int> nums,int diff,int pairs){ // function to check if the difference is possible or not
    int i =1; // variable to store the index
    int n = nums.length; // variable to store the size of the vector nums
    int k = 0; // variable to store the number of pairs

    for(i=1;i<n && k<pairs;i++){ // loop for i
        if(nums[i]-nums[i-1]<=diff){ // if the difference is less than or equal to diff
            k++; // increment the k
            i++; // increment the i
        }
    }

    if(k>=pairs){ // if k is greater than or equal to pairs
        return true; // return true
    }
    return false; // return false

}

int minimizeMax(List<int> nums, int p) {
    nums.sort(); // sort the vector nums
    int n = nums.length; // variable to store the size of the vector nums
    int left = 0; // variable to store the left
    int right = nums[n-1]-nums[0]; // variable to store the right

    while(left<=right){ // loop till left is less than or equal to right

        int mid = left + (right - left) ~/ 2; // variable to store the mid

        if(ispos(nums,mid,p)){ // if the difference is possible
            right = mid-1; // update the right
        }
        else{
            left = mid+1; // update the left
        }
    }
    return left; // return the left
}

}

239. Sliding Window Maximum in c++

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(k)

class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> dq; // deque
        vector<int> ans; // vector to store the result
        for(int i=0; i<nums.size(); i++){ // loop for i
            while(!dq.empty() && dq.back() < nums[i]){ // if the deque is not empty and the last element of the deque is less than nums[i]
                dq.pop_back(); // pop the last element from the deque
            }
            dq.push_back(nums[i]); // push the element in the deque
            if(i >= k-1){ // if i is greater than or equal to k-1
                ans.push_back(dq.front()); // push the front element of the deque in the ans
                if(nums[i-k+1] == dq.front()){ // if the front element of the deque is equal to nums[i-k+1]
                    dq.pop_front(); // pop the front element from the deque
                }d
            }
        }
        return ans; // return the ans
    }
};

239. Sliding Window Maximum in java

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(k)  

class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> dq = new LinkedList<>(); // deque
        int[] ans = new int[nums.length-k+1]; // vector to store the result
        for(int i=0; i<nums.length; i++){ // loop for i
            while(!dq.isEmpty() && dq.peekLast() < nums[i]){ // if the deque is not empty and the last element of the deque is less than nums[i]
                dq.pollLast(); // pop the last element from the deque
            }
            dq.offer(nums[i]); // push the element in the deque
            if(i >= k-1){ // if i is greater than or equal to k-1
                ans[i-k+1] = dq.peekFirst(); // push the front element of the deque in the ans
                if(nums[i-k+1] == dq.peekFirst()){ // if the front element of the deque is equal to nums[i-k+1]
                    dq.pollFirst(); // pop the front element from the deque
                }
            }
        }
        return ans; // return the ans
    }
}

239. Sliding Window Maximum in Python

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(k)

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        dq = collections.deque() # deque
        ans = [] # vector to store the result
        for i in range(len(nums)): # loop for i
            while dq and dq[-1] < nums[i]: # if the deque is not empty and the last element of the deque is less than nums[i]
                dq.pop() # pop the last element from the deque
            dq.append(nums[i]) # push the element in the deque
            if i >= k-1: # if i is greater than or equal to k-1
                ans.append(dq[0]) # push the front element of the deque in the ans
                if nums[i-k+1] == dq[0]: # if the front element of the deque is equal to nums[i-k+1]
                    dq.popleft() # pop the front element from the deque
        return ans # return the ans

239. Sliding Window Maximum in python3

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(k)

class Solution:
    def maxSlidingWindow(self, nums: List[int, k: int) -> List[int]: # add the missing bracket after List[int]
        dq = collections.deque() # deque
        ans = [] # vector to store the result
        for i in range(len(nums)): # loop for i
            while dq and dq[-1] < nums[i]: # if the deque is not empty and the last element of the deque is less than nums[i]
                dq.pop() # pop the last element from the deque
            dq.append(nums[i]) # push the element in the deque
            if i >= k-1: # if i is greater than or equal to k-1
                ans.append(dq[0]) # push the front element of the deque in the ans
                if nums[i-k+1] == dq[0]: # if the front element of the deque is equal to nums[i-k+1]
                    dq.popleft() # pop the front element from the deque
        return ans # return the ans

239. Sliding Window Maximum in c

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(k)

int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize){
    int* ans = (int*)malloc(sizeof(int)*(numsSize-k+1)); // vector to store the result
    int index = 0; // variable to store the index
    int* dq = (int*)malloc(sizeof(int)*numsSize); // deque
    int front = 0; // variable to store the front
    int rear = 0; // variable to store the rear
    for(int i=0; i<numsSize; i++){ // loop for i
        while(front != rear && dq[front] < nums[i]){ // if the deque is not empty and the last element of the deque is less than nums[i]
            front++; // increment the front
        }
        dq[front++] = nums[i]; // push the element in the deque
        if(i >= k-1){ // if i is greater than or equal to k-1
            ans[index++] = dq[rear]; // push the front element of the deque in the ans
            if(nums[i-k+1] == dq[rear]){ // if the front element of the deque is equal to nums[i-k+1]
                rear++; // increment the rear
            }
        }
    }
    *returnSize = index; // update the returnSize
    return ans; // return the ans
}

239. Sliding Window Maximum in c#

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(k)

public class Solution {
    public int[] MaxSlidingWindow(int[] nums, int k) {
        LinkedList<int> deque = new LinkedList<int>(); // Create a deque to store indices of elements in the sliding window
        int[] result = new int[nums.Length - k + 1]; // Create an array to store the maximum values for each window

        for (int i = 0; i < nums.Length; i++) {
            // Remove elements from the back of the deque that are smaller than the current element
            while (deque.Count > 0 && deque.Last.Value < nums[i])
                deque.RemoveLast();

            // Add the current element's index to the back of the deque
            deque.AddLast(nums[i]);

            // Check if the current index is beyond the first complete window
            if (i >= k - 1) {
                result[i - k + 1] = deque.First.Value; // The front of the deque contains the maximum element for the current window

                // If the element being removed from the window is the maximum, remove it from the front of the deque
                if (nums[i - k + 1] == deque.First.Value)
                    deque.RemoveFirst();
            }
        }

        return result; // Return the array containing maximum values for each window
    }
}

239. Sliding Window Maximum in javascript

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(k)

var maxSlidingWindow = function(nums, k) {
    let dq = []; // deque
    let ans = []; // vector to store the result
    for(let i=0; i<nums.length; i++){ // loop for i
        while(dq.length && dq[dq.length-1] < nums[i]){ // if e deque is not empty and the last element of the deque is less than nums[i]
            dq.pop(); // pop the last element from the deque
        }
        dq.push(nums[i]); // push the element in the deque
        if(i >= k-1){ // if i is greater than or equal to k-1
            ans.push(dq[0]); // push the front element of the deque in the ans
            if(nums[i-k+1] == dq[0]){ // if the front element of the deque is equal to nums[i-k+1]
                dq.shift(); // pop the front element from the deque
            }
        }
    }
    return ans; // return the ans
};

239. Sliding Window Maximum in Swift

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(k)

class Solution {
    func maxSlidingWindow(_ nums: [Int], _ k: Int) -> [Int] {
        var dq = [Int]() // deque
        var ans = [Int]() // vector to store the result
        for i in 0..<nums.count{ // loop for i
            while dq.count > 0 && dq.last! < nums[i]{ // if the deque is not empty and the last element of the deque is less than nums[i]
                dq.removeLast() // pop the last element from the deque
            }
            dq.append(nums[i]) // push the element in the deque
            if i >= k-1{ // if i is greater than or equal to k-1
                ans.append(dq.first!) // push the front element of the deque in the ans
                if nums[i-k+1] == dq.first!{ // if the front element of the deque is equal to nums[i-k+1]
                    dq.removeFirst() // pop the front element from the deque
                }
            }
        }
        return ans // return the ans
    }
}

239. Sliding Window Maximum in dart

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(k)

import 'dart:collection';
class Solution {
  List<int> maxSlidingWindow(List<int> nums, int k) {
    List<int> ans = [];
    Queue<int> dq = Queue<int>();

    for (int i = 0; i < nums.length; i++) {
      // Remove elements from the back of the queue that are smaller than the current element
      while (dq.isNotEmpty && nums[dq.last] < nums[i]) {
        dq.removeLast();
      }

      dq.add(i); // Add the index of the current element to the queue

      // Check if the front element of the queue is outside the current window
      if (dq.first <= i - k) {
        dq.removeFirst();
      }

      // Check if the window has reached the required size
      if (i >= k - 1) {
        ans.add(nums[dq.first]); // The front of the queue contains the maximum element for the current window
      }
    }

    return ans;
  }
}

215. Kth Largest Element in an Array in c++ using min heap

// Time Complexity : O(nlogk) where n is the size of the vector nums and space complexity is O(k)

class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int, vector<int>, greater<int>> pq; // min heap
        for(int i=0; i<nums.size(); i++){ // loop for i
            pq.push(nums[i]); // push the element in the min heap
            if(pq.size() > k){ // if the size of the min heap is greater than k
                pq.pop(); // pop the element from the min heap
            }
        }
        return pq.top(); // return the top element from the min heap
    }
};

2nd Method using  quick select (Quickselect, also known as Hoare's selection algorithm, is a selection algorithm to find the kth smallest/largest element in an unordered list. It is related to the quick sort sorting algorithm.)

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
      int findKthLargest(vector<int>& nums, int k) {
        return quickSelect(nums , k); // call the quickSelect function
    }

    int quickSelect(vector<int>& nums , int k){ // function to find the kth largest element
        int pivot = nums[rand() % nums.size()]; // variable to store the pivot
        vector<int> left; // vector to store the left
        vector<int> mid; // vector to store the mid
        vector<int> right; // vector to store the right
        for(int num : nums) { // loop for num
            if (num > pivot) { // if num is greater than pivot
                left.push_back(num); // push the num in the left
            } else if (num == pivot) { // else if num is equal to pivot
                mid.push_back(num); // push the num in the mid
            } else { // else
                right.push_back(num); // push the num in the right
            }
        }
       if(k<=left.size()){ // if k is less than or equal to left.size()
           return quickSelect(left , k); // call the quickSelect function
       }
       if(k>left.size()+mid.size()){ // if k is greater than left.size()+mid.size()
           return quickSelect(right , k-left.size()-mid.size()); // call the quickSelect function
       }
       return pivot; // return the pivot
    }

};
215. Kth Largest Element in an Array in java

// Time Complexity : O(nlogk) where n is the size of the vector nums and space complexity is O(k)

class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(); // min heap
        for(int i=0; i<nums.length; i++){ // loop for i
            pq.add(nums[i]); // push the element in the min heap
            if(pq.size() > k){ // if the size of the min heap is greater than k
                pq.poll(); // pop the element from the min heap
            }
        }
        return pq.peek(); // return the top element from the min heap
    }
}

2nd Method using  quick select (Quickselect, also known as Hoare's selection algorithm, is a selection algorithm to find the kth smallest/largest element in an unordered list. It is related to the quick sort sorting algorithm.)

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public int findKthLargest(int[] nums, int k) {
        return quickSelect(nums , k); // call the quickSelect function
    }

    public int quickSelect(int[] nums , int k){ // function to find the kth largest element
        int pivot = nums[new Random().nextInt(nums.length)]; // variable to store the pivot
        List<Integer> left = new ArrayList<>(); // vector to store the left
        List<Integer> mid = new ArrayList<>(); // vector to store the mid
        List<Integer> right = new ArrayList<>(); // vector to store the right
        for(int num : nums) { // loop for num
            if (num > pivot) { // if num is greater than pivot
                left.add(num); // push the num in the left
            } else if (num == pivot) { // else if num is equal to pivot
                mid.add(num); // push the num in the mid
            } else { // else
                right.add(num); // push the num in the right
            }
        }
       if(k<=left.size()){ // if k is less than or equal to left.size()
           return quickSelect(left.stream().mapToInt(i -> i).toArray() , k); // call the quickSelect function
       }
       if(k>left.size()+mid.size()){ // if k is greater than left.size()+mid.size()
           return quickSelect(right.stream().mapToInt(i -> i).toArray() , k-left.size()-mid.size()); // call the quickSelect function
       }
       return pivot; // return the pivot
    }

}

215. Kth Largest Element in an Array in python

// Time Complexity : O(nlogk) where n is the size of the vector nums and space complexity is O(k)

class Solution(object):
    def findKthLargest(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        pq = []  # min heap
        for i in range(len(nums)):  # loop for i
            heapq.heappush(pq, nums[i])  # push the element in the min heap
            if len(pq) > k:  # if the size of the min heap is greater than k
                heapq.heappop(pq)  # pop the element from the min heap
        return pq[0]  # return the top element from the min heap

2nd Method using  quick select (Quickselect, also known as Hoare's selection algorithm, is a selection algorithm to find the kth smallest/largest element in an unordered list. It is related to the quick sort sorting algorithm.)

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution(object):
    def findKthLargest(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        return self.quickSelect(nums, k)  # call the quickSelect function

    def quickSelect(self, nums, k):  # function to find the kth largest element
        pivot = random.choice(nums)  # variable to store the pivot
        left = []  # vector to store the left
        mid = []  # vector to store the mid
        right = []  # vector to store the right
        for num in nums:  # loop for num
            if num > pivot:  # if num is greater than pivot
                left.append(num)  # push the num in the left
            elif num == pivot:  # else if num is equal to pivot
                mid.append(num)  # push the num in the mid
            else:  # else
                right.append(num)  # push the num in the right
        if k <= len(left):  # if k is less than or equal to left.size()
            return self.quickSelect(left, k)  # call the quickSelect function
        if k > len(left) + len(mid):  # if k is greater than left.size()+mid.size()
            return self.quickSelect(right, k - len(left) - len(mid))  # call the quickSelect function
        return pivot  # return the pivot
    
215. Kth Largest Element in an Array in python3

// Time Complexity : O(nlogk) where n is the size of the vector nums and space complexity is O(k)

class Solution:
    def findKthLargest(self, nums: List[int, k: int) -> int:  // add the missing bracket after int
        pq = []  # min heap
        for i in range(len(nums)):  # loop for i
            heapq.heappush(pq, nums[i])  # push the element in the min heap
            if len(pq) > k:  # if the size of the min heap is greater than k
                heapq.heappop(pq)  # pop the element from the min heap
        return pq[0]  # return the top element from the min heap 

2nd Method using  quick select (Quickselect, also known as Hoare's selection algorithm, is a selection algorithm to find the kth smallest/largest element in an unordered list. It is related to the quick sort sorting algorithm.)

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution:
    def findKthLargest(self, nums: List[int, k: int) -> int:  // add the missing bracket after int
        return self.quickSelect(nums, k)  # call the quickSelect function

    def quickSelect(self, nums, k):  # function to find the kth largest element
        pivot = random.choice(nums)  # variable to store the pivot
        left = []  # vector to store the left
        mid = []  # vector to store the mid
        right = []  # vector to store the right
        for num in nums:  # loop for num
            if num > pivot:  # if num is greater than pivot
                left.append(num)  # push the num in the left
            elif num == pivot:  # else if num is equal to pivot
                mid.append(num)  # push the num in the mid
            else:  # else
                right.append(num)  # push the num in the right
        if k <= len(left):  # if k is less than or equal to left.size()
            return self.quickSelect(left, k)  # call the quickSelect function
        if k > len(left) + len(mid):  # if k is greater than left.size()+mid.size()
            return self.quickSelect(right, k - len(left) - len(mid))  # call the quickSelect function
        return pivot  # return the pivot

215. Kth Largest Element in an Array in c

// Time Complexity : O(nlogk) where n is the size of the vector nums and space complexity is O(k)

int findKthLargest(int* nums, int numsSize, int k){
    int pq[numsSize];  // min heap
    int size = 0;  // variable to store the size of the min heap
    for(int i=0; i<numsSize; i++){  // loop for i
        pq[size++] = nums[i];  // push the element in the min heap
        if(size > k){  // if the size of the min heap is greater than k
            heapify(pq, size);  // heapify the min heap
            pq[0] = pq[size-1];  // update the pq[0]
            size--;  // decrement the size
        }
    }
    heapify(pq, size);  // heapify the min heap
    return pq[0];  // return the top element from the min heap
}

void heapify(int* pq, int size){  // function to heapify the min heap
    for(int i=size/2-1; i>=0; i--){  // loop for i
        int smallest = i;  // variable to store the smallest
        int left = 2*i+1;  // variable to store the left
        int right = 2*i+2;  // variable to store the right
        if(left<size && pq[left]<pq[smallest]){  // if left is less than size and pq[left] is less than pq[smallest]
            smallest = left;  // update the smallest
        }
        if(right<size && pq[right]<pq[smallest]){  // if right is less than size and pq[right] is less than pq[smallest]
            smallest = right;  // update the smallest
        }
        if(smallest != i){  // if smallest is not equal to i
            int temp = pq[i];  // variable to store the pq[i]
            pq[i] = pq[smallest];  // update the pq[i]
            pq[smallest] = temp;  // update the pq[smallest]
            heapify(pq, size);  // heapify the min heap
        }
    }
}

215. Kth Largest Element in an Array in c#

// Time Complexity : O(nlogk) where n is the size of the vector nums and space complexity is O(k)

public class Solution {
    public int FindKthLargest(int[] nums, int k) {
    var queue = new PriorityQueue<int, int>(); // min heap 
     foreach (var num in nums) { // loop for num
        queue.Enqueue(num , num); // push the element in the min heap
        if (queue.Count > k) { // if the size of the min heap is greater than k
            queue.Dequeue(); // pop the element from the min heap
        }
    }
    return queue.Peek(); // return the top element from the min heap
    }
}

2nd Method using  quick select (Quickselect, also known as Hoare's selection algorithm, is a selection algorithm to find the kth smallest/largest element in an unordered list. It is related to the quick sort sorting algorithm.)

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

public class Solution {
    public int FindKthLargest(int[] nums, int k) {
        return QuickSelect(nums, k); // call the QuickSelect function
    }

    public int QuickSelect(int[] nums, int k) { // function to find the kth largest element
        var pivot = nums[new Random().Next(nums.Length)]; // variable to store the pivot
        var left = new List<int>(); // vector to store the left
        var mid = new List<int>(); // vector to store the mid
        var right = new List<int>(); // vector to store the right
        foreach (var num in nums) { // loop for num
            if (num > pivot) { // if num is greater than pivot
                left.Add(num); // push the num in the left
            } else if (num == pivot) { // else if num is equal to pivot
                mid.Add(num); // push the num in the mid
            } else { // else
                right.Add(num); // push the num in the right
            }
        }
        if (k <= left.Count) { // if k is less than or equal to left.size()
            return QuickSelect(left.ToArray(), k); // call the QuickSelect function
        }
        if (k > left.Count + mid.Count) { // if k is greater than left.size()+mid.size()
            return QuickSelect(right.ToArray(), k - left.Count - mid.Count); // call the QuickSelect function
        }
        return pivot; // return the pivot
    }
}

215. Kth Largest Element in an Array in javascript

// Time Complexity : O(nlogk) where n is the size of the vector nums and space complexity is O(k)

var findKthLargest = function(nums, k) {
    nums.sort((a, b) => a-b);    // sort the vector nums
    return nums[nums.length-k];  // return the kth largest element
};

2nd Method using  quick select (Quickselect, also known as Hoare's selection algorithm, is a selection algorithm to find the kth smallest/largest element in an unordered list. It is related to the quick sort sorting algorithm.)

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

var findKthLargest = function(nums, k) {
    return quickSelect(nums, k);  // call the quickSelect function
};

var quickSelect = function(nums, k) {  // function to find the kth largest element
    let pivot = nums[Math.floor(Math.random() * nums.length)];  // variable to store the pivot
    let left = [];  // vector to store the left
    let mid = [];  // vector to store the mid
    let right = [];  // vector to store the right
    for(let num of nums){  // loop for num
        if(num > pivot){  // if num is greater than pivot
            left.push(num);  // push the num in the left
        }
        else if(num == pivot){  // else if num is equal to pivot
            mid.push(num);  // push the num in the mid
        }
        else{  // else
            right.push(num);  // push the num in the right
        }
    }
    if(k <= left.length){  // if k is less than or equal to left.size()
        return quickSelect(left, k);  // call the quickSelect function
    }
    if(k > left.length + mid.length){  // if k is greater than left.size()+mid.size()
        return quickSelect(right, k - left.length - mid.length);  // call the quickSelect function
    }
    return pivot;  // return the pivot
};

215. Kth Largest Element in an Array in Swift

// Time Complexity : O(nlogk) where n is the size of the vector nums and space complexity is O(k)

class Solution {
    func findKthLargest(_ nums: [Int], _ k: Int) -> Int {
        return nums.sorted()[nums.count-k] // sort the vector nums and return the kth largest element
    }
}

2nd Method using  quick select (Quickselect, also known as Hoare's selection algorithm, is a selection algorithm to find the kth smallest/largest element in an unordered list. It is related to the quick sort sorting algorithm.)

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    func findKthLargest(_ nums: [Int], _ k: Int) -> Int {
        return quickSelect(nums, k) // call the quickSelect function
    }

    func quickSelect(_ nums: [Int], _ k: Int) -> Int { // function to find the kth largest element
        let pivot = nums.randomElement()! // variable to store the pivot
        var left = [Int]() // vector to store the left
        var mid = [Int]() // vector to store the mid
        var right = [Int]() // vector to store the right
        for num in nums{ // loop for num
            if num > pivot{ // if num is greater than pivot
                left.append(num) // push the num in the left
            }
            else if num == pivot{ // else if num is equal to pivot
                mid.append(num) // push the num in the mid
            }
            else{ // else
                right.append(num) // push the num in the right
            }
        }
        if k <= left.count{ // if k is less than or equal to left.size()
            return quickSelect(left, k) // call the quickSelect function
        }
        if k > left.count + mid.count{ // if k is greater than left.size()+mid.size()
            return quickSelect(right, k - left.count - mid.count) // call the quickSelect function
        }
        return pivot // return the pivot
    }
}

215. Kth Largest Element in an Array in dart

// Time Complexity : O(nlogk) where n is the size of the vector nums and space complexity is O(k)

int findKthLargest(List<int> nums, int k) {
    nums.sort(); // sort the vector nums
    return nums[nums.length-k]; // return the kth largest element
}

2nd Method using  quick select (Quickselect, also known as Hoare's selection algorithm, is a selection algorithm to find the kth smallest/largest element in an unordered list. It is related to the quick sort sorting algorithm.)

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)
class Solution {
int findKthLargest(List<int> nums, int k) {
    return quickSelect(nums, k); // call the quickSelect function
}

int quickSelect(List<int> nums, int k) { // function to find the kth largest element
    int pivot = nums[new Random().nextInt(nums.length)]; // variable to store the pivot
    List<int> left = []; // vector to store the left
    List<int> mid = []; // vector to store the mid
    List<int> right = []; // vector to store the right
    for(int num in nums){ // loop for num
        if(num > pivot){ // if num is greater than pivot
            left.add(num); // push the num in the left
        }
        else if(num == pivot){ // else if num is equal to pivot
            mid.add(num); // push the num in the mid
        }
        else{ // else
            right.add(num); // push the num in the right
        }
    }
    if(k <= left.length){ // if k is less than or equal to left.size()
        return quickSelect(left, k); // call the quickSelect function
    }
    if(k > left.length + mid.length){ // if k is greater than left.size()+mid.size()
        return quickSelect(right, k - left.length - mid.length); // call the quickSelect function
    }
    return pivot; // return the pivot
}
}

2824. Count Pairs Whose Sum is Less than Target

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
  int countPairs(vector<int>& nums , int target){ // function to count the pairs whose sum is less than target
      sort(nums.begin() , nums.end()); // sort the vector nums
      int count = 0; // variable to store the count
      int left = 0; // variable to store the left
      int right = nums.size()-1; // variable to store the right
      while(left < right){ // loop until left is less than right
          if(nums[left] + nums[right] < target){ // if nums[left] + nums[right] is less than target
              count += right-left; // update the count
              left++; // increment the left
          }
          else{ // else
              right--; // decrement the right
          }
      }
      return count; // return the count
  }
};

2824. Count Pairs Whose Sum is Less than Target in java

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public int countPairs(List<Integer> nums, int target) {
        Collections.sort(nums); // sort the vector nums
        int count = 0; // variable to store the count
        int left = 0; // variable to store the left
        int right = nums.size()-1; // variable to store the right
        while(left < right){ // loop until left is less than right
            if(nums.get(left) + nums.get(right) < target){ // if nums[left] + nums[right] is less than target
                count += right-left; // update the count
                left++; // increment the left
            }
            else{ // else
                right--; // decrement the right
            }
        }
        return count; // return the count
        
    }
}

2824. Count Pairs Whose Sum is Less than Target in python

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution(object):
    def countPairs(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        nums.sort() # sort the vector nums
        count = 0 # variable to store the count
        left = 0 # variable to store the left
        right = len(nums)-1 # variable to store the right
        while(left < right): # loop until left is less than right
            if(nums[left] + nums[right] < target): # if nums[left] + nums[right] is less than target
                count += right-left # update the count
                left += 1 # increment the left
            else: # else
                right -= 1 # decrement the right
        return count # return the count

2824. Count Pairs Whose Sum is Less than Target in python3

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution:
    def countPairs(self, nums: List[int], target: int) -> int:
        nums.sort() # sort the vector nums
        count = 0 # variable to store the count
        left = 0 # variable to store the left
        right = len(nums)-1 # variable to store the right
        while(left < right): # loop until left is less than right
            if(nums[left] + nums[right] < target): # if nums[left] + nums[right] is less than target
                count += right-left # update the count
                left += 1 # increment the left
            else: # else
                right -= 1 # decrement the right
        return count # return the count

2824. Count Pairs Whose Sum is Less than Target in c

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

int countPairs(int* nums, int numsSize, int target){
    qsort(nums, numsSize, sizeof(int), cmp); // sort the vector nums
    int count = 0; // variable to store the count
    int left = 0; // variable to store the left
    int right = numsSize-1; // variable to store the right
    while(left < right){ // loop until left is less than right
        if(nums[left] + nums[right] < target){ // if nums[left] + nums[right] is less than target
            count += right-left; // update the count
            left++; // increment the left
        }
        else{ // else
            right--; // decrement the right
        }
    }
    return count; // return the count
}

int cmp(const void* a, const void* b){ // function to compare the elements
    return *(int*)a - *(int*)b; // return the difference
}

2824. Count Pairs Whose Sum is Less than Target in c#

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

public class Solution {
    public int CountPairs(IList<int> nums, int target) {
        nums = nums.OrderBy(x => x).ToList(); // sort the vector nums
        int count = 0; // variable to store the count
        int left = 0; // variable to store the left
        int right = nums.Count-1; // variable to store the right
        while(left < right){ // loop until left is less than right
            if(nums[left] + nums[right] < target){ // if nums[left] + nums[right] is less than target
                count += right-left; // update the count
                left++; // increment the left
            }
            else{ // else
                right--; // decrement the right
            }
        }
        return count; // return the count
    }
}

2824. Count Pairs Whose Sum is Less than Target in javascript

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

var countPairs = function(nums, target) {
    nums.sort((a, b) => a-b); // sort the vector nums
    let count = 0; // variable to store the count
    let left = 0; // variable to store the left
    let right = nums.length-1; // variable to store the right
    while(left < right){ // loop until left is less than right
        if(nums[left] + nums[right] < target){ // if nums[left] + nums[right] is less than target
            count += right-left; // update the count
            left++; // increment the left
        }
        else{ // else
            right--; // decrement the right
        }
    }
    return count; // return the count
};

2824. Count Pairs Whose Sum is Less than Target in Swift

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    func countPairs(_ nums: [Int], _ target: Int) -> Int {
        var nums = nums.sorted() // sort the vector nums
        var count = 0 // variable to store the count
        var left = 0 // variable to store the left
        var right = nums.count-1 // variable to store the right
        while(left < right){ // loop until left is less than right
            if(nums[left] + nums[right] < target){ // if nums[left] + nums[right] is less than target
                count += right-left // update the count
                left += 1 // increment the left
            }
            else{ // else
                right -= 1 // decrement the right
            }
        }
        return count // return the count
    }
}

2824. Count Pairs Whose Sum is Less than Target in dart

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution {
  int countPairs(List<int> nums, int target) {
    nums.sort(); // sort the vector nums
    int count = 0; // variable to store the count
    int left = 0; // variable to store the left
    int right = nums.length-1; // variable to store the right
    while(left < right){ // loop until left is less than right
        if(nums[left] + nums[right] < target){ // if nums[left] + nums[right] is less than target
            count += right-left; // update the count
            left++; // increment the left
        }
        else{ // else
            right--; // decrement the right
        }
    }
    return count; // return the count
  }
}

2825. Make String a Subsequence Using Cyclic Increments in c++

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    bool canMakeSubsequence(std::string str1, std::string str2) {
        int i = 0; // variable to store the i
        int j = 0; // variable to store the j
        int n = str1.size(); // variable to store the size of the str1
        int m = str2.size(); // variable to store the size of the str2
        while(i<n && j<m){ // loop until i is less than n and j is less than m
            if(str1[i] == str2[j] || str1[i]+1 == str2[j] || str1[i] - 25 == str2[j]){  // if str1[i] is equal to str2[j] or str1[i]+1 is equal to str2[j] or str1[i] - 25 is equal to str2[j]
                j++; // increment the j
            }
            i++; // increment the i
        }
        return j == m; // return true if j is equal to m else return false
    }
};

2825. Make String a Subsequence Using Cyclic Increments in java

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public boolean canMakeSubsequence(String str1, String str2) {
        int i = 0; // variable to store the i
        int j = 0; // variable to store the j
        int n = str1.length(); // variable to store the size of the str1
        int m = str2.length(); // variable to store the size of the str2
        while(i<n && j<m){ // loop until i is less than n and j is less than m
            if(str1.charAt(i) == str2.charAt(j) || str1.charAt(i)+1 == str2.charAt(j) || str1.charAt(i) - 25 == str2.charAt(j)){  // if str1[i] is equal to str2[j] or str1[i]+1 is equal to str2[j] or str1[i] - 25 is equal to str2[j]
                j++; // increment the j
            }
            i++; // increment the i
        }
        return j == m; // return true if j is equal to m else return false
    }
}

2825. Make String a Subsequence Using Cyclic Increments in python

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution(object):
    def canMakeSubsequence(self, str1, str2):
        """
        :type str1: str
        :type str2: str
        :rtype: bool
        """
        i = 0 # variable to store the i
        j = 0 # variable to store the j
        n = len(str1) # variable to store the size of the str1
        m = len(str2) # variable to store the size of the str2
        while(i<n and j<m): # loop until i is less than n and j is less than m
              if str2[j] in {str1[i], chr(ord(str1[i]) + 1), chr(ord(str1[i]) - 25)}:  # if str1[i] is equal to str2[j] or str1[i]+1 is equal to str2[j] or str1[i] - 25 is equal to str2[j]
                j += 1 # increment the j
            i += 1 # increment the i
        return j == m # return true if j is equal to m else return false

2825. Make String a Subsequence Using Cyclic Increments in python3

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution:
    def canMakeSubsequence(self, str1: str, str2: str) -> bool:
        i = 0 # variable to store the i
        j = 0 # variable to store the j
        n = len(str1) # variable to store the size of the str1
        m = len(str2) # variable to store the size of the str2
        while(i<n and j<m): # loop until i is less than n and j is less than m
              if str2[j] in {str1[i], chr(ord(str1[i]) + 1), chr(ord(str1[i]) - 25)}:  # if str1[i] is equal to str2[j] or str1[i]+1 is equal to str2[j] or str1[i] - 25 is equal to str2[j]
                j += 1 # increment the j
            i += 1 # increment the i
        return j == m # return true if j is equal to m else return false
        

2825. Make String a Subsequence Using Cyclic Increments in c

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

bool canMakeSubsequence(char * str1, char * str2){
    int i = 0; // variable to store the i
    int j = 0; // variable to store the j
    int n = strlen(str1); // variable to store the size of the str1
    int m = strlen(str2); // variable to store the size of the str2
    while(i<n && j<m){ // loop until i is less than n and j is less than m
        if(str1[i] == str2[j] || str1[i]+1 == str2[j] || str1[i] - 25 == str2[j]){  // if str1[i] is equal to str2[j] or str1[i]+1 is equal to str2[j] or str1[i] - 25 is equal to str2[j]
            j++; // increment the j
        }
        i++; // increment the i
    }
    return j == m; // return true if j is equal to m else return false
}

2825. Make String a Subsequence Using Cyclic Increments in c#

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

public class Solution {
    public bool CanMakeSubsequence(string str1, string str2) {
        int i = 0; // variable to store the i
        int j = 0; // variable to store the j
        int n = str1.Length; // variable to store the size of the str1
        int m = str2.Length; // variable to store the size of the str2
        while(i<n && j<m){ // loop until i is less than n and j is less than m
            if(str1[i] == str2[j] || str1[i]+1 == str2[j] || str1[i] - 25 == str2[j]){  // if str1[i] is equal to str2[j] or str1[i]+1 is equal to str2[j] or str1[i] - 25 is equal to str2[j]
                j++; // increment the j
            }
            i++; // increment the i
        }
        return j == m; // return true if j is equal to m else return false
    }
}

2825. Make String a Subsequence Using Cyclic Increments in javascript

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

var canMakeSubsequence = function(str1, str2) {
    let i = 0; // variable to store the i
    let j = 0; // variable to store the j
    let n = str1.length; // variable to store the size of the str1
    let m = str2.length; // variable to store the size of the str2
    while(i < n && j < m){ // loop until i is less than n and j is less than m
        if ((str2.charCodeAt(j) - str1.charCodeAt(i) + 26) % 26 <= 1) { 
            // If the absolute difference between the Unicode values is 0 or 1
            // str2.charCodeAt(j) and str1.charCodeAt(i): These are used to obtain the Unicode values of the characters at positions j in str2 and i in str1, respectively.
            // (str2.charCodeAt(j) - str1.charCodeAt(i) + 26) % 26: This part of the condition calculates the difference between the Unicode values of the two characters and ensures the result is non-negative by adding 26 (the number of letters in the English alphabet). This difference modulo 26 ensures that the result remains within the range of a single alphabet cycle.
            // <= 1: This checks whether the calculated difference is either 0 or 1. If the difference is 0, it means the characters are the same. If the difference is 1, it means the characters are consecutive in the alphabet.

            j++; // increment the j
        }
        i++; // increment the i
    }
    return j === m; // return true if j is equal to m else return false
};

2825. Make String a Subsequence Using Cyclic Increments in Swift

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    func canMakeSubsequence(_ str1: String, _ str2: String) -> Bool {
        let str1Array = Array(str1) // Convert str1 to an array of characters
        let str2Array = Array(str2) // Convert str2 to an array of characters
        
        var i = 0 // variable to store the i
        var j = 0 // variable to store the j
        let n = str1Array.count // variable to store the size of the str1
        let m = str2Array.count // variable to store the size of the str2
        while(i<n && j<m){ // loop until i is less than n and j is less than m
            let char1 = str1Array[i] // variable to store the char1
            let char2 = str2Array[j] // variable to store the char2
            if char1 == char2 || char1.asciiValue! + 1 == char2.asciiValue! || char1.asciiValue! - 25 == char2.asciiValue!{  // if str1[i] is equal to str2[j] or str1[i]+1 is equal to str2[j] or str1[i] - 25 is equal to str2[j]
                j += 1 // increment the j
            }
            i += 1 // increment the i
        }
        return j == m // return true if j is equal to m else return false
    }
}

2nd Method 

extension String {
    subscript(idx: Int) -> Character {
        self[index(startIndex, offsetBy: idx)]
    }
}

class Solution {
    
    func canMakeSubsequence(_ str1: String, _ str2: String) -> Bool {
        let str1 = Array(str1)
        let str2 = Array(str2)
        
        let m = str1.count
        let n = str2.count
        var i = 0, j = 0
        let a: Character = "a", aValue = a.asciiValue!
        while i < m, j < n {
            guard var char1 = str1[i].asciiValue, var char2 = str2[j].asciiValue else {
                return false
            }
            char1 -= aValue
            char2 -= aValue
            if char1 == char2 || (char1 + 1) % 26 == char2 {
                j += 1
            }
            i += 1
        }
        return j == n 
    }
}

2825. Make String a Subsequence Using Cyclic Increments in dart

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
  bool canMakeSubsequence(String str1, String str2) {
    int i = 0; // variable to store the i
    int j = 0; // variable to store the j
    int n = str1.length; // variable to store the size of str1
    int m = str2.length; // variable to store the size of str2
    while (i < n && j < m) { // loop until i is less than n and j is less than m
      if (str1[i] == str2[j] || str1[i].codeUnitAt(0) + 1 == str2[j].codeUnitAt(0) || str1[i].codeUnitAt(0) - 25 == str2[j].codeUnitAt(0)) {
        // if str1[i] is equal to str2[j] or str1[i]+1 is equal to str2[j] or str1[i] - 25 is equal to str2[j]
        j++; // increment j
      }
      i++; // increment i
    }
    return j == m; // return true if j is equal to m else return false
  }
}

2826. Sorting Three Groups in c++

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

// Brute Force

class Solution {
public:
    int minimumOperations(vector<int>& nums) {
        int n = nums.size(); // variable to store the size of the nums
        int count = 0; // variable to store the count
        int i = 0; // variable to store the i
        int j = n-1; // variable to store the j
        while(i<j){ // loop until i is less than j
            if(nums[i] == nums[j]){ // if nums[i] is equal to nums[j]
                i++; // increment the i
                j--; // decrement the j
            }
            else if(nums[i] < nums[j]){ // else if nums[i] is less than nums[j]
                nums[i+1] += nums[i]; // update the nums[i+1]
                i++; // increment the i
                count++; // increment the count
            }
            else{ // else
                nums[j-1] += nums[j]; // update the nums[j-1]
                j--; // decrement the j
                count++; // increment the count
            }
        }
        return count; // return the count
        
    }
};

// Optimal Solution using DP

class Solution {
public:
    int minimumOperations(vector<int>& nums) {
        int n = nums.size();    // variable to store the size of the nums
        vector<int> dp(4 , n) ; // vector to store the dp array
        for(int num : nums) {   // loop for num
            dp[num]--;        // update the dp[num] ,  This line decrements the value of the element in the dp vector at index a. In the context of this code, a represents the current element from the input vector. This decrement operation essentially counts how many occurrences of each value (0, 1, 2, or 3) are present in the input vector.
            dp[2] = min(dp[2] , dp[1]); // update the dp[2] , This line updates the value of the element at index 2 in the dp vector. It takes the minimum of the current value at index 2 (dp[2]) and the value at index 1 (dp[1]). This operation is used to ensure that the minimum number of operations is tracked for transitioning from value 1 to value 2.
            dp[3] = min(dp[3] , dp[2]); // update the dp[3] , Similar to the previous line, this updates the value of the element at index 3 in the dp vector. It takes the minimum of the current value at index 3 (dp[3]) and the updated value at index 2 (dp[2]). This operation is used to ensure that the minimum number of operations is tracked for transitioning from value 2 to value 3.
        }
        return dp[3]; // return the dp[3]
    }
};

2826. Sorting Three Groups in java using DP

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public int minimumOperations(List<Integer> nums) {
        int n = nums.size();    // variable to store the size of the nums
        int[] dp = new int[4];  // vector to store the dp array
        Arrays.fill(dp, n);     // fill the dp array with n
        for(int num : nums) {   // loop for num
            dp[num]--;        // update the dp[num] ,  This line decrements the value of the element in the dp vector at index a. In the context of this code, a represents the current element from the input vector. This decrement operation essentially counts how many occurrences of each value (0, 1, 2, or 3) are present in the input vector.
            dp[2] = Math.min(dp[2] , dp[1]); // update the dp[2] , This line updates the value of the element at index 2 in the dp vector. It takes the minimum of the current value at index 2 (dp[2]) and the value at index 1 (dp[1]). This operation is used to ensure that the minimum number of operations is tracked for transitioning from value 1 to value 2.
            dp[3] = Math.min(dp[3] , dp[2]); // update the dp[3] , Similar to the previous line, this updates the value of the element at index 3 in the dp vector. It takes the minimum of the current value at index 3 (dp[3]) and the updated value at index 2 (dp[2]). This operation is used to ensure that the minimum number of operations is tracked for transitioning from value 2 to value 3.
        }
        return dp[3]; // return the dp[3]
    }
}

2826. Sorting Three Groups in python using DP

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution(object):
    def minimumOperations(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums) # variable to store the size of the nums
        dp = [n] * 4 # vector to store the dp array
        for num in nums: # loop for num
            dp[num] -= 1 # update the dp[num] ,  This line decrements the value of the element in the dp vector at index a. In the context of this code, a represents the current element from the input vector. This decrement operation essentially counts how many occurrences of each value (0, 1, 2, or 3) are present in the input vector.
            dp[2] = min(dp[2] , dp[1]) # update the dp[2] , This line updates the value of the element at index 2 in the dp vector. It takes the minimum of the current value at index 2 (dp[2]) and the value at index 1 (dp[1]). This operation is used to ensure that the minimum number of operations is tracked for transitioning from value 1 to value 2.
            dp[3] = min(dp[3] , dp[2]) # update the dp[3] , Similar to the previous line, this updates the value of the element at index 3 in the dp vector. It takes the minimum of the current value at index 3 (dp[3]) and the updated value at index 2 (dp[2]). This operation is used to ensure that the minimum number of operations is tracked for transitioning from value 2 to value 3.
        return dp[3] # return the dp[3]

2826. Sorting Three Groups in python3 using DP

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution:
    def minimumOperations(self, nums: List[int) -> int: // add bracket after int
        n = len(nums) # variable to store the size of the nums
        dp = [n] * 4 # vector to store the dp array
        for num in nums: # loop for num
            dp[num] -= 1 # update the dp[num] ,  This line decrements the value of the element in the dp vector at index a. In the context of this code, a represents the current element from the input vector. This decrement operation essentially counts how many occurrences of each value (0, 1, 2, or 3) are present in the input vector.
            dp[2] = min(dp[2] , dp[1]) # update the dp[2] , This line updates the value of the element at index 2 in the dp vector. It takes the minimum of the current value at index 2 (dp[2]) and the value at index 1 (dp[1]). This operation is used to ensure that the minimum number of operations is tracked for transitioning from value 1 to value 2.
            dp[3] = min(dp[3] , dp[2]) # update the dp[3] , Similar to the previous line, this updates the value of the element at index 3 in the dp vector. It takes the minimum of the current value at index 3 (dp[3]) and the updated value at index 2 (dp[2]). This operation is used to ensure that the minimum number of operations is tracked for transitioning from value 2 to value 3.
        return dp[3] # return the dp[3]

2826. Sorting Three Groups in c using DP

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

int minimumOperations(int* nums, int numsSize){
    int n = numsSize; // variable to store the size of the nums
    int dp[4] = {n, n, n, n}; // vector to store the dp array
    for(int i = 0; i < n; i++){ // loop for i
        dp[nums[i]]--; // update the dp[num] ,  This line decrements the value of the element in the dp vector at index a. In the context of this code, a represents the current element from the input vector. This decrement operation essentially counts how many occurrences of each value (0, 1, 2, or 3) are present in the input vector.
        dp[2] = fmin(dp[2] , dp[1]); // update the dp[2] , This line updates the value of the element at index 2 in the dp vector. It takes the minimum of the current value at index 2 (dp[2]) and the value at index 1 (dp[1]). This operation is used to ensure that the minimum number of operations is tracked for transitioning from value 1 to value 2.
        dp[3] = fmin(dp[3] , dp[2]); // update the dp[3] , Similar to the previous line, this updates the value of the element at index 3 in the dp vector. It takes the minimum of the current value at index 3 (dp[3]) and the updated value at index 2 (dp[2]). This operation is used to ensure that the minimum number of operations is tracked for transitioning from value 2 to value 3.
    }
    return dp[3]; // return the dp[3]
}

2826. Sorting Three Groups in c#

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

public class Solution {
    public int MinimumOperations(IList<int> nums) {
        int n = nums.Count; // variable to store the size of the nums
        int[] dp = new int[4]; // vector to store the dp array
        Array.Fill(dp, n);  // fill the dp array with n

        for (int i = 0; i < n; i++) {   // loop for i
            int num = nums[i];  // variable to store the num
            dp[num]--;  // update the dp[num] ,  This line decrements the value of the element in the dp vector at index a. In the context of this code, a represents the current element from the input vector. This decrement operation essentially counts how many occurrences of each value (0, 1, 2, or 3) are present in the input vector.
            dp[2] = Math.Min(dp[2], dp[1]); // update the dp[2] , This line updates the value of the element at index 2 in the dp vector. It takes the minimum of the current value at index 2 (dp[2]) and the value at index 1 (dp[1]). This operation is used to ensure that the minimum number of operations is tracked for transitioning from value 1 to value 2.
            dp[3] = Math.Min(dp[3], dp[2]); // update the dp[3] , Similar to the previous line, this updates the value of the element at index 3 in the dp vector. It takes the minimum of the current value at index 3 (dp[3]) and the updated value at index 2 (dp[2]). This operation is used to ensure that the minimum number of operations is tracked for transitioning from value 2 to value 3.
        }

        return dp[3];   // return the dp[3]
    }
}



2826. Sorting Three Groups in javascript using DP

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

var minimumOperations = function(nums) {
    let n = nums.length; // variable to store the size of the nums
    let dp = new Array(4).fill(n); // vector to store the dp array
    for(let num of nums){ // loop for num
        dp[num]--; // update the dp[num] ,  This line decrements the value of the element in the dp vector at index a. In the context of this code, a represents the current element from the input vector. This decrement operation essentially counts how many occurrences of each value (0, 1, 2, or 3) are present in the input vector.
        dp[2] = Math.min(dp[2] , dp[1]); // update the dp[2] , This line updates the value of the element at index 2 in the dp vector. It takes the minimum of the current value at index 2 (dp[2]) and the value at index 1 (dp[1]). This operation is used to ensure that the minimum number of operations is tracked for transitioning from value 1 to value 2.
        dp[3] = Math.min(dp[3] , dp[2]); // update the dp[3] , Similar to the previous line, this updates the value of the element at index 3 in the dp vector. It takes the minimum of the current value at index 3 (dp[3]) and the updated value at index 2 (dp[2]). This operation is used to ensure that the minimum number of operations is tracked for transitioning from value 2 to value 3.
    }
    return dp[3]; // return the dp[3]
};

2826. Sorting Three Groups in Swift using DP

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    func minimumOperations(_ nums: [Int]) -> Int {
        let n = nums.count // variable to store the size of the nums
        var dp = Array(repeating: n, count: 4) // vector to store the dp array
        for num in nums { // loop for num
            dp[num] -= 1 // update the dp[num] ,  This line decrements the value of the element in the dp vector at index a. In the context of this code, a represents the current element from the input vector. This decrement operation essentially counts how many occurrences of each value (0, 1, 2, or 3) are present in the input vector.
            dp[2] = min(dp[2] , dp[1]) // update the dp[2] , This line updates the value of the element at index 2 in the dp vector. It takes the minimum of the current value at index 2 (dp[2]) and the value at index 1 (dp[1]). This operation is used to ensure that the minimum number of operations is tracked for transitioning from value 1 to value 2.
            dp[3] = min(dp[3] , dp[2]) // update the dp[3] , Similar to the previous line, this updates the value of the element at index 3 in the dp vector. It takes the minimum of the current value at index 3 (dp[3]) and the updated value at index 2 (dp[2]). This operation is used to ensure that the minimum number of operations is tracked for transitioning from value 2 to value 3.
        }
        return dp[3] // return the dp[3]
    }
}

2826. Sorting Three Groups in dart using DP

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
  int minimumOperations(List<int> nums) {
    int n = nums.length; // variable to store the size of the nums
    List<int> dp = new List.filled(4, n); // vector to store the dp array
    for (int num in nums) { // loop for num
      dp[num]--; // update the dp[num] ,  This line decrements the value of the element in the dp vector at index a. In the context of this code, a represents the current element from the input vector. This decrement operation essentially counts how many occurrences of each value (0, 1, 2, or 3) are present in the input vector.
      dp[2] = min(dp[2], dp[1]); // update the dp[2] , This line updates the value of the element at index 2 in the dp vector. It takes the minimum of the current value at index 2 (dp[2]) and the value at index 1 (dp[1]). This operation is used to ensure that the minimum number of operations is tracked for transitioning from value 1 to value 2.
      dp[3] = min(dp[3], dp[2]); // update the dp[3] , Similar to the previous line, this updates the value of the element at index 3 in the dp vector. It takes the minimum of the current value at index 3 (dp[3]) and the updated value at index 2 (dp[2]). This operation is used to ensure that the minimum number of operations is tracked for transitioning from value 2 to value 3.
    }
    return dp[3]; // return the dp[3]
  }
}

459. Repeated Substring Pattern in c++


KMP (Knuth-Morris-Pratt) and LPS (Longest Prefix which is also Suffix) are algorithms and concepts used in string matching and manipulation problems, including problems related to repeated substrings or pattern searching. These algorithms are particularly useful for optimizing substring search and pattern matching in linear time.

1. **KMP Algorithm (Knuth-Morris-Pratt Algorithm)**:

The KMP algorithm is used for efficiently finding occurrences of a given pattern (substring) within a text (string). It works by preprocessing the pattern to create an auxiliary array known as the Longest Prefix which is also Suffix (LPS) array. This LPS array helps to determine the amount by which the pattern can be shifted during a mismatch in the pattern-text comparison.

The KMP algorithm avoids unnecessary comparisons by using information from the LPS array to guide its search. This makes it more efficient than simple brute-force methods for substring matching.

2. **LPS Array (Longest Prefix which is also Suffix)**:

The LPS array is used by the KMP algorithm to optimize substring matching. It's an array of the same length as the pattern string, where each element `lps[i]` represents the length of the longest proper prefix of the substring `pattern[0...i]` that is also a suffix of the same substring.

For example, if the pattern is "ABABCAB", the LPS array is [0, 0, 1, 2, 0, 1, 2]. This means that the longest prefix which is also a suffix for "AB" is 0, for "ABA" it's 1, for "ABAB" it's 2, and so on.

In the context of problems related to repeated substrings or pattern searching, you might use KMP and the LPS array to efficiently find repeated patterns within a string. These algorithms help optimize the search for patterns in linear time, making them quite powerful for string manipulation problems.

When dealing with problems like the "Repeated Substring Pattern" you mentioned earlier, KMP and LPS can be used to optimize the repeated pattern search process. By utilizing these algorithms, you can efficiently identify patterns that are repeated within a string and thus solve the problem more effectively.




// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(n)

class Solution {
public:
    bool repeatedSubstringPattern(string s) { // function to check whether the string is repeated substring pattern or not
        int n=s.size(); // variable to store the size of the string
        for(int i=n/2;i>=1;i--){  // loop until i is greater than or equal to 1 ,  This loop iterates from half of the string length down to 1. The idea is to check for possible substring lengths that can form the repeated pattern.
            if(n%i==0){     // if n%i is equal to 0 , Check if the current value of i is a divisor of n. If it is, then it's a potential candidate for a substring length that might form the repeated pattern.
                if(s.substr(0,n-i)==s.substr(i))return true;   // if s.substr(0,n-i) is equal to s.substr(i) return true , This line compares two substrings. The first substring starts from index 0 and has a length of (n - i), while the second substring starts from index i. If these two substrings are equal, it means that a repeated substring of length i is found.
            }
        }
        return false;   // return false
    }
};

2nd Method:

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(n)

class Solution {
public:
    bool repeatedSubstringPattern(string s) {  // function to check whether the string is repeated substring pattern or not
        string t = s + s;  // Concatenate the string with itself  (e.g. "abc" + "abc" = "abcabc")
        if (t.substr(1, t.size() - 2).find(s) != -1) return true;  // Check if the substring exists  (e.g. "abc" is found in "bcabca")
        // This line performs the following steps:
        // t.substr(1, t.size() - 2): This extracts a substring from the concatenated string t. The range (1, t.size() - 2) is used to exclude the first and last characters of t. This is done to remove one instance of the original string that appears at both the beginning and the end of the concatenated string.
        // .find(s) != -1: This checks if the original string s exists within the extracted substring. The find function returns the position of the substring within the string it's called on. If the substring is not found, it returns -1.
        // If s is found within the substring, the condition will evaluate to true, and the function will return true, indicating that the given string can be formed by repeating a substring.
        return false;  // If not, return false  (e.g. "abc" is not found in "bcabc")
    }
};

3rd Method 

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(n)

class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        string t = s + s;  // Concatenate the string with itself

        return t.find(s, 1) != s.size();  // Check if the original string is present starting from index 1
    }
};

459. Repeated Substring Pattern in java

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(n)

class Solution {
    public boolean repeatedSubstringPattern(String s) {
        String t = s + s;  // Concatenate the string with itself
        return t.substring(1, t.length() - 1).contains(s);  // Check if the substring exists
    }
}

459. Repeated Substring Pattern in python

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(n)

class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        t = s + s  # Concatenate the string with itself
        return s in t[1:-1]  # Check if the substring exists

459. Repeated Substring Pattern in python3

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(n)

class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        t = s + s  # Concatenate the string with itself
        return s in t[1:-1]  # Check if the substring exists

459. Repeated Substring Pattern in c

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(n)

bool repeatedSubstringPattern(char * s){
    int n = strlen(s); // variable to store the size of the string
    char * t = (char *)malloc(sizeof(char)*(2*n+1)); // variable to store the t
    strcpy(t,s); // copy the s to t
    strcat(t,s); // concatenate the s to t
    char * p = strstr(t+1,s); // variable to store the p
    if(p == NULL){ // if p is equal to NULL
        return false; // return false
    }
    return true; // return true
}

459. Repeated Substring Pattern in c#

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(n)

public class Solution {
    public bool RepeatedSubstringPattern(string s) {
        string t = s + s;  // Concatenate the string with itself
        return t.Substring(1, t.Length - 2).Contains(s);  // Check if the substring exists
    }
}

459. Repeated Substring Pattern in javascript

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(n)

var repeatedSubstringPattern = function(s) {
    let t = s + s;  // Concatenate the string with itself
    return t.substring(1, t.length - 1).includes(s);  // Check if the substring exists
};

459. Repeated Substring Pattern in Swift

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(n)

class Solution {
    func repeatedSubstringPattern(_ s: String) -> Bool {
        let t = s + s  // Concatenate the string with itself
        return t[t.index(t.startIndex, offsetBy: 1)..<t.index(t.endIndex, offsetBy: -1)].contains(s)  // Check if the substring exists
    }
}

459. Repeated Substring Pattern in dart

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(n)

class Solution {
  bool repeatedSubstringPattern(String s) {
    String t = s + s; // variable to store the t
    return t.substring(1, t.length - 1).contains(s); // Check if the substring exists
  }
}

646. Maximum Length of Pair Chain in c++

Approach 1: Iterative Dynamic Programming

// Time Complexity : O(n^2) where n is the size of the vector nums and space complexity is O(n)

class Solution {
public:
    int findLongestChain(vector<vector<int>>& pairs) { // function to find the longest chain
        int n=pairs.size(); // variable to store the size of the pairs
        sort(pairs.begin(),pairs.end()); // sort the pairs
        vector<int>dp(n,1); // vector to store the dp
        for(int i=1;i<n;i++){ // loop until i is less than n
            for(int j=0;j<i;j++){ // loop until j is less than i
                if(pairs[i][0]>pairs[j][1])dp[i]=max(dp[i],dp[j]+1); // if pairs[i][0] is greater than pairs[j][1] update the dp[i]
            }
        }
        return *max_element(dp.begin(),dp.end()); // return the max element of the dp
    }
};

Approach 2: Greedy

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    int findLongestChain(vector<vector<int>>& pairs) { // function to find the longest chain
        int n=pairs.size(); // variable to store the size of the pairs
        sort(pairs.begin(),pairs.end(),[](vector<int>&a,vector<int>&b){ // sort the pairs
            return a[1]<b[1]; // return a[1]<b[1]
        });
        int ans=0; // variable to store the ans 
        int curr=INT_MIN; // variable to store the curr
        for(auto pair : pairs){ // loop for pair
            if(curr<pair[0]){ // if curr is less than pair[0]
                ans++; // increment the ans
                curr=pair[1]; // update the curr
            }
        }
        return ans; // return the ans
    }
};

646. Maximum Length of Pair Chain in java

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public int findLongestChain(int[][] pairs) { // function to find the longest chain
        Arrays.sort(pairs, (a, b) -> a[1] - b[1]); // sort the pairs
        int ans = 0; // variable to store the ans
        int curr = Integer.MIN_VALUE; // variable to store the curr
        for (int[] pair : pairs) { // loop for pair
            if (curr < pair[0]) { // if curr is less than pair[0]
                ans++; // increment the ans
                curr = pair[1]; // update the curr
            }
        }
        return ans; // return the ans
    }
}

646. Maximum Length of Pair Chain in python

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution:
     def findLongestChain(self, pairs): // function to find the longest chain
        """
        :type pairs: List[List[int]]
        :rtype: int
        """
        pairs.sort(key=lambda x: x[1]) // sort the pairs
        ans = 0 // variable to store the ans
        curr = float('-inf') // variable to store the curr
        for pair in pairs: // loop for pair
            if curr < pair[0]: // if curr is less than pair[0]
                ans += 1 // increment the ans
                curr = pair[1] // update the curr
        return ans // return the ans

646. Maximum Length of Pair Chain in python3

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution:
    def findLongestChain(self, pairs: List[List[int]]) -> int: // add bracket after List
        pairs.sort(key=lambda x: x[1]) // sort the pairs
        ans = 0 // variable to store the ans
        curr = float('-inf') // variable to store the curr
        for pair in pairs: // loop for pair
            if curr < pair[0]: // if curr is less than pair[0]
                ans += 1 // increment the ans
                curr = pair[1] // update the curr
        return ans // return the ans

646. Maximum Length of Pair Chain in c

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

int cmp(const vod *a, const void *b) { // function to compare the two elements
    int *arr1 = *(int **)a; // variable to store the arr1
    int *arr2 = *(int **)b; // variable to store the arr2
    return arr1[1] - arr2[1]; // return arr1[1] - arr2[1]
}

int findLongestChain(int** pairs, int pairsSize, int* pairsColSize){
    qsort(pairs, pairsSize, sizeof(int *), cmp); // sort the pairs
    int ans = 0; // variable to store the ans
    int curr = INT_MIN; // variable to store the curr
    for (int i = 0; i < pairsSize; i++) { // loop until i is less than pairsSize
        if (curr < pairs[i][0]) { // if curr is less than pairs[i][0]
            ans++; // increment the ans
            curr = pairs[i][1]; // update the curr
        }
    }
    return ans; // return the ans
}

646. Maximum Length of Pair Chain in c#

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

public class Solution {
    public int FindLongestChain(int[][] pairs) { // function to find the longest chain
        Array.Sort(pairs, (a, b) => a[1] - b[1]); // sort the pairs
        int ans = 0; // variable to store the ans
        int curr = int.MinValu; // variable to store the curr
        foreach (int[] pair in pairs) { // loop for pair
            if (curr < pair[0]) { // if curr is less than pair[0]
                ans++; // increment the ans
                curr = pair[1]; // update the curr
            }
        }
        return ans; // return the ans
    }
}

646. Maximum Length of Pair Chain in javascript

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

var findLongestChain = function(pairs) {
    pairs.sort((a, b) => a[1] - b[1]); // sort the pairs
    let ans = 0; // variable to store the ans
    let curr = -Infinity; // variable to store the curr
    for (let pair of pairs) { // loop for pair
        if (curr < pair[0]) { // if curr is less than pair[0]
            ans++; // increment the ans
            curr = pair[1]; // update the curr
        }
    }
    return ans; // return the ans
};

646. Maximum Length of Pair Chain in Swift

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    func findLongestChain(_ pairs: [[Int]]) -> Int { // function to find the longest chain
        let pairs = pairs.sorted { $0[1] < $1[1] } // sort the pairs
        var ans = 0 // variable to store the ans
        var curr = Int.min // variable to store the curr
        for pair in pairs { // loop for pair
            if curr < pair[0] { // if curr is less than pair[0]
                ans += 1 // increment the ans
                curr = pair[1] // update the curr
            }
        }
        return ans // return the ans
    }
}

646. Maximum Length of Pair Chain in dart

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution {
  int findLongestChain(List<List<int>> pairs) { // function to find the longest chain
    pairs.sort((a, b) => a[1] - b[1]); // sort the pairs
    int ans = 0; // variable to store the ans
    int curr = -1e5.toInt(); // variable to store the curr
    for (var pair in pairs) { // loop for pair
      if (curr < pair[0]) { // if curr is less than pair[0]
        ans++; // increment the ans
        curr = pair[1]; // update the curr
      }
    }
    return ans; // return the ans
  }
}

403. Frog Jump in c++

// Time Complexity : O(n^2) where n is the size of the vector nums and space complexity is O(n^2)

class Solution {
public:
    bool canCross(vector<int>& stones) { // function to check whether the frog can cross the river or not
        int n=stones.size(); // variable to store the size of the stones
        unordered_map<int,unordered_set<int>>mp; // unordered_map to store the int and unordered_set
        for(auto x:stones)mp[x]; // loop for x
        mp[0].insert(0); // insert the 0
        for(auto x:stones){ // loop for x
            for(auto y:mp[x]){ // loop for y
                for(int k=y-1;k<=y+1;k++){ // loop until k is less than or equal to y+1
                    if(k>0)mp[x+k].insert(k); // if k is greater than 0 insert the k
                }
            }
        }
        return mp[stones[n-1]].size(); // return the mp[stones[n-1]].size()
    }
};

Approach 2: Dynamic Programming

// Time Complexity : O(n^2) where n is the size of the vector nums and space complexity is O(n^2)

class Solution {
public:
    bool canCross(vector<int>& stones) { // function to check whether the frog can cross the river or not
        int n=stones.size(); // variable to store the size of the stones
        vector<vector<bool>>dp(n,vector<bool>(n)); // vector to store the dp
        dp[0][1]=true; // update the dp[0][1]
        for(int i=1; i<n; i++) { // loop until i is less than n
            for(int j=0; j<i; j++) { // loop until j is less than i
                int diff=stones[i]-stones[j]; // variable to store the diff
                if(diff<n && dp[j][diff]) { // if diff is less than n and dp[j][diff] is true
                    dp[i][diff]=true; // update the dp[i][diff]
                    if(diff-1>=0)dp[i][diff-1]=true; // if diff-1 is greater than or equal to 0 update the dp[i][diff-1]
                    if(diff+1<n)dp[i][diff+1]=true; // if diff+1 is less than n update the dp[i][diff+1]
                    if(i==n-1)return true; // if i is equal to n-1 return true
                }
            }
        }
        return false; // return false
    }
};

403. Frog Jump in java

// Time Complexity : O(n^2) where n is the size of the vector nums and space complexity is O(n^2)

class Solution {
    public boolean canCross(int[] stones) { // function to check whether the frog can cross the river or not
        int n=stones.length; // variable to store the size of the stones
        HashMap<Integer,HashSet<Integer>>mp=new HashMap<>(); // HashMap to store the int and HashSet
        for(int x:stones)mp.put(x,new HashSet<>()); // loop for x
        mp.get(0).add(0); // insert the 0
        for(int x:stones){ // loop for x
            for(int y:mp.get(x)){ // loop for y
                for(int k=y-1;k<=y+1;k++){ // loop until k is less than or equal to y+1
                    if(k>0)mp.get(x+k).add(k); // if k is greater than 0 insert the k
                }
            }
        }
        return mp.get(stones[n-1]).size()>0; // return the mp.get(stones[n-1]).size()>0
    }
};

Approach 2: Dynamic Programming

// Time Complexity : O(n^2) where n is the size of the vector nums and space complexity is O(n^2)

class Solution {
    public boolean canCross(int[] stones) { // function to check whether the frog can cross the river or not
        int n=stones.length; // variable to store the size of the stones
        boolean[][]dp=new boolean[n][n]; // boolean to store the dp
        dp[0][1]=true; // update the dp[0][1]
        for(int i=1; i<n; i++) { // loop until i is less than n
            for(int j=0; j<i; j++) { // loop until j is less than i
                int diff=stones[i]-stones[j]; // variable to store the diff
                if(diff<n && dp[j][diff]) { // if diff is less than n and dp[j][diff] is true
                    dp[i][diff]=true; // update the dp[i][diff]
                    if(diff-1>=0)dp[i][diff-1]=true; // if diff-1 is greater than or equal to 0 update the dp[i][diff-1]
                    if(diff+1<n)dp[i][diff+1]=true; // if diff+1 is less than n update the dp[i][diff+1]
                    if(i==n-1)return true; // if i is equal to n-1 return true
                }
            }
        }
        return false; // return false
    }
};

403. Frog Jump in python

// Time Complexity : O(n^2) where n is the size of the vector nums and space complexity is O(n^2)

class Solution(object):
    def canCross(self, stones): # function to check whether the frog can cross the river or not
        """
        :type stones: List[int]
        :rtype: bool
        """
        n=len(stones) # variable to store the size of the stones
        mp={x:set() for x in stones} # HashMap to store the int and HashSet
        mp[0].add(0) # insert the 0
        for x in stones: # loop for x
            for y in mp[x]: # loop for y
                for k in range(y-1,y+2): # loop until k is less than or equal to y+1
                    if k > 0 and x + k in mp:  # if k is greater than 0 insert the k
                        mp[x+k].add(k) # insert the k
        return len(mp[stones[-1]]) > 0 # return the len(mp[stones[-1]]) > 0

Approach 2: Dynamic Programming

// Time Complexity : O(n^2) where n is the size of the vector nums and space complexity is O(n^2)

class Solution(object):
    def canCross(self, stones): # function to check whether the frog can cross the river or not
        """
        :type stones: List[int]
        :rtype: bool
        """
        n=len(stones) # variable to store the size of the stones
       // dp=[[False]*n for _ in range(n)]  # boolean to store the dp
        dp[0][1]=True # update the dp[0][1]
        for i in range(1,n): # loop until i is less than n
            for j in range(i): # loop until j is less than i
                diff=stones[i]-stones[j] # variable to store the diff
                if diff<n and dp[j][diff]: # if diff is less than n and dp[j][diff] is true
                    dp[i][diff]=True # update the dp[i][diff]
                    if diff-1>=0:dp[i][diff-1]=True # if diff-1 is greater than or equal to 0 update the dp[i][diff-1]
                    if diff+1<n:dp[i][diff+1]=True # if diff+1 is less than n update the dp[i][diff+1]
                    if i==n-1:return True # if i is equal to n-1 return true
        return False # return false

403. Frog Jump in python3

// Time Complexity : O(n^2) where n is the size of the vector nums and space complexity is O(n^2)

class Solution:
    def canCross(self, stones: List[int]) -> bool: # add bracket after List
        n=len(stones) # variable to store the size of the stones
        mp={x:set() for x in stones} # HashMap to store the int and HashSet
        mp[0].add(0) # insert the 0
        for x in stones: # loop for x
            for y in mp[x]: # loop for y
                for k in range(y-1,y+2): # loop until k is less than or equal to y+1
                    if k > 0 and x + k in mp:  # if k is greater than 0 insert the k
                        mp[x+k].add(k) # insert the k
        return len(mp[stones[-1]]) > 0 # return the len(mp[stones[-1]]) > 0

Approach 2: Dynamic Programming

// Time Complexity : O(n^2) where n is the size of the vector nums and space complexity is O(n^2)

class Solution:
    def canCross(self, stones: List[int]) -> bool: # add bracket after List
        n=len(stones) # variable to store the size of the stones
        //dp=[[False]*n for _ in range(n)]  # boolean to store the dp
        dp[0][1]=True # update the dp[0][1]
        for i in range(1,n): # loop until i is less than n
            for j in range(i): # loop until j is less than i
                diff=stones[i]-stones[j] # variable to store the diff
                if diff<n and dp[j][diff]: # if diff is less than n and dp[j][diff] is true
                    dp[i][diff]=True # update the dp[i][diff]
                    if diff-1>=0:dp[i][diff-1]=True # if diff-1 is greater than or equal to 0 update the dp[i][diff-1]
                    if diff+1<n:dp[i][diff+1]=True # if diff+1 is less than n update the dp[i][diff+1]
                    if i==n-1:return True # if i is equal to n-1 return true
        return False # return false

403. Frog Jump in c

// Time Complexity : O(n^2) where n is the size of the vector nums and space complexity is O(n^2)

bool canCross(int* stones, int stonesSize){
    int n=stonesSize; // variable to store the size of the stones
    bool dp[n][n]; // boolean to store the dp
    memset(dp,false,sizeof(dp)); // memset the dp
    dp[0][1]=true; // update the dp[0][1]
    for(int i=1; i<n; i++) { // loop until i is less than n
        for(int j=0; j<i; j++) { // loop until j is less than i
            int diff=stones[i]-stones[j]; // variable to store the diff
            if(diff<n && dp[j][diff]) { // if diff is less than n and dp[j][diff] is true
                dp[i][diff]=true; // update the dp[i][diff]
                if(diff-1>=0)dp[i][diff-1]=true; // if diff-1 is greater than or equal to 0 update the dp[i][diff-1]
                if(diff+1<n)dp[i][diff+1]=true; // if diff+1 is less than n update the dp[i][diff+1]
                if(i==n-1)return true; // if i is equal to n-1 return true
            }
        }
    }
    return false; // return false
}

403. Frog Jump in c#

// Time Complexity : O(n^2) where n is the size of the vector nums and space complexity is O(n^2)

public class Solution {
    public bool CanCross(int[] stones) { // function to check whether the frog can cross the river or not
        int n=stones.Length; // variable to store the size of the stones
        Dictionary<int,HashSet<int>>mp=new Dictionary<int,HashSet<int>>(); // HashMap to store the int and HashSet
        foreach(int x in stones)mp[x]=new HashSet<int>(); // loop for x
        mp[0].Add(0); // insert the 0
        foreach(int x in stones){ // loop for x
            foreach(int y in mp[x]){ // loop for y
                for(int k=y-1;k<=y+1;k++){ // loop until k is less than or equal to y+1
                    if(k>0)mp[x+k].Add(k); // if k is greater than 0 insert the k
                }
            }
        }
        return mp[stones[n-1]].Count>0; // return the mp[stones[n-1]].Count>0
    }
}

Approach 2: Dynamic Programming

// Time Complexity : O(n^2) where n is the size of the vector nums and space complexity is O(n^2)

public class Solution {
    public bool CanCross(int[] stones) { // function to check whether the frog can cross the river or not
        int n=stones.Length; // variable to store the size of the stones
        bool[][]dp=new bool[n][]; // boolean to store the dp
        for(int i=0;i<n;i++)dp[i]=new bool[n]; // loop for i
        dp[0][1]=true; // update the dp[0][1]
        for(int i=1; i<n; i++) { // loop until i is less than n
            for(int j=0; j<i; j++) { // loop until j is less than i
                int diff=stones[i]-stones[j]; // variable to store the diff
                if(diff<n && dp[j][diff]) { // if diff is less than n and dp[j][diff] is true
                    dp[i][diff]=true; // update the dp[i][diff]
                    if(diff-1>=0)dp[i][diff-1]=true; // if diff-1 is greater than or equal to 0 update the dp[i][diff-1]
                    if(diff+1<n)dp[i][diff+1]=true; // if diff+1 is less than n update the dp[i][diff+1]
                    if(i==n-1)return true; // if i is equal to n-1 return true
                }
            }
        }
        return false; // return false
    }
}

403. Frog Jump in javascript

// Time Complexity : O(n^2) where n is the size of the vector nums and space complexity is O(n^2)

var canCross = function(stones) {
    const n = stones.length; // variable to store the size of the stones
    const dp = Array.from({ length: n }, () => new Array(n).fill(false)); // boolean to store the dp
    dp[0][1] = true; // update the dp[0][1]
    for (let i = 1; i < n; i++) { // loop until i is less than n
        for (let j = 0; j < i; j++) { // loop until j is less than i
            const diff = stones[i] - stones[j]; // variable to store the diff
            if (diff < n && dp[j][diff]) { // if diff is less than n and dp[j][diff] is true
                dp[i][diff] = true; // update the dp[i][diff]
                if (diff - 1 >= 0) dp[i][diff - 1] = true; // if diff-1 is greater than or equal to 0 update the dp[i][diff-1]
                if (diff + 1 < n) dp[i][diff + 1] = true; // if diff+1 is less than n update the dp[i][diff+1]
                if (i === n - 1) return true; // if i is equal to n-1 return true
            }
        }
    }
    return false; // return false
};

403. Frog Jump in Swift

// Time Complexity : O(n^2) where n is the size of the vector nums and space complexity is O(n^2)

class Solution {
    func canCross(_ stones: [Int]) -> Bool { // function to check whether the frog can cross the river or not
        let n = stones.count // variable to store the size of the stones
        var dp = [[Bool]](repeating: [Bool](repeating: false, count: n), count: n) // boolean to store the dp
        dp[0][1] = true // update the dp[0][1]
        for i in 1..<n { // loop until i is less than n
            for j in 0..<i { // loop until j is less than i
                let diff = stones[i] - stones[j] // variable to store the diff
                if diff < n && dp[j][diff] { // if diff is less than n and dp[j][diff] is true
                    dp[i][diff] = true // update the dp[i][diff]
                    if diff - 1 >= 0 { dp[i][diff - 1] = true } // if diff-1 is greater than or equal to 0 update the dp[i][diff-1]
                    if diff + 1 < n { dp[i][diff + 1] = true } // if diff+1 is less than n update the dp[i][diff+1]
                    if i == n - 1 { return true } // if i is equal to n-1 return true
                }
            }
        }
        return false // return false
    }
}

403. Frog Jump in dart

// Time Complexity : O(n^2) where n is the size of the vector nums and space complexity is O(n^2)

class Solution {
  bool canCross(List<int> stones) { // function to check whether the frog can cross the river or not
    final n = stones.length; // variable to store the size of the stones
    final dp = List.generate(n, (_) => List<bool>.filled(n, false)); // boolean to store the dp
    dp[0][1] = true; // update the dp[0][1]
    for (var i = 1; i < n; i++) { // loop until i is less than n
      for (var j = 0; j < i; j++) { // loop until j is less than i
        final diff = stones[i] - stones[j]; // variable to store the diff
        if (diff < n && dp[j][diff]) { // if diff is less than n and dp[j][diff] is true
          dp[i][diff] = true; // update the dp[i][diff]
          if (diff - 1 >= 0) dp[i][diff - 1] = true; // if diff-1 is greater than or equal to 0 update the dp[i][diff-1]
          if (diff + 1 < n) dp[i][diff + 1] = true; // if diff+1 is less than n update the dp[i][diff+1]
          if (i == n - 1) return true; // if i is equal to n-1 return true
        }
      }
    }
    return false; // return false
  }
}

2483. Minimum Penalty for a Shop in c++

// Time Complexity : O(n) and space complexity is O(1)

class Solution {
public:
    int bestClosingTime(string customers) {
        int n=customers.size(); // variable to store the size of the customers
        int currPenality = 0; // variable to store the currPenality
        int minPenality = 0; // variable to store the minPenality
        int earliestHour = 0; // variable to store the earliestHour
        for(int i=0;i<n;i++){ // loop until i is less than n
            if(customers[i]=='N'){ // if customers[i] is equal to 'N'
                currPenality++; // increment the currPenality
            }
            else{ // else
                currPenality--; // decrement the currPenality
            }
            if(currPenality<minPenality){ // if currPenality is less than minPenality
                minPenality=currPenality; // update the minPenality
                earliestHour=i+1; // update the earliestHour
            }
        }
        return earliestHour; // return the earliestHour
    }
};

2483. Minimum Penalty for a Shop in java

// Time Complexity : O(n) and space complexity is O(1)

class Solution {
    public int bestClosingTime(String customers) {
        int n=customers.length(); // variable to store the size of the customers
        int currPenality = 0; // variable to store the currPenality
        int minPenality = 0; // variable to store the minPenality
        int earliestHour = 0; // variable to store the earliestHour
        for(int i=0;i<n;i++){ // loop until i is less than n
            if(customers.charAt(i)=='N'){ // if customers.charAt(i) is equal to 'N'
                currPenality++; // increment the currPenality
            }
            else{ // else
                currPenality--; // decrement the currPenality
            }
            if(currPenality<minPenality){ // if currPenality is less than minPenality
                minPenality=currPenality; // update the minPenality
                earliestHour=i+1; // update the earliestHour
            }
        }
        return earliestHour; // return the earliestHour
    }
}

2483. Minimum Penalty for a Shop in Python

// Time Complexity : O(n) and space complexity is O(1)

class Solution(object):
    def bestClosingTime(self, customers): 
        """
        :type customers: str
        :rtype: int
        """
        n=len(customers) # variable to store the size of the customers
        currPenality = 0 # variable to store the currPenality
        minPenality = 0 # variable to store the minPenality
        earliestHour = 0 # variable to store the earliestHour
        for i in range(n): # loop until i is less than n
            if customers[i]=='N': # if customers[i] is equal to 'N'
                currPenality+=1 # increment the currPenality
            else: # else
                currPenality-=1 # decrement the currPenality
            if currPenality<minPenality: # if currPenality is less than minPenality
                minPenality=currPenality # update the minPenality
                earliestHour=i+1 # update the earliestHour
        return earliestHour # return the earliestHour
        
2483. Minimum Penalty for a Shop in Python3 

// Time Complexity : O(n) and space complexity is O(1)

class Solution:
    def bestClosingTime(self, customers: str) -> int:
        n=len(customers) # variable to store the size of the customers
        currPenality = 0 # variable to store the currPenality
        minPenality = 0 # variable to store the minPenality
        earliestHour = 0 # variable to store the earliestHour
        for i in range(n): # loop until i is less than n
            if customers[i]=='N': # if customers[i] is equal to 'N'
                currPenality+=1 # increment the currPenality
            else: # else
                currPenality-=1 # decrement the currPenality
            if currPenality<minPenality: # if currPenality is less than minPenality
                minPenality=currPenality # update the minPenality
                earliestHour=i+1 # update the earliestHour
        return earliestHour # return the earliestHour

2483. Minimum Penalty for a Shop in c

// Time Complexity : O(n) and space complexity is O(1)

int bestClosingTime(char* customers)
{
    int n=strlen(customers); // variable to store the size of the customers
    int currPenality = 0; // variable to store the currPenality
    int minPenality = 0; // variable to store the minPenality
    int earliestHour = 0; // variable to store the earliestHour
    for(int i=0;i<n;i++){ // loop until i is less than n
        if(customers[i]=='N'){ // if customers[i] is equal to 'N'
            currPenality++; // increment the currPenality
        }
        else{ // else
            currPenality--; // decrement the currPenality
        }
        if(currPenality<minPenality){ // if currPenality is less than minPenality
            minPenality=currPenality; // update the minPenality
            earliestHour=i+1; // update the earliestHour
        }
    }
    return earliestHour; // return the earliestHour
}

2483. Minimum Penalty for a Shop in c#

// Time Complexity : O(n) and space complexity is O(1)

public class Solution
{
public
    int BestClosingTime(string customers)
    {
        int n=customers.Length; // variable to store the size of the customers
        int currPenality = 0; // variable to store the currPenality
        int minPenality = 0; // variable to store the minPenality
        int earliestHour = 0; // variable to store the earliestHour
        for(int i=0;i<n;i++){ // loop until i is less than n
            if(customers[i]=='N'){ // if customers[i] is equal to 'N'
                currPenality++; // increment the currPenality
            }
            else{ // else
                currPenality--; // decrement the currPenality
            }
            if(currPenality<minPenality){ // if currPenality is less than minPenality
                minPenality=currPenality; // update the minPenality
                earliestHour=i+1; // update the earliestHour
            }
        }
        return earliestHour; // return the earliestHour
    }
}

2483. Minimum Penalty for a Shop in javascript

// Time Complexity : O(n) and space complexity is O(1)

var bestClosingTime = function(customers)
{
    const n = customers.length; // variable to store the size of the customers
    let currPenality = 0; // variable to store the currPenality
    let minPenality = 0; // variable to store the minPenality
    let earliestHour = 0; // variable to store the earliestHour
    for (let i = 0; i < n; i++) { // loop until i is less than n
        if (customers[i] == 'N'){ // if customers[i] is equal to 'N'
            currPenality++; // increment the currPenality
        }
        else
        {                   // else
            currPenality--; // decrement the currPenality
        }
        if (currPenality < minPenality) { // if currPenality is less than minPenality
            minPenality = currPenality; // update the minPenality
            earliestHour = i + 1; // update the earliestHour
        }
    }
    return earliestHour; // return the earliestHour
};

2483. Minimum Penalty for a Shop in Swift

// Time Complexity : O(n) and space complexity is O(1)

class Solution {
    func bestClosingTime(_ customers: String) -> Int {
        let n = customers.count // variable to store the size of the customers
        var currPenality = 0 // variable to store the currPenality
        var minPenality = 0 // variable to store the minPenality
        var earliestHour = 0 // variable to store the earliestHour
        for(i , customer) in customers.enumerated() { // loop until i is less than n
            if customer == "N" { // if customer is equal to "N"
                currPenality += 1 // increment the currPenality
            } else { // else
                currPenality -= 1 // decrement the currPenality
            }
            if currPenality < minPenality { // if currPenality is less than minPenality
                minPenality = currPenality // update the minPenality
                earliestHour = i + 1 // update the earliestHour
            }
        }
        return earliestHour // return the earliestHour
    }
}

2483. Minimum Penalty for a Shop in dart

// Time Complexity : O(n) and space complexity is O(1)

class Solution {
    int bestClosingTime(String customers) {
        int n=customers.length; // variable to store the size of the customers
        int currPenality = 0; // variable to store the currPenality
        int minPenality = 0; // variable to store the minPenality
        int earliestHour = 0; // variable to store the earliestHour
        for(int i=0;i<n;i++){ // loop until i is less than n
            if(customers[i]=='N'){ // if customers[i] is equal to 'N'
                currPenality++; // increment the currPenality
            }
            else{ // else
                currPenality--; // decrement the currPenality
            }
            if(currPenality<minPenality){ // if currPenality is less than minPenality
                minPenality=currPenality; // update the minPenality
                earliestHour=i+1; // update the earliestHour
            }
        }
        return earliestHour; // return the earliestHour
    }
}

2498. Frog Jump II in c++

// Time Complexity : O(n) and space complexity is O(1)

class Solution {
public:
    int maxJump(vector<int>& stones) {
        int n = stones.size(); // variable to store the size of the stones
        int res = stones[1] - stones[0]; // variable to store the res
        for (int i = 2; i < n; i++) { // loop until i is less than n
            res = max(res, stones[i] - stones[i - 2]); // update the res
        }
        return res; // return the res
    }
};

2498. Frog Jump II in java

// Time Complexity : O(n) and space complexity is O(1)

class Solution {
    public int maxJump(int[] stones) {
        int n = stones.length; // variable to store the size of the stones
        int res = stones[1] - stones[0]; // variable to store the res
        for (int i = 2; i < n; i++) { // loop until i is less than n
            res = Math.max(res, stones[i] - stones[i - 2]); // update the res
        }
        return res; // return the res
    }
}

2498. Frog Jump II in Python

// Time Complexity : O(n) and space complexity is O(1)

class Solution(object):
    def maxJump(self, stones):
        """
        :type stones: List[int]
        :rtype: int
        """
        n=len(stones) # variable to store the size of the stones
        res = stones[1] - stones[0] # variable to store the res
        for i in range(2,n): # loop until i is less than n
            res = max(res, stones[i] - stones[i - 2]) # update the res
        return res # return the res

2498. Frog Jump II in Python3

// Time Complexity : O(n) and space complexity is O(1)

class Solution:
    def maxJump(self, stones: List[int]) -> int:
        n=len(stones) # variable to store the size of the stones
        res = stones[1] - stones[0] # variable to store the res
        for i in range(2,n): # loop until i is less than n
            res = max(res, stones[i] - stones[i - 2]) # update the res
        return res # return the res

2498. Frog Jump II in c

// Time Complexity : O(n) and space complexity is O(1)
#include <math.h> // For fmax function

// Custom max function for integers
int max_int(int a, int b) {
    return a > b ? a : b;
}

int maxJump(int* stones, int stonesSize) {
    int n = stonesSize;
    int res = stones[1] - stones[0];
    for (int i = 2; i < n; i++) {
        // Using fmax function for floating-point values
        // res = fmax(res, stones[i] - stones[i - 2]);
        
        // Using custom max function for integers
        res = max_int(res, stones[i] - stones[i - 2]);
    }
    return res;
}


2498. Frog Jump II in c#

// Time Complexity : O(n) and space complexity is O(1)

public class Solution
{
public
    int MaxJump(int[] stones)
    {
        int n=stones.Length; // variable to store the size of the stones
        int res = stones[1] - stones[0]; // variable to store the res
        for (int i = 2; i < n; i++) { // loop until i is less than n
            res = Math.Max(res, stones[i] - stones[i - 2]); // update the res
        }
        return res; // return the res
    }
}

2498. Frog Jump II in javascript

// Time Complexity : O(n) and space complexity is O(1)

var maxJump = function(stones) {
    const n = stones.length; // variable to store the size of the stones
    let res = stones[1] - stones[0]; // variable to store the res
    for (let i = 2; i < n; i++) { // loop until i is less than n
        res = Math.max(res, stones[i] - stones[i - 2]); // update the res
    }
    return res; // return the res
};

2498. Frog Jump II in Swift

// Time Complexity : O(n) and space complexity is O(1)

class Solution {
    func maxJump(_ stones: [Int]) -> Int {
        let n = stones.count // variable to store the size of the stones
        var res = stones[1] - stones[0] // variable to store the res
        for i in 2..<n { // loop until i is less than n
            res = max(res, stones[i] - stones[i - 2]) // update the res
        }
        return res // return the res
    }
}

2498. Frog Jump II in dart

// Time Complexity : O(n) and space complexity is O(1)

class Solution {
    int maxJump(List<int> stones) {
        int n=stones.length; // variable to store the size of the stones
        int res = stones[1] - stones[0]; // variable to store the res
        for (int i = 2; i < n; i++) { // loop until i is less than n
            res = max(res, stones[i] - stones[i - 2]); // update the res
        }
        return res; // return the res
    }
}

338. Counting Bits in c++

// Time Complexity : O(n) and space complexity is O(n)

class Solution {
public:
    vector<int> countBits(int n) {
        vector<int>dp(n+1); // vector to store the dp
        dp[0]=0; // update the dp[0]
        for(int i=1;i<=n;i++){ // loop until i is less than or equal to n
            dp[i]=dp[i/2]+i%2; // update the dp[i]
            // or
            // dp[i]=dp[i>>1]+i&1; // update the dp[i]
        }
        return dp; // return the dp
    }
};

338. Counting Bits in java

// Time Complexity : O(n) and space complexity is O(n)

class Solution {
    public int[] countBits(int n) {
        int[]dp=new int[n+1]; // array to store the dp
        dp[0]=0; // update the dp[0]
        for(int i=1;i<=n;i++){ // loop until i is less than or equal to n
            dp[i]=dp[i/2]+i%2; // update the dp[i]
            // or
            // dp[i]=dp[i>>1]+i&1; // update the dp[i]
        }
        return dp; // return the dp
    }
}

338. Counting Bits in Python

// Time Complexity : O(n) and space complexity is O(n)

class Solution(object):
    def countBits(self, n):
        """
        :type n: int
        :rtype: List[int]
        """
        dp=[0]*(n+1) # array to store the dp
        dp[0]=0 # update the dp[0]
        for i in range(1,n+1): # loop until i is less than or equal to n
            dp[i]=dp[i>>1]+i&1 # update the dp[i]
        return dp # return the dp

338. Counting Bits in Python3

// Time Complexity : O(n) and space complexity is O(n)

class Solution:
    def countBits(self, n: int) -> List[int]:
        dp=[0]*(n+1) # array to store the dp
        dp[0]=0 # update the dp[0]
        for i in range(1,n+1): # loop until i is less than or equal to n
            dp[i]=dp[i>>1]+i&1 # update the dp[i]
        return dp # return the dp

338. Counting Bits in c

// Time Complexity : O(n) and space complexity is O(n)

int* countBits(int n, int* returnSize){
    int* dp=(int*)malloc(sizeof(int)*(n+1)); // array to store the dp
    dp[0]=0; // update the dp[0]
    for(int i=1;i<=n;i++){ // loop until i is less than or equal to n
        dp[i] = dp[i/2] + (i%2) // update the dp[i]
    }
    *returnSize=n+1; // update the returnSize
    return dp; // return the dp
}

338. Counting Bits in c#

// Time Complexity : O(n) and space complexity is O(n)

public class Solution
{
public int[] CountBits(int n)
    {
        int[] dp=new int[n+1]; // array to store the dp
        dp[0]=0; // update the dp[0]
        for(int i=1;i<=n;i++){ // loop until i is less than or equal to n
            dp[i]=dp[i/2]+i%2;; // update the dp[i]
        }
        return dp; // return the dp
    }
}

338. Counting Bits in javascript

// Time Complexity : O(n) and space complexity is O(n)

var countBits = function(n) {
    let dp=new Array(n+1); // array to store the dp
    dp[0]=0; // update the dp[0]
    for(let i=1;i<=n;i++){ // loop until i is less than or equal to n
        dp[i]=dp[i>>1]+(i&1); // update the dp[i]
    }
    return dp; // return the dp
};

338. Counting Bits in Swift

// Time Complexity : O(n) and space complexity is O(n)

class Solution {
    func countBits(_ n: Int) -> [Int] {
        var dp=[Int](repeating: 0, count: n+1) // array to store the dp
        dp[0]=0 // update the dp[0]
        for i in stride (from: 1, through: n, by: 1) { // loop until i is less than or equal to n
            dp[i]=dp[i>>1]+i&1 // update the dp[i]
        }
        return dp // return the dp
    }
}

338. Counting Bits in dart

// Time Complexity : O(n) and space complexity is O(n)

class Solution {
    List<int> countBits(int n) {
        List<int> dp=new List<int>.filled(n+1,0); // array to store the dp
        dp[0]=0; // update the dp[0]
        for(int i=1;i<=n;i++){ // loop until i is less than or equal to n
            dp[i]=dp[i>>1]+(i&1); // update the dp[i]
        }
        return dp; // return the dp
    }
}

1326. Minimum Number of Taps to Open to Water a Garden

// 45.) Jump Game II and  1024.) Video Stitching is same as this problem and greedy approach is used in this problem

Approach 1: Dynamic Programming

// Time Complexity : O(n*m) and space complexity is O(n)

class Solution {
public:
    int minTaps(int n, vector<int>& ranges) {
        vector<int> dp(n + 1, n + 2); // vector to store the dp By initializing dp with n+2, you can easily check if it's possible to cover all areas or not. If any element of dp remains n+2 after the DP process, it implies that there is no solution, and the function returns -1. Otherwise, it returns the minimum number of taps needed, which is stored in the dp[n] element.
        dp[0]=0; // update the dp[0]
        for(int i=0;i<=n;i++){ // loop until i is less than or equal to n
            for(int j=max(0,i-ranges[i]+1);j<=min(n,i+ranges[i]);j++){ // loop until j is less than or equal to min(n,i+ranges[i]) &&  This is an inner loop that iterates from j, which is the leftmost area that the current tap can cover, to the rightmost area it can cover. The max(0, i - ranges[i] + 1) expression calculates the leftmost area that can be covered by the current tap without going out of bounds, and min(n, i + ranges[i]) calculates the rightmost area it can cover without exceeding n.
                dp[j] = min(dp[j], dp[max(0, i - ranges[i])] + 1);     // update the dp[j] && In this line, the DP value for area j is updated. The new value is calculated as the minimum of its current value dp[j] and the value of dp at the leftmost area that can cover this area, plus 1. This step is essential for dynamic programming as it considers whether it's better to turn on a new tap or extend the coverage of an existing tap.
            }
        }
        return dp[n] < n + 2 ? dp[n] : -1; // return the dp[n]<n+2?dp[n]:-1  Finally, after all iterations are completed, the function checks if the DP value at the last area n is less than n+2. If it is, it means that it's possible to cover all areas, so the function returns dp[n], which represents the minimum number of taps needed. If dp[n] is still n+2, it means that it's not possible to cover all areas, so the function returns -1.
    }
};

// Approach 2: Greedy

// Time Complexity : O(n) and space complexity is O(n)

class Solution {
public:
    int minTaps(int n, vector<int>& ranges) {
        vector<int>dp(n+1); // vector to store the dp
        for(int i=0;i<ranges.size();i++){ // loop until i is less than ranges.size()
        // Inside the loop, it calculates two values left and right representing the leftmost and rightmost areas that the current tap can cover. The max(0, i - ranges[i]) calculation ensures that left doesn't go below 0, and the min(n, i + ranges[i]) calculation ensures that right doesn't go beyond n.
            int left=max(0,i-ranges[i]); // variable to store the left  
            int right=min(n,i+ranges[i]); // variable to store the right
            dp[left]=max(dp[left],right); // update the dp[left]
            // This line updates the DP value at the left position in the dp vector.It ensures that the DP value at left contains the maximum rightmost position that can be covered by taps that have coverage extending to the left of this point.
        }
        int taps = 0; // variable to store the taps
        int farthest = 0; // variable to store the farthest
        int currEnd = 0; // variable to store the currEnd
        for(int i=0;i<=n;i++){ // loop until i is less than or equal to n
            if(i > farthest) return -1; // if i is greater than farthest return -1
            if(i > currEnd){ // if i is equal to currEnd
                taps++; // increment the taps
                currEnd=farthest; // update the currEnd
            }
            farthest = max(farthest, dp[i]); // update the farthest
            // In each iteration, farthest is updated to be the maximum of its current value and the rightmost coverage provided by the tap that covers or extends to the current area i.
        }
        return taps; // return the taps
    }
};

1326. Minimum Number of Taps to Open to Water a Garden in java

Approach 1: Dynamic Programming

// Time Complexity : O(n*m) and space complexity is O(n)

class Solution {
    public int minTaps(int n, int[] ranges) {
        int[]dp=new int[n+1]; // array to store the dp
        Arrays.fill(dp,n+2); // fill the dp with n+2
        dp[0]=0; // update the dp[0]
        for(int i=0;i<=n;i++){ // loop until i is less than or equal to n
            for(int j=Math.max(0,i-ranges[i]+1);j<=Math.min(n,i+ranges[i]);j++){ // loop until j is less than or equal to min(n,i+ranges[i])
                dp[j]=Math.min(dp[j],dp[Math.max(0,i-ranges[i])]+1); // update the dp[j]
            }
        }
        return dp[n]<n+2?dp[n]:-1; // return the dp[n]<n+2?dp[n]:-1
    }
}

Approach 2: Greedy

// Time Complexity : O(n) and space complexity is O(n)

class Solution {
    public int minTaps(int n, int[] ranges) {
        int[]dp=new int[n+1]; // array to store the dp
        for(int i=0;i<ranges.length;i++){ // loop until i is less than ranges.length
            int left=Math.max(0,i-ranges[i]); // variable to store the left
            int right=Math.min(n,i+ranges[i]); // variable to store the right
            dp[left]=Math.max(dp[left],right); // update the dp[left]
        }
        int taps = 0; // variable to store the taps
        int farthest = 0; // variable to store the farthest
        int currEnd = 0; // variable to store the currEnd
        for(int i=0;i<=n;i++){ // loop until i is less than or equal to n
            if(i > farthest) return -1; // if i is greater than farthest return -1
            if(i > currEnd){ // if i is equal to currEnd
                taps++; // increment the taps
                currEnd=farthest; // update the currEnd
            }
            farthest = Math.max(farthest, dp[i]); // update the farthest
        }
        return taps; // return the taps
    }
}

1326. Minimum Number of Taps to Open to Water a Garden in Python

Approach 1: Dynamic Programming

// Time Complexity : O(n*m) and space complexity is O(n)

class Solution(object):
    def minTaps(self, n, ranges):
        """
        :type n: int
        :type ranges: List[int]
        :rtype: int
        """
        dp=[n+2]*(n+1) # array to store the dp
        dp[0]=0 # update the dp[0]
        for i in range(n+1): # loop until i is less than or equal to n
            for j in range(max(0,i-ranges[i]+1),min(n,i+ranges[i])+1): # loop until j is less than or equal to min(n,i+ranges[i])
                dp[j]=min(dp[j],dp[max(0,i-ranges[i])]+1) # update the dp[j]
        return dp[n] if dp[n]<n+2 else -1 # return the dp[n] if dp[n]<n+2 else -1

Approach 2: Greedy

// Time Complexity : O(n) and space complexity is O(n)

class Solution(object):
    def minTaps(self, n, ranges):
        """
        :type n: int
        :type ranges: List[int]
        :rtype: int
        """
        dp=[0]*(n+1) # array to store the dp
        for i in range(len(ranges)): # loop until i is less than len(ranges)
            left=max(0,i-ranges[i]) # variable to store the left
            right=min(n,i+ranges[i]) # variable to store the right
            dp[left]=max(dp[left],right) # update the dp[left]
        taps = 0 # variable to store the taps
        farthest = 0 # variable to store the farthest
        currEnd = 0 # variable to store the currEnd
        for i in range(n+1): # loop until i is less than or equal to n
            if i > farthest: return -1 # if i is greater than farthest return -1
            if i > currEnd: # if i is equal to currEnd
                taps += 1 # increment the taps
                currEnd = farthest # update the currEnd
            farthest = max(farthest, dp[i]) # update the farthest
        return taps # return the taps

1326. Minimum Number of Taps to Open to Water a Garden in Python3

Approach 1: Dynamic Programming

// Time Complexity : O(n*m) and space complexity is O(n)

class Solution:
    def minTaps(self, n: int, ranges: List[int) -> int:  // add the bracket after the List[int]
        dp=[n+2]*(n+1) # array to store the dp
        dp[0]=0 # update the dp[0]
        for i in range(n+1): # loop until i is less than or equal to n
            for j in range(max(0,i-ranges[i]+1),min(n,i+ranges[i])+1): # loop until j is less than or equal to min(n,i+ranges[i])
                dp[j]=min(dp[j],dp[max(0,i-ranges[i])]+1) # update the dp[j]
        return dp[n] if dp[n]<n+2 else -1 # return the dp[n] if dp[n]<n+2 else -1

Approach 2: Greedy

// Time Complexity : O(n) and space complexity is O(n)

class Solution:
    def minTaps(self, n: int, ranges: List[int) -> int: // add the bracket after the List[int]
        dp=[0]*(n+1) # array to store the dp
        for i in range(len(ranges)): # loop until i is less than len(ranges)
            left=max(0,i-ranges[i]) # variable to store the left
            right=min(n,i+ranges[i]) # variable to store the right
            dp[left]=max(dp[left],right) # update the dp[left]
        taps = 0 # variable to store the taps
        farthest = 0 # variable to store the farthest
        currEnd = 0 # variable to store the currEnd
        for i in range(n+1): # loop until i is less than or equal to n
            if i > farthest: return -1 # if i is greater than farthest return -1
            if i > currEnd: # if i is equal to currEnd
                taps += 1 # increment the taps
                currEnd = farthest # update the currEnd
            farthest = max(farthest, dp[i]) # update the farthest
        return taps # return the taps

1326. Minimum Number of Taps to Open to Water a Garden in c

Approach 1: Dynamic Programming

// Time Complexity : O(n*m) and space complexity is O(n)

int minTaps(int n, int* ranges, int rangesSize){
    int* dp=(int*)malloc(sizeof(int)*(n+1)); // array to store the dp
    for(int i=0;i<=n;i++)dp[i]=n+2; // loop until i is less than or equal to n
    dp[0]=0; // update the dp[0]
    for(int i=0;i<=n;i++){ // loop until i is less than or equal to n
        for(int j=fmax(0,i-ranges[i]+1);j<=fmin(n,i+ranges[i]);j++){ // loop until j is less than or equal to min(n,i+ranges[i])
            dp[j]=fmin(dp[j],dp[fmax(0,i-ranges[i])]+1); // update the dp[j]
        }
    }
    return dp[n]<n+2?dp[n]:-1; // return the dp[n]<n+2?dp[n]:-1
}

Approach 2: Greedy

// Time Complexity : O(n) and space complexity is O(n)

int minTaps(int n, int* ranges, int rangesSize){
    int* dp=(int*)malloc(sizeof(int)*(n+1)); // array to store the dp
    for(int i=0;i<=n;i++)dp[i]=0; // loop until i is less than or equal to n
    for(int i=0;i<rangesSize;i++){ // loop until i is less than rangesSize
        int left=fmax(0,i-ranges[i]); // variable to store the left
        int right=fmin(n,i+ranges[i]); // variable to store the right
        dp[left]=fmax(dp[left],right); // update the dp[left]
    }
    int taps = 0; // variable to store the taps
    int farthest = 0; // variable to store the farthest
    int currEnd = 0; // variable to store the currEnd
    for(int i=0;i<=n;i++){ // loop until i is less than or equal to n
        if(i > farthest) return -1; // if i is greater than farthest return -1
        if(i > currEnd){ // if i is equal to currEnd
            taps++; // increment the taps
            currEnd = farthest; // update the currEnd
        }
        farthest = fmax(farthest, dp[i]); // update the farthest
    }
    return taps; // return the taps
}

1326. Minimum Number of Taps to Open to Water a Garden in c#

Approach 1: Dynamic Programming

// Time Complexity : O(n*m) and space complexity is O(n)

public class Solution {
    public int MinTaps(int n, int[] ranges) {
        int[]dp=new int[n+1]; // array to store the dp
        Array.Fill(dp,n+2); // fill the dp with n+2
        dp[0]=0; // update the dp[0]
        for(int i=0;i<=n;i++){ // loop until i is less than or equal to n
            for(int j=Math.Max(0,i-ranges[i]+1);j<=Math.Min(n,i+ranges[i]);j++){ // loop until j is less than or equal to min(n,i+ranges[i])
                dp[j]=Math.Min(dp[j],dp[Math.Max(0,i-ranges[i])]+1); // update the dp[j]
            }
        }
        return dp[n]<n+2?dp[n]:-1; // return the dp[n]<n+2?dp[n]:-1
    }
}

Approach 2: Greedy

// Time Complexity : O(n) and space complexity is O(n)

public class Solution {
    public int MinTaps(int n, int[] ranges) {
        int[]dp=new int[n+1]; // array to store the dp
        for(int i=0;i<ranges.Length;i++){ // loop until i is less than ranges.Length
            int left=Math.Max(0,i-ranges[i]); // variable to store the left
            int right=Math.Min(n,i+ranges[i]); // variable to store the right
            dp[left]=Math.Max(dp[left],right); // update the dp[left]
        }
        int taps = 0; // variable to store the taps
        int farthest = 0; // variable to store the farthest
        int currEnd = 0; // variable to store the currEnd
        for(int i=0;i<=n;i++){ // loop until i is less than or equal to n
            if(i > farthest) return -1; // if i is greater than farthest return -1
            if(i > currEnd){ // if i is equal to currEnd
                taps++; // increment the taps
                currEnd = farthest; // update the currEnd
            }
            farthest = Math.Max(farthest, dp[i]); // update the farthest
        }
        return taps; // return the taps
    }
}

1326. Minimum Number of Taps to Open to Water a Garden in javascript

Approach 1: Dynamic Programming

// Time Complexity : O(n*m) and space complexity is O(n)

var minTaps = function(n, ranges) {
    let dp=new Array(n+1); // array to store the dp
    dp.fill(n+2); // fill the dp with n+2
    dp[0]=0; // update the dp[0]
    for(let i=0;i<=n;i++){ // loop until i is less than or equal to n
        for(let j=Math.max(0,i-ranges[i]+1);j<=Math.min(n,i+ranges[i]);j++){ // loop until j is less than or equal to min(n,i+ranges[i])
            dp[j]=Math.min(dp[j],dp[Math.max(0,i-ranges[i])]+1); // update the dp[j]
        }
    }
    return dp[n]<n+2?dp[n]:-1; // return the dp[n]<n+2?dp[n]:-1
};

Approach 2: Greedy

// Time Complexity : O(n) and space complexity is O(n)

var minTaps = function(n, ranges) {
    let dp=new Array(n+1); // array to store the dp
    dp.fill(0); // fill the dp with 0
    for(let i=0;i<ranges.length;i++){ // loop until i is less than ranges.length
        let left=Math.max(0,i-ranges[i]); // variable to store the left
        let right=Math.min(n,i+ranges[i]); // variable to store the right
        dp[left]=Math.max(dp[left],right); // update the dp[left]
    }
    let taps = 0; // variable to store the taps
    let farthest = 0; // variable to store the farthest
    let currEnd = 0; // variable to store the currEnd
    for(let i=0;i<=n;i++){ // loop until i is less than or equal to n
        if(i > farthest) return -1; // if i is greater than farthest return -1
        if(i > currEnd){ // if i is equal to currEnd
            taps++; // increment the taps
            currEnd = farthest; // update the currEnd
        }
        farthest = Math.max(farthest, dp[i]); // update the farthest
    }
    return taps; // return the taps
};

1326. Minimum Number of Taps to Open to Water a Garden in Swift

Approach 1: Dynamic Programming

// Time Complexity : O(n*m) and space complexity is O(n)

class Solution {
    func minTaps(_ n: Int, _ ranges: [Int]) -> Int {
        var dp=[Int](repeating: n+2, count: n+1) // array to store the dp
        dp[0]=0 // update the dp[0]
        for i in 0...n { // loop until i is less than or equal to n
            for j in max(0,i-ranges[i]+1)...min(n,i+ranges[i]) { // loop until j is less than or equal to min(n,i+ranges[i])
                dp[j]=min(dp[j],dp[max(0,i-ranges[i])]+1) // update the dp[j]
            }
        }
        return dp[n]<n+2 ? dp[n] : -1 // return the dp[n]<n+2 ? dp[n] : -1
    }
}

Approach 2: Greedy

// Time Complexity : O(n) and space complexity is O(n)

class Solution {
    func minTaps(_ n: Int, _ ranges: [Int]) -> Int {
        var dp=[Int](repeating: 0, count: n+1) // array to store the dp
        for i in 0..<ranges.count { // loop until i is less than ranges.count
            let left=max(0,i-ranges[i]) // variable to store the left
            let right=min(n,i+ranges[i]) // variable to store the right
            dp[left]=max(dp[left],right) // update the dp[left]
        }
        var taps = 0 // variable to store the taps
        var farthest = 0 // variable to store the farthest
        var currEnd = 0 // variable to store the currEnd
        for i in 0...n { // loop until i is less than or equal to n
            if i > farthest { return -1 } // if i is greater than farthest return -1
            if i > currEnd { // if i is equal to currEnd
                taps += 1 // increment the taps
                currEnd = farthest // update the currEnd
            }
            farthest = max(farthest, dp[i]) // update the farthest
        }
        return taps // return the taps
    }
}

1326. Minimum Number of Taps to Open to Water a Garden in dart

Approach 1: Dynamic Programming

// Time Complexity : O(n*m) and space complexity is O(n)

class Solution {
    int minTaps(int n, int[] ranges) {
        int[]dp=new int[n+1]; // array to store the dp
        Arrays.fill(dp,n+2); // fill the dp with n+2
        dp[0]=0; // update the dp[0]
        for(int i=0;i<=n;i++){ // loop until i is less than or equal to n
            for(int j=Math.max(0,i-ranges[i]+1);j<=Math.min(n,i+ranges[i]);j++){ // loop until j is less than or equal to min(n,i+ranges[i])
                dp[j]=Math.min(dp[j],dp[Math.max(0,i-ranges[i])]+1); // update the dp[j]
            }
        }
        return dp[n]<n+2?dp[n]:-1; // return the dp[n]<n+2?dp[n]:-1
    }
}

Approach 2: Greedy

// Time Complexity : O(n) and space complexity is O(n)

class Solution {
  int minTaps(int n, List<int> ranges) {
    List<int> dp = new List<int>.filled(n + 1, 0); // array to store the dp
    for (int i = 0; i < ranges.length; i++) { // loop until i is less than ranges.length
      int left = max(0, i - ranges[i]); // variable to store the left
      int right = min(n, i + ranges[i]); // variable to store the right
      dp[left] = max(dp[left], right); // update the dp[left]
    }
    int taps = 0; // variable to store the taps
    int farthest = 0; // variable to store the farthest
    int currEnd = 0; // variable to store the currEnd
    for (int i = 0; i <= n; i++) { // loop until i is less than or equal to n
      if (i > farthest) return -1; // if i is greater than farthest return -1
      if (i > currEnd) { // if i is equal to currEnd
        taps++; // increment the taps
        currEnd = farthest; // update the currEnd
      }
      farthest = max(farthest, dp[i]); // update the farthest
    }
    return taps; // return the taps
  }
}

45. Jump Game II in c++

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size();  // variable to store the length of the vector nums
        int res = 0;  // variable to store the result
        int i = 0;  // variable to store the start index of the window
        int j = 0;  // variable to store the end index of the window
        while(j < n - 1){  // while the end index of the window is less than the length of the vector nums
            int maxIndex = j;  // variable to store the maximum index
            for(int k=i; k<=j; k++){  // for each element in the window
                maxIndex = max(maxIndex, k + nums[k]);  // update the maximum index 
            }
            i = j + 1;  // update the start index of the window
            j = maxIndex;  // update the end index of the window
            res++;  // increment the result
        }
        return res;  // return the result
    }
};

45. Jump Game II in Java

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
    public int jump(int[] nums) {
        int n = nums.length;  // variable to store the length of the vector nums
        int res = 0;  // variable to store the result
        int i = 0;  // variable to store the start index of the window
        int j = 0;  // variable to store the end index of the window
        while(j < n - 1){  // while the end index of the window is less than the length of the vector nums
            int maxIndex = j;  // variable to store the maximum index
            for(int k=i; k<=j; k++){  // for each element in the window
                maxIndex = Math.max(maxIndex, k + nums[k]);  // update the maximum index
            }
            i = j + 1;  // update the start index of the window
            j = maxIndex;  // update the end index of the window
            res++;  // increment the result
        }
        return res;  // return the result
    }
}

45. Jump Game II in Python

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution:
     def jump(self, nums):  # function to jump
        """
        :type nums: List[int]   
        :rtype: int
        """
        n = len(nums)  # variable to store the length of the vector nums
        res = 0  # variable to store the result
        i = 0  # variable to store the start index of the window
        j = 0  # variable to store the end index of the window
        while j < n - 1:  # while the end index of the window is less than the length of the vector nums
            maxIndex = j  # variable to store the maximum index
            for k in range(i, j + 1):  # for each element in the window
                maxIndex = max(maxIndex, k + nums[k])  # update the maximum index
            i = j + 1  # update the start index of the window
            j = maxIndex  # update the end index of the window
            res += 1  # increment the result
        return res  # return the result

45. Jump Game II in Python3

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution:
    def jump(self, nums: List[int]) -> int:  # function to jump
        n = len(nums)  # variable to store the length of the vector nums
        res = 0  # variable to store the result
        i = 0  # variable to store the start index of the window
        j = 0  # variable to store the end index of the window
        while j < n - 1:  # while the end index of the window is less than the length of the vector nums
            maxIndex = j  # variable to store the maximum index
            for k in range(i, j + 1):  # for each element in the window
                maxIndex = max(maxIndex, k + nums[k])  # update the maximum index
            i = j + 1  # update the start index of the window
            j = maxIndex  # update the end index of the window
            res += 1  # increment the result
        return res  # return the result

45. Jump Game II in c

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

int jump(int* nums, int numsSize){
    int n = numsSize;  // variable to store the length of the vector nums
    int res = 0;  // variable to store the result
    int i = 0;  // variable to store the start index of the window
    int j = 0;  // variable to store the end index of the window
    while(j < n - 1){  // while the end index of the window is less than the length of the vector nums
        int maxIndex = j;  // variable to store the maximum index
        for(int k=i; k<=j; k++){  // for each element in the window
            maxIndex = fmax(maxIndex, k + nums[k]);  // update the maximum index
        }
        i = j + 1;  // update the start index of the window
        j = maxIndex;  // update the end index of the window
        res++;  // increment the result
    }
    return res;  // return the result
}

45. Jump Game II in c#

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

public class Solution {
    public int Jump(int[] nums) {
        int n = nums.Length;  // variable to store the length of the vector nums
        int res = 0;  // variable to store the result
        int i = 0;  // variable to store the start index of the window
        int j = 0;  // variable to store the end index of the window
        while(j < n - 1){  // while the end index of the window is less than the length of the vector nums
            int maxIndex = j;  // variable to store the maximum index
            for(int k=i; k<=j; k++){  // for each element in the window
                maxIndex = Math.Max(maxIndex, k + nums[k]);  // update the maximum index
            }
            i = j + 1;  // update the start index of the window
            j = maxIndex;  // update the end index of the window
            res++;  // increment the result
        }
        return res;  // return the result
    }
}

45. Jump Game II in Javascript

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

var jump = function(nums) {
    let n = nums.length;  // variable to store the length of the vector nums
    let res = 0;  // variable to store the result
    let i = 0;  // variable to store the start index of the window
    let j = 0;  // variable to store the end index of the window
    while(j < n - 1){  // while the end index of the window is less than the length of the vector nums
        let maxIndex = j;  // variable to store the maximum index
        for(let k=i; k<=j; k++){  // for each element in the window
            maxIndex = Math.max(maxIndex, k + nums[k]);  // update the maximum index
        }
        i = j + 1;  // update the start index of the window
        j = maxIndex;  // update the end index of the window
        res++;  // increment the result
    }
    return res;  // return the result
};

45. Jump Game II in Swift

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
    func jump(_ nums: [Int]) -> Int {
        let n = nums.count  // variable to store the length of the vector nums
        var res = 0  // variable to store the result
        var i = 0  // variable to store the start index of the window
        var j = 0  // variable to store the end index of the window
        while j < n - 1 {  // while the end index of the window is less than the length of the vector nums
            var maxIndex = j  // variable to store the maximum index
            for k in i...j {  // for each element in the window
                maxIndex = max(maxIndex, k + nums[k])  // update the maximum index
            }
            i = j + 1  // update the start index of the window
            j = maxIndex  // update the end index of the window
            res += 1  // increment the result
        }
        return res  // return the result
    }
}

45. Jump Game II in Dart

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
    int jump(List<int> nums) {
        int n = nums.length;  // variable to store the length of the vector nums
        int res = 0;  // variable to store the result
        int i = 0;  // variable to store the start index of the window
        int j = 0;  // variable to store the end index of the window
        while(j < n - 1){  // while the end index of the window is less than the length of the vector nums
            int maxIndex = j;  // variable to store the maximum index
            for(int k=i; k<=j; k++){  // for each element in the window
                maxIndex = max(maxIndex, k + nums[k]);  // update the maximum index
            }
            i = j + 1;  // update the start index of the window
            j = maxIndex;  // update the end index of the window
            res++;  // increment the result
        }
        return res;  // return the result
    }
}

2843. Count Symmetric Integers in c++

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
public:
    int countSymmetricIntegers(int low, int high) {
        int res = 0;  // variable to store the result
        for(int i=low; i<=high; i++){  // loop until i is less than or equal to high
            if(isSymmetric(i)) res++;  // if the number is symmetric increment the result
        }
        return res;  // return the result
    }
    bool isSymmetric(int num){  // function to check if the number is symmetric
        string s = to_string(num);  // variable to store the string
        int n = s.length();  // variable to store the length of the string
        if(n%2 == 1) return false;  // if the length of the string is odd return false
        int leftSum = 0;  // variable to store the left sum
        int rightSum = 0;  // variable to store the right sum
        for(int i=0; i<n/2; i++){  // loop until i is less than n/2
            leftSum += s[i] - '0';  // update the left sum
            rightSum += s[n-i-1] - '0';  // update the right sum
        }
        return leftSum == rightSum;  // return true if the left sum is equal to the right sum else return false
    }
};

2843. Count Symmetric Integers in Java

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
    public int countSymmetricIntegers(int low, int high) {
        int res = 0;  // variable to store the result
        for(int i=low; i<=high; i++){  // loop until i is less than or equal to high
            if(isSymmetric(i)) res++;  // if the number is symmetric increment the result
        }
        return res;  // return the result
    }
    public boolean isSymmetric(int num){  // function to check if the number is symmetric
        String s = Integer.toString(num);  // variable to store the string
        int n = s.length();  // variable to store the length of the string
        if(n%2 == 1) return false;  // if the length of the string is odd return false
        int leftSum = 0;  // variable to store the left sum
        int rightSum = 0;  // variable to store the right sum
        for(int i=0; i<n/2; i++){  // loop until i is less than n/2
            leftSum += s.charAt(i) - '0';  // update the left sum
            rightSum += s.charAt(n-i-1) - '0';  // update the right sum
        }
        return leftSum == rightSum;  // return true if the left sum is equal to the right sum else return false
    }
}

2843. Count Symmetric Integers in Python

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution(object): # class Solution 
    def countSymmetricIntegers(self, low, high): # function to count symmetric integers
        """
        :type low: int
        :type high: int
        :rtype: int
        """
        res = 0 # variable to store the result
        for i in range(low, high+1): # loop until i is less than or equal to high
            if self.isSymmetric(i): res += 1 # if the number is symmetric increment the result
        return res # return the result
    def isSymmetric(self, num): # function to check if the number is symmetric
        s = str(num) # variable to store the string
        n = len(s) # variable to store the length of the string
        if n%2 == 1: return False # if the length of the string is odd return false
        leftSum = 0 # variable to store the left sum
        rightSum = 0 # variable to store the right sum
        for i in range(n//2): # loop until i is less than n/2
            leftSum += int(s[i]) # update the left sum
            rightSum += int(s[n-i-1]) # update the right sum
        return leftSum == rightSum # return true if the left sum is equal to the right sum else return false

2843. Count Symmetric Integers in Python3

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution:
    def countSymmetricIntegers(self, low: int, high: int) -> int:  # function to count symmetric integers
        res = 0  # variable to store the result
        for i in range(low, high+1):  # loop until i is less than or equal to high
            if self.isSymmetric(i): res += 1  # if the number is symmetric increment the result
        return res  # return the result
    def isSymmetric(self, num: int) -> bool:  # function to check if the number is symmetric
        s = str(num)  # variable to store the string
        n = len(s)  # variable to store the length of the string
        if n%2 == 1: return False  # if the length of the string is odd return false
        leftSum = 0  # variable to store the left sum
        rightSum = 0  # variable to store the right sum
        for i in range(n//2):  # loop until i is less than n/2
            leftSum += int(s[i])  # update the left sum
            rightSum += int(s[n-i-1])  # update the right sum
        return leftSum == rightSum  # return true if the left sum is equal to the right sum else return false

2843. Count Symmetric Integers in c

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

#include <stdio.h>
#include <stdbool.h>
#include <string.h>

// Function prototype for isSymmetric
bool isSymmetric(int num);

int countSymmetricIntegers(int low, int high) {
    int res = 0; // variable to store the result
    for (int i = low; i <= high; i++)
    { // loop until i is less than or equal to high
        if (isSymmetric(i))
            res++; // if the number is symmetric increment the result
    }
    return res; // return the result
}

bool isSymmetric(int num) {  // function to check if the number is symmetric
    char s[100];             // variable to store the string
    sprintf(s, "%d", num);   // variable to store the length of the string
    int n = strlen(s);       // variable to store the length of the string
    if (n % 2 == 1)
        return false; // if the length of the string is odd return false
    int leftSum = 0;  // variable to store the left sum
    int rightSum = 0; // variable to store the right sum
    for (int i = 0; i < n / 2; i++)
    {                                   // loop until i is less than n/2
        leftSum += s[i] - '0';          // update the left sum
        rightSum += s[n - i - 1] - '0'; // update the right sum
    }
    return leftSum == rightSum; // return true if the left sum is equal to the right sum else return false
}

2843. Count Symmetric Integers in c#

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

public class Solution {
    public int CountSymmetricIntegers(int low, int high) {
        int res = 0;  // variable to store the result
        for(int i=low; i<=high; i++){  // loop until i is less than or equal to high
            if(isSymmetric(i)) res++;  // if the number is symmetric increment the result
        }
        return res;  // return the result
        }
    public bool isSymmetric(int num){  // function to check if the number is symmetric
        string s = num.ToString();  // variable to store the string
        int n = s.Length;  // variable to store the length of the string
        if(n%2 == 1) return false;  // if the length of the string is odd return false
        int leftSum = 0;  // variable to store the left sum
        int rightSum = 0;  // variable to store the right sum
        for(int i=0; i<n/2; i++){  // loop until i is less than n/2
            leftSum += s[i] - '0';  // update the left sum
            rightSum += s[n-i-1] - '0';  // update the right sum
        }
        return leftSum == rightSum;  // return true if the left sum is equal to the right sum else return false
        }
}

2843. Count Symmetric Integers in Javascript

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

var countSymmetricIntegers = function(low, high) {
    let res = 0;  // variable to store the result
    for(let i=low; i<=high; i++){  // loop until i is less than or equal to high
        if(isSymmetric(i)) res++;  // if the number is symmetric increment the result
    }
    return res;  // return the result
};

var isSymmetric = function(num) {  // function to check if the number is symmetric
    let s = num.toString();  // variable to store the string
    let n = s.length;  // variable to store the length of the string
    if(n%2 == 1) return false;  // if the length of the string is odd return false
    let leftSum = 0;  // variable to store the left sum
    let rightSum = 0;  // variable to store the right sum
    for(let i=0; i<n/2; i++){  // loop until i is less than n/2
        leftSum += parseInt(s[i]);  // update the left sum
        rightSum += parseInt(s[n-i-1]);  // update the right sum
    }
    return leftSum == rightSum;  // return true if the left sum is equal to the right sum else return false
};

2843. Count Symmetric Integers in Swift

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
    func countSymmetricIntegers(_ low: Int, _ high: Int) -> Int {
        var res = 0;  // variable to store the result
        for i in low...high {  // loop until i is less than or equal to high
            if isSymmetric(i) { res += 1
            } // if the number is symmetric increment the result
            }
        return res;  // return the result
    }
    func isSymmetric(_ num: Int) -> Bool {  // function to check if the number is symmetric
        let s = String(num);  // variable to store the string
        let n = s.count;  // variable to store the length of the string
        if n%2 == 1 { return false }  // if the length of the string is odd return false
        var leftSum = 0;  // variable to store the left sum
        var rightSum = 0;  // variable to store the right sum
        for i in 0..<n/2 {  // loop until i is less than n/2
            leftSum += Int(String(s[s.index(s.startIndex, offsetBy: i)]))!;  // update the left sum
            rightSum += Int(String(s[s.index(s.startIndex, offsetBy: n-i-1)]))!;  // update the right sum
        }
        return leftSum == rightSum;  // return true if the left sum is equal to the right sum else return false
    }
}

2843. Count Symmetric Integers in Dart

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
    int countSymmetricIntegers(int low, int high) {
        int res = 0;  // variable to store the result
        for(int i=low; i<=high; i++){  // loop until i is less than or equal to high
            if(isSymmetric(i)) res++;  // if the number is symmetric increment the result
        }
        return res;  // return the result
    }
    bool isSymmetric(int num){  // function to check if the number is symmetric
        String s = num.toString();  // variable to store the string
        int n = s.length;  // variable to store the length of the string
        if(n%2 == 1) return false;  // if the length of the string is odd return false
        int leftSum = 0;  // variable to store the left sum
        int rightSum = 0;  // variable to store the right sum
        for(int i=0; i<n/2; i++){  // loop until i is less than n/2
            leftSum += int.parse(s[i]);  // update the left sum
            rightSum += int.parse(s[n-i-1]);  // update the right sum
        }
        return leftSum == rightSum;  // return true if the left sum is equal to the right sum else return false
    }
}

1024. Video Stitching in c++

// Time Complexity : O(nlogn) where n is the length of the vector nums and space complexity is O(1)

class Solution {
public:
    int videoStitching(vector<vector<int>>& clips, int time) {
        sort(clips.begin(), clips.end());  // sort the clips
        int i = 0 ,  start = 0 , end = 0 , res = 0; // variable to store the i, start, end and res
        // for(int i=0; start<time;start=end , res++){ // loop until start is less than time
            // or
            while(start < time) { // loop until start is less than time
            while(i<clips.size() && clips[i][0]<=start){
                end = max(end, clips[i][1]);  // loop until i is less than clips.size() and clips[i][0]<=start
                i++; // increment i
        }
            if(start == end) return -1;  // if start is equal to end return -1
            start = end;  // update the start
            res++;  // increment the result
        }
        return res;  // return the result
    }
};

2nd Method using Approach 2: Dynamic Programming

// Time Complexity : O(n*T) where n is the length of the vector nums and space complexity is O(T)

class Solution {
public:
    int videoStitching(vector<vector<int>>& clips, int time) {
        vector<int> dp(time+1, time+1);  // vector to store the dp
        dp[0] = 0;  // update the dp[0]
        for(int i=1; i<=time; i++){  // loop until i is less than or equal to time
            for(auto x:clips){  // loop for x
                if(x[0]<=i && i<=x[1]){  // if x[0]<=i and i<=x[1]
                    dp[i] = min(dp[i], dp[x[0]]+1);  // update the dp[i]
                }
            }
        }
        return dp[time] == time+1 ? -1 : dp[time];  // return dp[time] == time+1 ? -1 : dp[time]
    }
};

1024. Video Stitching in Java

// Time Complexity : O(nlogn) where n is the length of the vector nums and space complexity is O(1)

class Solution {
    public int videoStitching(int[][] clips, int time) {
        Arrays.sort(clips, (a,b)->a[0]-b[0]);  // sort the clips
        int i = 0 ,  start = 0 , end = 0 , res = 0; // variable to store the i, start, end and res
        // for(int i=0; start<time;start=end , res++){ // loop until start is less than time
            // or
            while(start < time) { // loop until start is less than time
            while(i<clips.length && clips[i][0]<=start){
                end = Math.max(end, clips[i][1]);  // loop until i is less than clips.length and clips[i][0]<=start
                i++; // increment i
        }
            if(start == end) return -1;  // if start is equal to end return -1
            start = end;  // update the start
            res++;  // increment the result
        }
        return res;  // return the result
    }
}

2nd Method using Approach 2: Dynamic Programming

// Time Complexity : O(n*T) where n is the length of the vector nums and space complexity is O(T)

class Solution {
    public int videoStitching(int[][] clips, int time) {
        int[] dp = new int[time+1];  // vector to store the dp
        Arrays.fill(dp, time+1);  // fill the dp
        dp[0] = 0;  // update the dp[0]
        for(int i=1; i<=time; i++){  // loop until i is less than or equal to time
            for(int[] x:clips){  // loop for x
                if(x[0]<=i && i<=x[1]){  // if x[0]<=i and i<=x[1]
                    dp[i] = Math.min(dp[i], dp[x[0]]+1);  // update the dp[i]
                }
            }
        }
        return dp[time] == time+1 ? -1 : dp[time];  // return dp[time] == time+1 ? -1 : dp[time]
    }
}

1024. Video Stitching in Python

// Time Complexity : O(nlogn) where n is the length of the vector nums and space complexity is O(1)

class Solution(object):
    def videoStitching(self, clips, time):
        """
        :type clips: List[List[int]]
        :type time: int
        :rtype: int
        """
        clips.sort(key=lambda x:x[0])  # sort the clips
        i = 0 ;  start = 0 ; end = 0 ; res = 0 # variable to store the i, start, end and res
        while start < time:  # loop until start is less than time
            while i<len(clips) and clips[i][0]<=start:
                end = max(end, clips[i][1])  # loop until i is less than len(clips) and clips[i][0]<=start
                i+=1  # increment i
            if start == end: return -1  # if start is equal to end return -1
            start = end  # update the start
            res+=1  # increment the result
        return res  # return the result

2nd Method using Approach 2: Dynamic Programming

// Time Complexity : O(n*T) where n is the length of the vector nums and space complexity is O(T)

class Solution(object):
    def videoStitching(self, clips, time):
        """
        :type clips: List[List[int]]
        :type time: int
        :rtype: int
        """
        dp = [time+1]*(time+1)  # vector to store the dp
        dp[0] = 0  # update the dp[0]
        for i in range(1, time+1):  # loop until i is less than or equal to time
            for x in clips:  # loop for x
                if x[0]<=i and i<=x[1]:  # if x[0]<=i and i<=x[1]
                    dp[i] = min(dp[i], dp[x[0]]+1)  # update the dp[i]
        return -1 if dp[time] == time+1 else dp[time]  # return -1 if dp[time] == time+1 else dp[time]

1024. Video Stitching in Python3

// Time Complexity : O(nlogn) where n is the length of the vector nums and space complexity is O(1)

class Solution:
    def videoStitching(self, clips: List[List[int], time: int) -> int: # add bracket after List[int]
        clips.sort(key=lambda x:x[0])  # sort the clips
        i = 0 ;  start = 0 ; end = 0 ; res = 0 # variable to store the i, start, end and res
        while start < time:  # loop until start is less than time
            while i<len(clips) and clips[i][0]<=start:
                end = max(end, clips[i][1])  # loop until i is less than len(clips) and clips[i][0]<=start
                i+=1  # increment i
            if start == end: return -1  # if start is equal to end return -1
            start = end  # update the start
            res+=1  # increment the result
        return res  # return the result

2nd Method using Approach 2: Dynamic Programming

// Time Complexity : O(n*T) where n is the length of the vector nums and space complexity is O(T)

class Solution:
    def videoStitching(self, clips: List[List[int], time: int) -> int: # add bracket after List[int]
        dp = [time+1]*(time+1)  # vector to store the dp
        dp[0] = 0  # update the dp[0]
        for i in range(1, time+1):  # loop until i is less than or equal to time
            for x in clips:  # loop for x
                if x[0]<=i and i<=x[1]:  # if x[0]<=i and i<=x[1]
                    dp[i] = min(dp[i], dp[x[0]]+1)  # update the dp[i]
        return -1 if dp[time] == time+1 else dp[time]  # return -1 if dp[time] == time+1 else dp[time]

1024. Video Stitching in c

// Time Complexity : O(nlogn) where n is the length of the vector nums and space complexity is O(1)

int cmp(const void* a, const void* b); // function to compare the elements
int videoStitching(int** clips, int clipsSize, int* clipsColSize, int time){
    qsort(clips, clipsSize, sizeof(int*), cmp);  // sort the clips
    int i = 0 ,  start = 0 , end = 0 , res = 0; // variable to store the i, start, end and res
    while(start < time){  // loop until start is less than time
        while(i<clipsSize && clips[i][0]<=start){
            end = fmax(end, clips[i][1]);  // loop until i is less than clipsSize and clips[i][0]<=start
            i++;  // increment i
        }
        if(start == end) return -1;  // if start is equal to end return -1
        start = end;  // update the start
        res++;  // increment the result
    }
    return res;  // return the result
}

int cmp(const void* a, const void* b){  // function to compare the elements
    int* arr1 = *(int**)a;  // variable to store the first element
    int* arr2 = *(int**)b;  // variable to store the second element
    return arr1[0] - arr2[0];  // return the difference of the elements
}

2nd Method using Approach 2: Dynamic Programming

// Time Complexity : O(n*T) where n is the length of the vector nums and space complexity is O(T)

int videoStitching(int** clips, int clipsSize, int* clipsColSize, int time){
    int dp[time+1];  // vector to store the dp
    memset(dp, time+1, sizeof(dp));  // fill the dp
    dp[0] = 0;  // update the dp[0]
    for(int i=1; i<=time; i++){  // loop until i is less than or equal to time
        for(int j=0; j<clipsSize; j++){  // loop for j
            if(clips[j][0]<=i && i<=clips[j][1]){  // if clips[j][0]<=i and i<=clips[j][1]
                dp[i] = fmin(dp[i], dp[clips[j][0]]+1);  // update the dp[i]
            }
        }
    }
    return dp[time] == time+1 ? -1 : dp[time];  // return dp[time] == time+1 ? -1 : dp[time]
}

1024. Video Stitching in c#

// Time Complexity : O(nlogn) where n is the length of the vector nums and space complexity is O(1)

public class Solution {
    public int VideoStitching(int[][] clips, int time) {
        Array.Sort(clips, (a,b)=>a[0]-b[0]);  // sort the clips
        int i = 0 ,  start = 0 , end = 0 , res = 0; // variable to store the i, start, end and res
        while(start < time){  // loop until start is less than time
            while(i<clips.Length && clips[i][0]<=start){
                end = Math.Max(end, clips[i][1]);  // loop until i is less than clips.Length and clips[i][0]<=start
                i++;  // increment i
            }
            if(start == end) return -1;  // if start is equal to end return -1
            start = end;  // update the start
            res++;  // increment the result
        }
        return res;  // return the result
    }
}

2nd Method using Approach 2: Dynamic Programming

// Time Complexity : O(n*T) where n is the length of the vector nums and space complexity is O(T)

public class Solution {
    public int VideoStitching(int[][] clips, int time) {
        int[] dp = new int[time+1];  // vector to store the dp
        Array.Fill(dp, time+1);  // fill the dp
        dp[0] = 0;  // update the dp[0]
        for(int i=1; i<=time; i++){  // loop until i is less than or equal to time
            for(int j=0; j<clips.Length; j++){  // loop for j
                if(clips[j][0]<=i && i<=clips[j][1]){  // if clips[j][0]<=i and i<=clips[j][1]
                    dp[i] = Math.Min(dp[i], dp[clips[j][0]]+1);  // update the dp[i]
                }
            }
        }
        return dp[time] == time+1 ? -1 : dp[time];  // return dp[time] == time+1 ? -1 : dp[time]
    }
}

1024. Video Stitching in Javascript

// Time Complexity : O(nlogn) where n is the length of the vector nums and space complexity is O(1)

var videoStitching = function(clips, time) {
    clips.sort((a,b)=>a[0]-b[0]);  // sort the clips
    let i = 0 ,  start = 0 , end = 0 , res = 0; // variable to store the i, start, end and res
    while(start < time){  // loop until start is less than time
        while(i<clips.length && clips[i][0]<=start){
            end = Math.max(end, clips[i][1]);  // loop until i is less than clips.length and clips[i][0]<=start
            i++;  // increment i
        }
        if(start == end) return -1;  // if start is equal to end return -1
        start = end;  // update the start
        res++;  // increment the result
    }
    return res;  // return the result
};

2nd Method using Approach 2: Dynamic Programming

// Time Complexity : O(n*T) where n is the length of the vector nums and space complexity is O(T)

var videoStitching = function(clips, time) {
    let dp = new Array(time+1).fill(time+1);  // vector to store the dp
    dp[0] = 0;  // update the dp[0]
    for(let i=1; i<=time; i++){  // loop until i is less than or equal to time
        for(let j=0; j<clips.length; j++){  // loop for j
            if(clips[j][0]<=i && i<=clips[j][1]){  // if clips[j][0]<=i and i<=clips[j][1]
                dp[i] = Math.min(dp[i], dp[clips[j][0]]+1);  // update the dp[i]
            }
        }
    }
    return dp[time] == time+1 ? -1 : dp[time];  // return dp[time] == time+1 ? -1 : dp[time]
};

1024. Video Stitching in Swift

// Time Complexity : O(nlogn) where n is the length of the vector nums and space complexity is O(1)

class Solution {
    func videoStitching(_ clips: [[Int]], _ time: Int) -> Int {
        var clips = clips.sorted(by: {$0[0]<$1[0]});  // sort the clips
        var i = 0 ,  start = 0 , end = 0 , res = 0; // variable to store the i, start, end and res
        while(start < time){  // loop until start is less than time
            while(i<clips.count && clips[i][0]<=start){
                end = max(end, clips[i][1]);  // loop until i is less than clips.count and clips[i][0]<=start
                i+=1;  // increment i
            }
            if(start == end) { return -1 }  // if start is equal to end return -1
            start = end;  // update the start
            res+=1;  // increment the result
        }
        return res;  // return the result
    }
}

2nd Method using Approach 2: Dynamic Programming

// Time Complexity : O(n*T) where n is the length of the vector nums and space complexity is O(T)

class Solution {
    func videoStitching(_ clips: [[Int]], _ time: Int) -> Int {
        var dp = Array(repeating: time+1, count: time+1);  // vector to store the dp
        dp[0] = 0;  // update the dp[0]
        for i in 1...time{  // loop until i is less than or equal to time
            for j in 0..<clips.count{  // loop for j
                if(clips[j][0]<=i && i<=clips[j][1]){  // if clips[j][0]<=i and i<=clips[j][1]
                    dp[i] = min(dp[i], dp[clips[j][0]]+1);  // update the dp[i]
                }
            }
        }
        return dp[time] == time+1 ? -1 : dp[time];  // return dp[time] == time+1 ? -1 : dp[time]
    }
}

1024. Video Stitching in Dart

// Time Complexity : O(nlogn) where n is the length of the vector nums and space complexity is O(1)

class Solution {
    int videoStitching(List<List<int>> clips, int time) {
        clips.sort((a,b)=>a[0]-b[0]);  // sort the clips
        int i = 0 ,  start = 0 , end = 0 , res = 0; // variable to store the i, start, end and res
        while(start < time){  // loop until start is less than time
            while(i<clips.length && clips[i][0]<=start){
                end = max(end, clips[i][1]);  // loop until i is less than clips.length and clips[i][0]<=start
                i++;  // increment i
            }
            if(start == end) return -1;  // if start is equal to end return -1
            start = end;  // update the start
            res++;  // increment the result
        }
        return res;  // return the result
    }
}

2nd Method using Approach 2: Dynamic Programming

// Time Complexity : O(n*T) where n is the length of the vector nums and space complexity is O(T)

class Solution {
    int videoStitching(List<List<int>> clips, int time) {
        int dp[time+1];  // vector to store the dp
        Arrays.fill(dp, time+1);  // fill the dp
        dp[0] = 0;  // update the dp[0]
        for(int i=1; i<=time; i++){  // loop until i is less than or equal to time
            for(int j=0; j<clips.length; j++){  // loop for j
                if(clips[j][0]<=i && i<=clips[j][1]){  // if clips[j][0]<=i and i<=clips[j][1]
                    dp[i] = min(dp[i], dp[clips[j][0]]+1);  // update the dp[i]
                }
            }
        }
        return dp[time] == time+1 ? -1 : dp[time];  // return dp[time] == time+1 ? -1 : dp[time]
    }
}

138. Copy List with Random Pointer in c++

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(!head) return NULL;  // if head is null return null
        Node* curr = head;  // variable to store the curr
        while(curr){  // loop until curr is null
            Node* temp = curr->next;  // variable to store the temp
            curr->next = new Node(curr->val);  // update the curr->next
            curr->next->next = temp;  // update the curr->next->next
            curr = temp;  // update the curr
        }
        curr = head;  // update the curr
        while(curr){  // loop until curr is null
            if(curr->random) curr->next->random = curr->random->next;  // if curr->random is not null update the curr->next->random
            curr = curr->next->next;  // update the curr
        }
        curr = head;  // update the curr
        Node* newHead = head->next;  // variable to store the newHead
        while(curr){  // loop until curr is null
            Node* temp = curr->next;  // variable to store the temp
            curr->next = temp->next;  // update the curr->next
            if(temp->next) temp->next = temp->next->next;  // if temp->next is not null update the temp->next
            curr = curr->next;  // update the curr
        }
        return newHead;  // return the newHead
    }
};

2nd Method 

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(n)

class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(!head) return NULL;  // if head is null return null
        unordered_map<Node*, Node*> mp;  // unordered_map to store the Node* and Node*
        Node* curr = head;  // variable to store the curr
        while(curr){  // loop until curr is null
            mp[curr] = new Node(curr->val);  // update the mp[curr]
            curr = curr->next;  // update the curr
        }
        curr = head;  // update the curr
        while(curr){  // loop until curr is null
            mp[curr]->next = mp[curr->next];  // update the mp[curr]->next
            mp[curr]->random = mp[curr->random];  // update the mp[curr]->random
            curr = curr->next;  // update the curr
        }
        return mp[head];  // return the mp[head]
    }
};

138. Copy List with Random Pointer in Java

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
    public Node copyRandomList(Node head) {
        if(head == null) return null;  // if head is null return null
        Node curr = head;  // variable to store the curr
        while(curr != null){  // loop until curr is null
            Node temp = curr.next;  // variable to store the temp
            curr.next = new Node(curr.val);  // update the curr->next
            curr.next.next = temp;  // update the curr->next->next
            curr = temp;  // update the curr
        }
        curr = head;  // update the curr
        while(curr != null){  // loop until curr is null
            if(curr.random != null) curr.next.random = curr.random.next;  // if curr->random is not null update the curr->next->random
            curr = curr.next.next;  // update the curr
        }
        curr = head;  // update the curr
        Node newHead = head.next;  // variable to store the newHead
        while(curr != null){  // loop until curr is null
            Node temp = curr.next;  // variable to store the temp
            curr.next = temp.next;  // update the curr->next
            if(temp.next != null) temp.next = temp.next.next;  // if temp->next is not null update the temp->next
            curr = curr.next;  // update the curr
        }
        return newHead;  // return the newHead
    }
}

2nd Method

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(n)

class Solution {
    public Node copyRandomList(Node head) {
        if(head == null) return null;  // if head is null return null
        Map<Node, Node> map = new HashMap<>();  // unordered_map to store the Node* and Node*
        Node curr = head;  // variable to store the curr
        while(curr != null){  // loop until curr is null
            map.put(curr, new Node(curr.val));  // update the mp[curr]
            curr = curr.next;  // update the curr
        }
        curr = head;  // update the curr
        while(curr != null){  // loop until curr is null
            map.get(curr).next = map.get(curr.next);  // update the mp[curr]->next
            map.get(curr).random = map.get(curr.random);  // update the mp[curr]->random
            curr = curr.next;  // update the curr
        }
        return map.get(head);  // return the mp[head]
    }
}

138. Copy List with Random Pointer in Python

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)\


class Solution(object):
    def copyRandomList(self, head):
        """
        :type head: Node
        :rtype: Node
        """
        if not head: return None  # if head is null return null
        curr = head  # variable to store the curr
        while curr:  # loop until curr is null
            temp = curr.next  # variable to store the temp
            curr.next = Node(curr.val)  # update the curr->next
            curr.next.next = temp  # update the curr->next->next
            curr = temp  # update the curr
        curr = head  # update the curr
        while curr:  # loop until curr is null
            if curr.random: curr.next.random = curr.random.next  # if curr->random is not null update the curr->next->random
            curr = curr.next.next  # update the curr
        curr = head  # update the curr
        newHead = head.next  # variable to store the newHead
        while curr:  # loop until curr is null
            temp = curr.next  # variable to store the temp
            curr.next = temp.next  # update the curr->next
            if temp.next: temp.next = temp.next.next  # if temp->next is not null update the temp->next
            curr = curr.next  # update the curr
        return newHead  # return the newHead

2nd Method

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(n)

class Solution(object):
    def copyRandomList(self, head):
        """
        :type head: Node
        :rtype: Node
        """
        if not head: return None  # if head is null return null
        mp = {}  # unordered_map to store the Node* and Node*
        curr = head  # variable to store the curr
        while curr:  # loop until curr is null
            mp[curr] = Node(curr.val)  # update the mp[curr]
            curr = curr.next  # update the curr
        curr = head  # update the curr
        while curr:  # loop until curr is null
            mp[curr].next = mp[curr.next]  # update the mp[curr]->next
            mp[curr].random = mp[curr.random]  # update the mp[curr]->random
            curr = curr.next  # update the curr
        return mp[head]  # return the mp[head]

138. Copy List with Random Pointer in Python3

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        if not head: return None  # if head is null return null
        curr = head  # variable to store the curr
        while curr:  # loop until curr is null
            temp = curr.next  # variable to store the temp
            curr.next = Node(curr.val)  # update the curr->next
            curr.next.next = temp  # update the curr->next->next
            curr = temp  # update the curr
        curr = head  # update the curr
        while curr:  # loop until curr is null
            if curr.random: curr.next.random = curr.random.next  # if curr->random is not null update the curr->next->random
            curr = curr.next.next  # update the curr
        curr = head  # update the curr
        newHead = head.next  # variable to store the newHead
        while curr:  # loop until curr is null
            temp = curr.next  # variable to store the temp
            curr.next = temp.next  # update the curr->next
            if temp.next: temp.next = temp.next.next  # if temp->next is not null update the temp->next
            curr = curr.next  # update the curr
        return newHead  # return the newHead
        
138. Copy List with Random Pointer in c

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

struct Node* copyRandomList(struct Node* head) {
    if(!head) return NULL;  // if head is null return null
    struct Node* curr = head;  // variable to store the curr
    while(curr){  // loop until curr is null
        struct Node* temp = curr->next;  // variable to store the temp
        curr->next = (struct Node*)malloc(sizeof(struct Node));  // update the curr->next
        curr->next->val = curr->val;  // update the curr->next->val
        curr->next->next = temp;  // update the curr->next->next
        curr = temp;  // update the curr
    }
    curr = head;  // update the curr
    while(curr){  // loop until curr is null
        if(curr->random) curr->next->random = curr->random->next;  // if curr->random is not null update the curr->next->random
        curr = curr->next->next;  // update the curr
    }
    curr = head;  // update the curr
    struct Node* newHead = head->next;  // variable to store the newHead
    while(curr){  // loop until curr is null
        struct Node* temp = curr->next;  // variable to store the temp
        curr->next = temp->next;  // update the curr->next
        if(temp->next) temp->next = temp->next->next;  // if temp->next is not null update the temp->next
        curr = curr->next;  // update the curr
    }
    return newHead;  // return the newHead
}

138. Copy List with Random Pointer in c#

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

public class Solution {
    public Node CopyRandomList(Node head) {
        if(head == null) return null;  // if head is null return null
        Node curr = head;  // variable to store the curr
        while(curr != null){  // loop until curr is null
            Node temp = curr.next;  // variable to store the temp
            curr.next = new Node(curr.val);  // update the curr->next
            curr.next.next = temp;  // update the curr->next->next
            curr = temp;  // update the curr
        }
        curr = head;  // update the curr
        while(curr != null){  // loop until curr is null
            if(curr.random != null) curr.next.random = curr.random.next;  // if curr->random is not null update the curr->next->random
            curr = curr.next.next;  // update the curr
        }
        curr = head;  // update the curr
        Node newHead = head.next;  // variable to store the newHead
        while(curr != null){  // loop until curr is null
            Node temp = curr.next;  // variable to store the temp
            curr.next = temp.next;  // update the curr->next
            if(temp.next != null) temp.next = temp.next.next;  // if temp->next is not null update the temp->next
            curr = curr.next;  // update the curr
        }
        return newHead;  // return the newHead
    }
}

138. Copy List with Random Pointer in Javascript

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

var copyRandomList = function(head) {
    if(!head) return null;  // if head is null return null
    let curr = head;  // variable to store the curr
    while(curr){  // loop until curr is null
        let temp = curr.next;  // variable to store the temp
        curr.next = new Node(curr.val);  // update the curr->next
        curr.next.next = temp;  // update the curr->next->next
        curr = temp;  // update the curr
    }
    curr = head;  // update the curr
    while(curr){  // loop until curr is null
        if(curr.random) curr.next.random = curr.random.next;  // if curr->random is not null update the curr->next->random
        curr = curr.next.next;  // update the curr
    }
    curr = head;  // update the curr
    let newHead = head.next;  // variable to store the newHead
    while(curr){  // loop until curr is null
        let temp = curr.next;  // variable to store the temp
        curr.next = temp.next;  // update the curr->next
        if(temp.next) temp.next = temp.next.next;  // if temp->next is not null update the temp->next
        curr = curr.next;  // update the curr
    }
    return newHead;  // return the newHead
};

138. Copy List with Random Pointer in Swift

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
    func copyRandomList(_ head: Node?) -> Node? {
        if head == nil { return nil }  // if head is null return null
        var curr = head  // variable to store the curr
        while curr != nil {  // loop until curr is null
            let temp = curr?.next  // variable to store the temp
            curr?.next = Node(curr!.val)  // update the curr->next
            curr?.next?.next = temp  // update the curr->next->next
            curr = temp  // update the curr
        }
        curr = head  // update the curr
        while curr != nil {  // loop until curr is null
            if curr?.random != nil { curr?.next?.random = curr?.random?.next }  // if curr->random is not null update the curr->next->random
            curr = curr?.next?.next  // update the curr
        }
        curr = head  // update the curr
        let newHead = head?.next  // variable to store the newHead
        while curr != nil {  // loop until curr is null
            let temp = curr?.next  // variable to store the temp
            curr?.next = temp?.next  // update the curr->next
            if temp?.next != nil { temp?.next = temp?.next?.next }  // if temp->next is not null update the temp->next
            curr = curr?.next  // update the curr
        }
        return newHead  // return the newHead
    }
}

138. Copy List with Random Pointer in Dart

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
    Node copyRandomList(Node head) {
        if(head == null) return null;  // if head is null return null
        Node curr = head;  // variable to store the curr
        while(curr != null){  // loop until curr is null
            Node temp = curr.next;  // variable to store the temp
            curr.next = Node(curr.val);  // update the curr->next
            curr.next.next = temp;  // update the curr->next->next
            curr = temp;  // update the curr
        }
        curr = head;  // update the curr
        while(curr != null){  // loop until curr is null
            if(curr.random != null) curr.next.random = curr.random.next;  // if curr->random is not null update the curr->next->random
            curr = curr.next.next;  // update the curr
        }
        curr = head;  // update the curr
        Node newHead = head.next;  // variable to store the newHead
        while(curr != null){  // loop until curr is null
            Node temp = curr.next;  // variable to store the temp
            curr.next = temp.next;  // update the curr->next
            if(temp.next != null) temp.next = temp.next.next;  // if temp->next is not null update the temp->next
            curr = curr.next;  // update the curr
        }
        return newHead;  // return the newHead
    }
}


725. Split Linked List in Parts in c++

// Time Complexity : O(n+k) where n is the length of the vector nums and space complexity is O(max(n,k))

class Solution {
public:
    vector<ListNode*> splitListToParts(ListNode* head, int k) {
        int n = 0;  // variable to store the n
        ListNode* curr = head;  // variable to store the curr
        while(curr){  // loop until curr is null
            n++;  // increment n
            curr = curr->next;  // update the curr
        }
        int width = n/k, rem = n%k;  // variable to store the width and rem
        vector<ListNode*> ans(k);  // vector to store the ans
        curr = head;  // update the curr
        for(int i=0; i<k; i++){  // loop until i is less than k
            ListNode* root = new ListNode(0);  // variable to store the root
            ListNode* write = root;  // variable to store the write
            for(int j=0; j<width+(i<rem?1:0); j++){  // loop until j is less than width+(i<rem?1:0)
                write->next = new ListNode(curr->val);  // update the write->next
                write = write->next;  // update the write
                if(curr) curr = curr->next;  // if curr is not null update the curr
            }
            ans[i] = root->next;  // update the ans[i]
        }
        return ans;  // return the ans
    }
};

2nd Method

// Time Complexity : O(n+k) where n is the length of the vector nums and space complexity is O(k)

class Solution {
public:
    vector<ListNode*> splitListToParts(ListNode* head, int k) {
        int n = 0;  // variable to store the n
        ListNode* curr = head;  // variable to store the curr
        while(curr){  // loop until curr is null
            n++;  // increment n
            curr = curr->next;  // update the curr
        }
        int width = n/k, rem = n%k;  // variable to store the width and rem
        vector<ListNode*> ans(k);  // vector to store the ans
        curr = head;  // update the curr
        for(int i=0; i<k; i++){  // loop until i is less than k
            ListNode* root = curr;  // variable to store the root
            for(int j=0; j<width+(i<rem?1:0)-1; j++){  // loop until j is less than width+(i<rem?1:0)-1
                if(curr) curr = curr->next;  // if curr is not null update the curr
            }
            // Inside the inner for loop, a ListNode* pointer named root is assigned the current curr pointer. This root pointer will point to the beginning of the current part of the split list.
            // Another loop (for (int j = 0; j < width + (i < rem ? 1 : 0) - 1; j++)) is used to traverse the list to the end of the current part. It adds width nodes initially and an additional node if i < rem (i.e., if there are remaining nodes to distribute among the parts). The - 1 ensures that the loop stops before the next part begins.
            // Inside this loop, if curr is not null, it is updated to point to the next node using curr = curr->next.
//             Certainly! Let's break down the expression `for (int j = 0; j < width + (i < rem ? 1 : 0) - 1; j++)` in brief:

// - `int j = 0;` initializes a variable `j` to 0. This variable will be used as a loop counter.

// - `j < width + (i < rem ? 1 : 0) - 1;` is the condition that determines whether the loop should continue. Let's break it down further:
//    - `width` represents the desired number of nodes for the current part of the split list.
//    - `(i < rem ? 1 : 0)` is a conditional expression that checks if `i` (the current part index) is less than `rem` (the remainder of nodes after distributing equally among parts). If `i` is less than `rem`, it evaluates to 1; otherwise, it evaluates to 0.
//    - `width + (i < rem ? 1 : 0)` calculates the total number of nodes for the current part, considering the extra node (1) if `i` is less than `rem`.
//    - `- 1` subtracts 1 from this total to ensure that the loop stops before the next part begins.

// - `j++` increments the loop counter `j` after each iteration of the loop.

// In summary, this `for` loop iterates over a portion of the linked list nodes (determined by `width` and whether there is an extra node based on `i` and `rem`) and continues until it reaches the specified number of nodes for the current part, minus one. This helps in correctly dividing the linked list into parts, ensuring that each part has the correct number of nodes.
            if(curr){  // if curr is not null
                ListNode* prev = curr;  // variable to store the prev
                curr = curr->next;  // update the curr
                prev->next = NULL;  // update the prev->next
            }
            // After determining the end of the current part, this block of code checks if curr is not null. If it's not null, it means there are more nodes in the list. It creates a ListNode* pointer named prev to point to the current node. The curr pointer is updated to point to the next node, and prev->next is set to NULL, effectively breaking the link between the current part and the next part.
            ans[i] = root;  // update the ans[i]
        }
        return ans;  // return the ans
    }
};

725. Split Linked List in Parts in Java

// Time Complexity : O(n+k) where n is the length of the vector nums and space complexity is O(max(n,k))

class Solution {
    public ListNode[] splitListToParts(ListNode head, int k) {
        int n = 0;  // variable to store the n
        ListNode curr = head;  // variable to store the curr
        while(curr != null){  // loop until curr is null
            n++;  // increment n
            curr = curr.next;  // update the curr
        }
        int width = n/k, rem = n%k;  // variable to store the width and rem
        ListNode[] ans = new ListNode[k];  // vector to store the ans
        curr = head;  // update the curr
        for(int i=0; i<k; i++){  // loop until i is less than k
            ListNode root = new ListNode(0);  // variable to store the root
            ListNode write = root;  // variable to store the write
            for(int j=0; j<width+(i<rem?1:0); j++){  // loop until j is less than width+(i<rem?1:0)
                write.next = new ListNode(curr.val);  // update the write->next
                write = write.next;  // update the write
                if(curr != null) curr = curr.next;  // if curr is not null update the curr
            }
            ans[i] = root.next;  // update the ans[i]
        }
        return ans;  // return the ans
    }
}

2nd Method

// Time Complexity : O(n+k) where n is the length of the vector nums and space complexity is O(k)

class Solution {
    public ListNode[] splitListToParts(ListNode head, int k) {
        int n = 0;  // variable to store the n
        ListNode curr = head;  // variable to store the curr
        while(curr != null){  // loop until curr is null
            n++;  // increment n
            curr = curr.next;  // update the curr
        }
        int width = n/k, rem = n%k;  // variable to store the width and rem
        ListNode[] ans = new ListNode[k];  // vector to store the ans
        curr = head;  // update the curr
        for(int i=0; i<k; i++){  // loop until i is less than k
            ListNode root = curr;  // variable to store the root
            for(int j=0; j<width+(i<rem?1:0)-1; j++){  // loop until j is less than width+(i<rem?1:0)-1
                if(curr != null) curr = curr.next;  // if curr is not null update the curr
            }
            if(curr != null){  // if curr is not null
                ListNode prev = curr;  // variable to store the prev
                curr = curr.next;  // update the curr
                prev.next = null;  // update the prev->next
            }
            ans[i] = root;  // update the ans[i]
        }
        return ans;  // return the ans
    }
}

725. Split Linked List in Parts in Python

// Time Complexity : O(n+k) where n is the length of the vector nums and space complexity is O(max(n,k))

class Solution(object):
    def splitListToParts(self, head, k):
        """
        :type head: ListNode
        :type k: int
        :rtype: List[ListNode]
        """
        
        n = 0  # variable to store the n
        curr = head  # variable to store the curr
        while curr:  # loop until curr is null
            n += 1  # increment n
            curr = curr.next  # update the curr
        width, rem = divmod(n, k)  # variable to store the width and rem
       //  ans = []  # vector to store the ans
        curr = head  # update the curr
        for i in range(k):  # loop until i is less than k
            root = write = ListNode(None)  # variable to store the root and write
            for j in range(width + (i < rem)):  # loop until j is less than width + (i < rem)
                write.next = write = ListNode(curr.val)  # update the write->next
                if curr: curr = curr.next  # if curr is not null update the curr
            ans.append(root.next)  # update the ans
        return ans  # return the ans

2nd Method

// Time Complexity : O(n+k) where n is the length of the vector nums and space complexity is O(k)

class Solution(object):
    def splitListToParts(self, head, k):
        """
        :type head: ListNode
        :type k: int
        :rtype: List[ListNode]
        """
        
        n = 0  # variable to store the n
        curr = head  # variable to store the curr
        while curr:  # loop until curr is null
            n += 1  # increment n
            curr = curr.next  # update the curr
        width, rem = divmod(n, k)  # variable to store the width and rem
        ans = []  # vector to store the ans
        curr = head  # update the curr
        for i in range(k):  # loop until i is less than k
            root = curr  # variable to store the root
            for j in range(width + (i < rem) - 1):  # loop until j is less than width + (i < rem) - 1
                if curr: curr = curr.next  # if curr is not null update the curr
            if curr:  # if curr is not null
                prev = curr  # variable to store the prev
                curr = curr.next  # update the curr
                prev.next = None  # update the prev->next
            ans.append(root)  # update the ans
        return ans  # return the ans

725. Split Linked List in Parts in Python3

// Time Complexity : O(n+k) where n is the length of the vector nums and space complexity is O(k)

class Solution:
    def splitListToParts(self, head: ListNode, k: int) -> List[ListNode]:
        n = 0  # variable to store the n
        curr = head  # variable to store the curr
        while curr:  # loop until curr is null
            n += 1  # increment n
            curr = curr.next  # update the curr
        width, rem = divmod(n, k)  # variable to store the width and rem
        ans = []  # vector to store the ans
        curr = head  # update the curr
        for i in range(k):  # loop until i is less than k
            root = curr  # variable to store the root
            for j in range(width + (i < rem) - 1):  # loop until j is less than width + (i < rem) - 1
                if curr: curr = curr.next  # if curr is not null update the curr
            if curr:  # if curr is not null
                prev = curr  # variable to store the prev
                curr = curr.next  # update the curr
                prev.next = None  # update the prev->next
            ans.append(root)  # update the ans
        return ans  # return the ans

725. Split Linked List in Parts in c

// Time Complexity : O(n+k) where n is the length of the vector nums and space complexity is O(k)

struct ListNode** splitListToParts(struct ListNode* head, int k, int* returnSize) {
    int n = 0;  // variable to store the n
    struct ListNode* curr = head;  // variable to store the curr
    while(curr){  // loop until curr is null
        n++;  // increment n
        curr = curr->next;  // update the curr
    }
    int width = n/k, rem = n%k;  // variable to store the width and rem
    struct ListNode** ans = (struct ListNode**)malloc(sizeof(struct ListNode*)*k);  // vector to store the ans
    curr = head;  // update the curr
    for(int i=0; i<k; i++){  // loop until i is less than k
        struct ListNode* root = curr;  // variable to store the root
        for(int j=0; j<width+(i<rem?1:0)-1; j++){  // loop until j is less than width+(i<rem?1:0)-1
            if(curr) curr = curr->next;  // if curr is not null update the curr
        }
        if(curr){  // if curr is not null
            struct ListNode* prev = curr;  // variable to store the prev
            curr = curr->next;  // update the curr
            prev->next = NULL;  // update the prev->next
        }
        ans[i] = root;  // update the ans[i]
    }
    *returnSize = k;  // update the returnSize
    return ans;  // return the ans
}

725. Split Linked List in Parts in c#

// Time Complexity : O(n+k) where n is the length of the vector nums and space complexity is O(k)

public class Solution {
    public ListNode[] SplitListToParts(ListNode head, int k) {
        int n = 0;  // variable to store the n
        ListNode curr = head;  // variable to store the curr
        while(curr != null){  // loop until curr is null
            n++;  // increment n
            curr = curr.next;  // update the curr
        }
        int width = n/k, rem = n%k;  // variable to store the width and rem
        ListNode[] ans = new ListNode[k];  // vector to store the ans
        curr = head;  // update the curr
        for(int i=0; i<k; i++){  // loop until i is less than k
            ListNode root = curr;  // variable to store the root
            for(int j=0; j<width+(i<rem?1:0)-1; j++){  // loop until j is less than width+(i<rem?1:0)-1
                if(curr != null) curr = curr.next;  // if curr is not null update the curr
            }
            if(curr != null){  // if curr is not null
                ListNode prev = curr;  // variable to store the prev
                curr = curr.next;  // update the curr
                prev.next = null;  // update the prev->next
            }
            ans[i] = root;  // update the ans[i]
        }
        return ans;  // return the ans
    }
}

725. Split Linked List in Parts in Javascript

// Time Complexity : O(n+k) where n is the length of the vector nums and space complexity is O(k)

var splitListToParts = function(head, k) {
    let n = 0  // variable to store the n
    let curr = head  // variable to store the curr
    while(curr){  // loop until curr is null
        n++  // increment n
        curr = curr.next  // update the curr
    }
    let width = Math.floor(n/k), rem = n%k  // variable to store the width and rem
    let ans = []  // vector to store the ans
    curr = head  // update the curr
    for(let i=0; i<k; i++){  // loop until i is less than k
        let root = curr  // variable to store the root
        for(let j=0; j<width+(i<rem?1:0)-1; j++){  // loop until j is less than width+(i<rem?1:0)-1
            if(curr) curr = curr.next  // if curr is not null update the curr
        }
        if(curr){  // if curr is not null
            let prev = curr  // variable to store the prev
            curr = curr.next  // update the curr
            prev.next = null  // update the prev->next
        }
        ans[i] = root  // update the ans[i]
    }
    return ans  // return the ans
};

725. Split Linked List in Parts in Swift

// Time Complexity : O(n+k) where n is the length of the vector nums and space complexity is O(k)

class Solution {
    func splitListToParts(_ head: ListNode?, _ k: Int) -> [ListNode?] {
        var n = 0  // variable to store the n
        var curr = head  // variable to store the curr
        while curr != nil {  // loop until curr is null
            n += 1  // increment n
            curr = curr?.next  // update the curr
        }
        let width = n / k, rem = n % k  // variable to store the width and rem
        var ans = [ListNode?](repeating: nil, count: k)  // array to store the ans
        curr = head  // update the curr
        
        for i in stride(from: 0, to: k, by: 1) {  // use stride to loop through i from 0 to k-1
            var root = curr  // variable to store the root
            let partSize = width + (i < rem ? 1 : 0)
            for j in stride(from: 0, to: partSize - 1, by: 1) {  // use stride for inner loop
                if curr != nil {
                    curr = curr?.next  // if curr is not null, update the curr
                }
            }
            if curr != nil {
                let nextNode = curr?.next
                curr?.next = nil
                curr = nextNode
            }
            ans[i] = root  // update the ans[i]
        }
        return ans  // return the ans
    }
}


725. Split Linked List in Parts in Dart

// Time Complexity : O(n+k) where n is the length of the vector nums and space complexity is O(k)

class Solution {
  List<ListNode?> splitListToParts(ListNode? head, int k) {
    int n = 0; // variable to store the n
    ListNode? curr = head; // variable to store the curr
    while (curr != null) { // loop until curr is null
      n++; // increment n
      curr = curr.next; // update the curr
    }
    int width = n ~/ k, rem = n % k; // variable to store the width and rem
    List<ListNode?> ans = []; // list to store the ans
    curr = head; // update the curr
    for (int i = 0; i < k; i++) { // loop until i is less than k
      ListNode? root = curr; // variable to store the root
      for (int j = 0; j < width + (i < rem ? 1 : 0) - 1; j++) { // loop until j is less than width + (i < rem ? 1 : 0) - 1
        if (curr != null) curr = curr.next; // if curr is not null update the curr
      }
      if (curr != null) { // if curr is not null
        ListNode? prev = curr; // variable to store the prev
        curr = curr.next; // update the curr
        prev.next = null; // update the prev->next
      }
      ans.add(root); // update the ans
    }
    return ans; // return the ans
  }
}

92. Reverse Linked List II in c++

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode* dummy = new ListNode(0);  // variable to store the dummy
        dummy->next = head;  // update the dummy->next
        ListNode* prev = dummy;  // variable to store the prev
        for(int i=0; i<left-1; i++){  // loop until i is less than left-1
            prev = prev->next;  // update the prev
        }
        ListNode* curr = prev->next;  // variable to store the curr
        for(int i=0; i<right-left; i++){  // loop until i is less than right-left
            ListNode* temp = prev->next;  // variable to store the temp
            prev->next = curr->next;  // update the prev->next
            curr->next = curr->next->next;  // update the curr->next
            prev->next->next = temp;  // update the prev->next->next
        }
        return dummy->next;  // return the dummy->next
    }
};

92. Reverse Linked List II in java

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(0);  // variable to store the dummy
        dummy.next = head;  // update the dummy->next
        ListNode prev = dummy;  // variable to store the prev
        for(int i=0; i<left-1; i++){  // loop until i is less than left-1
            prev = prev.next;  // update the prev
        }
        ListNode curr = prev.next;  // variable to store the curr
        for(int i=0; i<right-left; i++){  // loop until i is less than right-left
            ListNode temp = prev.next;  // variable to store the temp
            prev.next = curr.next;  // update the prev->next
            curr.next = curr.next.next;  // update the curr->next
            prev.next.next = temp;  // update the prev->next->next
        }
        return dummy.next;  // return the dummy->next
    }
}

92. Reverse Linked List II in python

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution(object):
    def reverseBetween(self, head, left, right):
        """
        :type head: ListNode
        :type left: int
        :type right: int
        :rtype: ListNode
        """
        
        dummy = ListNode(0)  # variable to store the dummy
        dummy.next = head  # update the dummy->next
        prev = dummy  # variable to store the prev
        for i in range(left-1):  # loop until i is less than left-1
            prev = prev.next  # update the prev
        curr = prev.next  # variable to store the curr
        for i in range(right-left):  # loop until i is less than right-left
            temp = prev.next  # variable to store the temp
            prev.next = curr.next  # update the prev->next
            curr.next = curr.next.next  # update the curr->next
            prev.next.next = temp  # update the prev->next->next
        return dummy.next  # return the dummy->next

92. Reverse Linked List II in python3

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution:
    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:
        dummy = ListNode(0)  # variable to store the dummy
        dummy.next = head  # update the dummy->next
        prev = dummy  # variable to store the prev
        for i in range(left-1):  # loop until i is less than left-1
            prev = prev.next  # update the prev
        curr = prev.next  # variable to store the curr
        for i in range(right-left):  # loop until i is less than right-left
            temp = prev.next  # variable to store the temp
            prev.next = curr.next  # update the prev->next
            curr.next = curr.next.next  # update the curr->next
            prev.next.next = temp  # update the prev->next->next
        return dummy.next  # return the dummy->next

92. Reverse Linked List II in c

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

struct ListNode* reverseBetween(struct ListNode* head, int left, int right){
    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));  // variable to store the dummy
    dummy->next = head;  // update the dummy->next
    struct ListNode* prev = dummy;  // variable to store the prev
    for(int i=0; i<left-1; i++){  // loop until i is less than left-1
        prev = prev->next;  // update the prev
    }
    struct ListNode* curr = prev->next;  // variable to store the curr
    for(int i=0; i<right-left; i++){  // loop until i is less than right-left
        struct ListNode* temp = prev->next;  // variable to store the temp
        prev->next = curr->next;  // update the prev->next
        curr->next = curr->next->next;  // update the curr->next
        prev->next->next = temp;  // update the prev->next->next
    }
    return dummy->next;  // return the dummy->next
}


92. Reverse Linked List II in c#

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

public class Solution {
    public ListNode ReverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(0);  // variable to store the dummy
        dummy.next = head;  // update the dummy->next
        ListNode prev = dummy;  // variable to store the prev
        for(int i=0; i<left-1; i++){  // loop until i is less than left-1
            prev = prev.next;  // update the prev
        }
        ListNode curr = prev.next;  // variable to store the curr
        for(int i=0; i<right-left; i++){  // loop until i is less than right-left
            ListNode temp = prev.next;  // variable to store the temp
            prev.next = curr.next;  // update the prev->next
            curr.next = curr.next.next;  // update the curr->next
            prev.next.next = temp;  // update the prev->next->next
        }
        return dummy.next;  // return the dummy->next
    }
}

92. Reverse Linked List II in Javascript

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

var reverseBetween = function(head, left, right) {
    let dummy = new ListNode(0);  // variable to store the dummy
    dummy.next = head;  // update the dummy->next
    let prev = dummy;  // variable to store the prev
    for(let i=0; i<left-1; i++){  // loop until i is less than left-1
        prev = prev.next;  // update the prev
    }
    let curr = prev.next;  // variable to store the curr
    for(let i=0; i<right-left; i++){  // loop until i is less than right-left
        let temp = prev.next;  // variable to store the temp
        prev.next = curr.next;  // update the prev->next
        curr.next = curr.next.next;  // update the curr->next
        prev.next.next = temp;  // update the prev->next->next
    }
    return dummy.next;  // return the dummy->next
};

92. Reverse Linked List II in Swift

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {
        let dummy = ListNode(0);  // variable to store the dummy
        dummy.next = head;  // update the dummy->next
        var prev = dummy;  // variable to store the prev
        for i in 0..<left-1{  // loop until i is less than left-1
            prev = prev.next!;  // update the prev
        }
        var curr = prev.next;  // variable to store the curr
        for i in 0..<right-left{  // loop until i is less than right-left
            let temp = prev.next;  // variable to store the temp
            prev.next = curr?.next;  // update the prev->next
            curr?.next = curr?.next?.next;  // update the curr->next
            prev.next?.next = temp;  // update the prev->next->next
        }
        return dummy.next;  // return the dummy->next
    }
}

92. Reverse Linked List II in Dart

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
  ListNode? reverseBetween(ListNode? head, int left, int right) {
    ListNode? dummy = ListNode(0);  // variable to store the dummy
    dummy.next = head;  // update the dummy->next
    ListNode? prev = dummy;  // variable to store the prev
    for (int i = 0; i < left - 1; i++) {  // loop until i is less than left-1
      prev = prev!.next;  // update the prev
    }
    ListNode? curr = prev!.next;  // variable to store the curr
    for (int i = 0; i < right - left; i++) {  // loop until i is less than right-left
      ListNode? temp = prev!.next;  // variable to store the temp
      prev!.next = curr!.next;  // update the prev->next
      curr!.next = curr!.next!.next;  // update the curr->next
      prev!.next!.next = temp;  // update the prev->next->next
    }
    return dummy!.next;  // return the dummy->next
  }
}

1359. Count All Valid Pickup and Delivery Options in  c++

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
public:
    int countOrders(int n) {
        long res = 1 , mod = 1e9+7;  // variable to store the res and mod
        for(int i=1; i<=n; i++){  // loop until i is less than or equal to n
            res = res*(i*2-1)*i%mod;  // update the res
        }
        return res;  // return the res
    }
};

1359. Count All Valid Pickup and Delivery Options in  java

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
    public int countOrders(int n) {
        long res = 1 , mod = 1_000_000_007;  // variable to store the res and mod
        for(int i=1; i<=n; i++){  // loop until i is less than or equal to n
            res = res*(i*2-1)*i%mod;  // update the res
        }
        return (int)res;  // return the res
    }
};

1359. Count All Valid Pickup and Delivery Options in  python

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution(object):
    def countOrders(self, n):
        """
        :type n: int
        :rtype: int
        """

        res = 1  # variable to store the res
        mod = 10**9 + 7  # variable to store the mod
        for i in range(1, n+1):  # loop until i is less than or equal to n
            res = res*(i*2-1)*i%mod  # update the res
        return res  # return the res

1359. Count All Valid Pickup and Delivery Options in  python3

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution:
    def countOrders(self, n: int) -> int:
        res = 1  # variable to store the res
        mod = 10**9 + 7  # variable to store the mod
        for i in range(1, n+1):  # loop until i is less than or equal to n
            res = res*(i*2-1)*i%mod  # update the res
        return res  # return the res

1359. Count All Valid Pickup and Delivery Options in  c

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

int countOrders(int n){
    long res = 1 , mod = 1e9+7;  // variable to store the res and mod
    for(int i=1; i<=n; i++){  // loop until i is less than or equal to n
        res = res*(i*2-1)*i%mod;  // update the res
    }
    return res;  // return the res
}

1359. Count All Valid Pickup and Delivery Options in  c#

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

public class Solution {
    public int CountOrders(int n) {
        long res = 1 , mod = 1_000_000_007;  // variable to store the res and mod
        for(int i=1; i<=n; i++){  // loop until i is less than or equal to n
            res = res*(i*2-1)*i%mod;  // update the res
        }
        return (int)res;  // return the res
    }
}

1359. Count All Valid Pickup and Delivery Options in  Javascript

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

var countOrders = function(n) {
    let res = 1  // variable to store the res
    let mod = 10**9 + 7  // variable to store the mod
    for(let i=1; i<=n; i++){  // loop until i is less than or equal to n
        res = res*(i*2-1)*i%mod  // update the res
    }
    return res  // return the res
};

1359. Count All Valid Pickup and Delivery Options in  Swift

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
    func countOrders(_ n: Int) -> Int {
        var res = 1  // variable to store the res
        let mod = Int(pow(10.0, 9.0)) + 7  // variable to store the mod
        for i in 1...n {  // loop until i is less than or equal to n
            res = (res * (i * 2 - 1) * i) % mod  // update the res
        }
        return res  // return the res
    }
}

1359. Count All Valid Pickup and Delivery Options in  Dart

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
  int countOrders(int n) {
    int res = 1;  // variable to store the res
    int mod = pow(10, 9).toInt() + 7;  // variable to store the mod
    for (int i = 1; i <= n; i++) {  // loop until i is less than or equal to n
      res = (res * (i * 2 - 1) * i) % mod;  // update the res
    }
    return res;  // return the res
  }
}

456. 132 Pattern in c++

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(n)

class Solution {
public:
    bool find132pattern(vector<int>& nums) {
        int n = nums.size();  // variable to store the n
        stack<int>st;  // stack to store the st
        int s3 = INT_MIN;  // variable to store the s3
        for(int i=n-1; i>=0; i--){  // loop until i is greater than or equal to 0
            if(nums[i]<s3)return true;  // if nums[i] is less than s3 return true
            else{  // else
                while(!st.empty() && nums[i]>st.top()){  // loop until st is not empty and nums[i] is greater than st.top()
                    s3 = st.top();  // update the s3
                    st.pop();  // pop the st
                }
            }
            st.push(nums[i]);  // push the nums[i]
        }
        return false;  // return false
    }

};

456. 132 Pattern in java

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(n)

class Solution {
    public boolean find132pattern(int[] nums) {
        int n = nums.length;  // variable to store the n
        Stack<Integer>st = new Stack<>();  // stack to store the st
        int s3 = Integer.MIN_VALUE;  // variable to store the s3
        for(int i=n-1; i>=0; i--){  // loop until i is greater than or equal to 0
            if(nums[i]<s3)return true;  // if nums[i] is less than s3 return true
            else{  // else
                while(!st.empty() && nums[i]>st.peek()){  // loop until st is not empty and nums[i] is greater than st.top()
                    s3 = st.peek();  // update the s3
                    st.pop();  // pop the st
                }
            }
            st.push(nums[i]);  // push the nums[i]
        }
        return false;  // return false
    }
}

456. 132 Pattern in python

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(n)

class Solution(object):
    def find132pattern(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        n = len(nums)  # variable to store the n
        st = []  # stack to store the st
        s3 = float('-inf')  # variable to store the s3
        for i in range(n-1, -1, -1):  # loop until i is greater than or equal to 0
            if nums[i]<s3: return True  # if nums[i] is less than s3 return true
            else:  # else
                while st and nums[i]>st[-1]:  # loop until st is not empty and nums[i] is greater than st.top()
                    s3 = st[-1]  # update the s3
                    st.pop()  # pop the st
            st.append(nums[i])  # push the nums[i]
        return False  # return false

456. 132 Pattern in python3

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(n)

class Solution:
    def find132pattern(self, nums: List[int) -> bool: // add the missing bracket after int
        n = len(nums)  # variable to store the n
        st = []  # stack to store the st
        s3 = float('-inf')  # variable to store the s3
        for i in range(n-1, -1, -1):  # loop until i is greater than or equal to 0
            if nums[i]<s3: return True  # if nums[i] is less than s3 return true
            else:  # else
                while st and nums[i]>st[-1]:  # loop until st is not empty and nums[i] is greater than st.top()
                    s3 = st[-1]  # update the s3
                    st.pop()  # pop the st
            st.append(nums[i])  # push the nums[i]
        return False  # return false

456. 132 Pattern in c

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(n)

bool find132pattern(int* nums, int numsSize){
    int n = numsSize;  // variable to store the n
    int st[n];  // stack to store the st
    int top = -1;  // variable to store the top
    int s3 = INT_MIN;  // variable to store the s3
    for(int i=n-1; i>=0; i--){  // loop until i is greater than or equal to 0
        if(nums[i]<s3)return true;  // if nums[i] is less than s3 return true
        else{  // else
            while(top!=-1 && nums[i]>st[top]){  // loop until st is not empty and nums[i] is greater than st.top()
                s3 = st[top];  // update the s3
                top--;  // pop the st
            }
        }
        st[++top] = nums[i];  // push the nums[i]
    }
    return false;  // return false
}

456. 132 Pattern in c#

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(n)

public class Solution {
    public bool Find132pattern(int[] nums) {
        int n = nums.Length;  // variable to store the n
        int[] st = new int[n];  // stack to store the st
        int top = -1;  // variable to store the top
        int s3 = int.MinValue;  // variable to store the s3
        for(int i=n-1; i>=0; i--){  // loop until i is greater than or equal to 0
            if(nums[i]<s3)return true;  // if nums[i] is less than s3 return true
            else{  // else
                while(top!=-1 && nums[i]>st[top]){  // loop until st is not empty and nums[i] is greater than st.top()
                    s3 = st[top];  // update the s3
                    top--;  // pop the st
                }
            }
            st[++top] = nums[i];  // push the nums[i]
        }
        return false;  // return false
    }
}

456. 132 Pattern in Javascript

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(n)

var find132pattern = function(nums) {
    let n = nums.length;  // variable to store the n
    let st = [];  // stack to store the st
    let s3 = Number.MIN_SAFE_INTEGER;  // variable to store the s3
    for(let i=n-1; i>=0; i--){  // loop until i is greater than or equal to 0
        if(nums[i]<s3)return true;  // if nums[i] is less than s3 return true
        else{  // else
            while(st.length && nums[i]>st[st.length-1]){  // loop until st is not empty and nums[i] is greater than st.top()
                s3 = st[st.length-1];  // update the s3
                st.pop();  // pop the st
            }
        }
        st.push(nums[i]);  // push the nums[i]
    }
    return false;  // return false
};

456. 132 Pattern in Swift

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(n)

class Solution {
    func find132pattern(_ nums: [Int]) -> Bool {
        let n = nums.count;  // variable to store the n
        var st = [Int]();  // stack to store the st
        var s3 = Int.min;  // variable to store the s3
        for i in stride(from: n-1, to: -1, by: -1){  // loop until i is greater than or equal to 0
            if nums[i]<s3{return true;}  // if nums[i] is less than s3 return true
            else{  // else
                while st.count>0 && nums[i]>st[st.count-1]{  // loop until st is not empty and nums[i] is greater than st.top()
                    s3 = st[st.count-1];  // update the s3
                    st.popLast();  // pop the st
                }
            }
            st.append(nums[i]);  // push the nums[i]
        }
        return false;  // return false
    }
}

456. 132 Pattern in Dart

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(n)

class Solution {
  bool find132pattern(List<int> nums) {
    int n = nums.length;  // variable to store the n
    List<int> st = [];  // stack to store the st
    int INT_MIN = -2147483648; // Minimum value for a 32-bit signed integer
    int s3 = INT_MIN; // Now you can use INT_MIN to initialize s3
    for (int i = n - 1; i >= 0; i--) {  // loop until i is greater than or equal to 0
      if (nums[i] < s3) return true;  // if nums[i] is less than s3 return true
      else {  // else
        while (st.length > 0 && nums[i] > st[st.length - 1]) {  // loop until st is not empty and nums[i] is greater than st.top()
          s3 = st[st.length - 1];  // update the s3
          st.removeLast();  // pop the st
        }
      }
      st.add(nums[i]);  // push the nums[i]
    }
    return false;  // return false
  }
}

316. Remove Duplicate Letters in c++

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
public:
    string removeDuplicateLetters(string s) {
        vector<int>cnt(26);  // vector to store the cnt
        vector<bool>used(26);  // vector to store the used
        for(auto x:s)cnt[x-'a']++;  // loop for x
        string ans="";  // variable to store the ans
        for(auto x:s){  // loop for x
            cnt[x-'a']--;  // decrement the cnt[x-'a']
            if(used[x-'a'])continue;  // if used[x-'a'] is true continue
            while(ans.size() && ans.back()>x && cnt[ans.back()-'a']){  // loop until ans.size() is not equal to 0 and ans.back() is greater than x and cnt[ans.back()-'a'] is not equal to 0
                used[ans.back()-'a']=false;  // update the used[ans.back()-'a']
                ans.pop_back();  // pop the ans
            }
            ans+=x;  // update the ans
            used[x-'a']=true;  // update the used[x-'a']
        }
        return ans;  // return the ans
    }
};

316. Remove Duplicate Letters in java

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
    public String removeDuplicateLetters(String s) {
        int[] cnt = new int[26];  // vector to store the cnt
        boolean[] used = new boolean[26];  // vector to store the used
        for(char x:s.toCharArray())cnt[x-'a']++;  // loop for x
        String ans="";  // variable to store the ans
        for(char x:s.toCharArray()){  // loop for x
            cnt[x-'a']--;  // decrement the cnt[x-'a']
            if(used[x-'a'])continue;  // if used[x-'a'] is true continue
            while(ans.length()>0 && ans.charAt(ans.length()-1)>x && cnt[ans.charAt(ans.length()-1)-'a']>0){  // loop until ans.size() is not equal to 0 and ans.back() is greater than x and cnt[ans.back()-'a'] is not equal to 0
                used[ans.charAt(ans.length()-1)-'a']=false;  // update the used[ans.back()-'a']
                ans=ans.substring(0,ans.length()-1);  // pop the ans
            }
            ans+=x;  // update the ans
            used[x-'a']=true;  // update the used[x-'a']
        }
        return ans;  // return the ans
    }
}

316. Remove Duplicate Letters in python

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution(object):
    def removeDuplicateLetters(self, s):
        """
        :type s: str
        :rtype: str
        """
        cnt = collections.Counter(s)  # vector to store the cnt
        used = collections.defaultdict(bool)  # vector to store the used
        ans = ""  # variable to store the ans
        for x in s:  # loop for x
            cnt[x] -= 1  # decrement the cnt[x-'a']
            if used[x]: continue  # if used[x-'a'] is true continue
            while ans and ans[-1] > x and cnt[ans[-1]]:  # loop until ans.size() is not equal to 0 and ans.back() is greater than x and cnt[ans.back()-'a'] is not equal to 0
                used[ans[-1]] = False  # update the used[ans.back()-'a']
                ans = ans[:-1]  # pop the ans
            ans += x  # update the ans
            used[x] = True  # update the used[x-'a']
        return ans  # return the ans

316. Remove Duplicate Letters in python3

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        cnt = collections.Counter(s)  # vector to store the cnt
        used = collections.defaultdict(bool)  # vector to store the used
        ans = ""  # variable to store the ans
        for x in s:  # loop for x
            cnt[x] -= 1  # decrement the cnt[x-'a']
            if used[x]: continue  # if used[x-'a'] is true continue
            while ans and ans[-1] > x and cnt[ans[-1]]:  # loop until ans.size() is not equal to 0 and ans.back() is greater than x and cnt[ans.back()-'a'] is not equal to 0
                used[ans[-1]] = False  # update the used[ans.back()-'a']
                ans = ans[:-1]  # pop the ans
            ans += x  # update the ans
            used[x] = True  # update the used[x-'a']
        return ans  # return the ans

316. Remove Duplicate Letters in c

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

char * removeDuplicateLetters(char * s){
    int cnt[26];  // vector to store the cnt
    bool used[26];  // vector to store the used
    memset(cnt,0,sizeof(cnt));  // memset the cnt
    memset(used,false,sizeof(used));  // memset the used
    int n = strlen(s);  // variable to store the n
    for(int i=0; i<n; i++)cnt[s[i]-'a']++;  // loop for i
    char *ans = (char*)malloc(sizeof(char)*n);  // variable to store the ans
    int top = -1;  // variable to store the top
    for(int i=0; i<n; i++){  // loop for i
        cnt[s[i]-'a']--;  // decrement the cnt[x-'a']
        if(used[s[i]-'a'])continue;  // if used[x-'a'] is true continue
        while(top!=-1 && ans[top]>s[i] && cnt[ans[top]-'a']){  // loop until ans.size() is not equal to 0 and ans.back() is greater than x and cnt[ans.back()-'a'] is not equal to 0
            used[ans[top]-'a']=false;  // update the used[ans.back()-'a']
            top--;  // pop the ans
        }
        ans[++top]=s[i];  // update the ans
        used[s[i]-'a']=true;  // update the used[x-'a']
    }
    ans[++top]='\0';  // update the ans
    return ans;  // return the ans
}

316. Remove Duplicate Letters in c#

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

public class Solution {
    public string RemoveDuplicateLetters(string s) {
        int[] cnt = new int[26];  // vector to store the cnt
        bool[] used = new bool[26];  // vector to store the used
        foreach(char x in s)cnt[x-'a']++;  // loop for x
        string ans="";  // variable to store the ans
        foreach(char x in s){  // loop for x
            cnt[x-'a']--;  // decrement the cnt[x-'a']
            if(used[x-'a'])continue;  // if used[x-'a'] is true continue
            while(ans.Length>0 && ans[ans.Length-1]>x && cnt[ans[ans.Length-1]-'a']>0){  // loop until ans.size() is not equal to 0 and ans.back() is greater than x and cnt[ans.back()-'a'] is not equal to 0
                used[ans[ans.Length-1]-'a']=false;  // update the used[ans.back()-'a']
                ans=ans.Substring(0,ans.Length-1);  // pop the ans
            }
            ans+=x;  // update the ans
            used[x-'a']=true;  // update the used[x-'a']
        }
        return ans;  // return the ans
    }
}

316. Remove Duplicate Letters in Javascript

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

var removeDuplicateLetters = function(s) {
    let cnt = new Array(26).fill(0);  // vector to store the cnt
    let used = new Array(26).fill(false);  // vector to store the used
    for(let x of s)cnt[x.charCodeAt(0)-'a'.charCodeAt(0)]++;  // loop for x
    let ans="";  // variable to store the ans
    for(let x of s){  // loop for x
        cnt[x.charCodeAt(0)-'a'.charCodeAt(0)]--;  // decrement the cnt[x-'a']
        if(used[x.charCodeAt(0)-'a'.charCodeAt(0)])continue;  // if used[x-'a'] is true continue
        while(ans.length>0 && ans[ans.length-1]>x && cnt[ans[ans.length-1].charCodeAt(0)-'a'.charCodeAt(0)]>0){  // loop until ans.size() is not equal to 0 and ans.back() is greater than x and cnt[ans.back()-'a'] is not equal to 0
            used[ans[ans.length-1].charCodeAt(0)-'a'.charCodeAt(0)]=false;  // update the used[ans.back()-'a']
            ans=ans.substring(0,ans.length-1);  // pop the ans
        }
        ans+=x;  // update the ans
        used[x.charCodeAt(0)-'a'.charCodeAt(0)]=true;  // update the used[x-'a']
    }
    return ans;  // return the ans
};

316. Remove Duplicate Letters in Swift

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
    func removeDuplicateLetters(_ s: String) -> String {
        var cnt = Array(repeating: 0, count: 26);  // vector to store the cnt
        var used = Array(repeating: false, count: 26);  // vector to store the used
        for x in s{cnt[Int(x.asciiValue!-Character("a").asciiValue!)]+=1;}  // loop for x
        var ans="";  // variable to store the ans
        for x in s{  // loop for x
            cnt[Int(x.asciiValue!-Character("a").asciiValue!)]-=1;  // decrement the cnt[x-'a']
            if(used[Int(x.asciiValue!-Character("a").asciiValue!)]){continue;}  // if used[x-'a'] is true continue
            while ans.count>0 && ans.last!>x && cnt[Int(ans.last!.asciiValue!-Character("a").asciiValue!)]>0{  // loop until ans.size() is not equal to 0 and ans.back() is greater than x and cnt[ans.back()-'a'] is not equal to 0
                used[Int(ans.last!.asciiValue!-Character("a").asciiValue!)]=false;  // update the used[ans.back()-'a']
                ans.removeLast();  // pop the ans
            }
            ans+=String(x);  // update the ans
            used[Int(x.asciiValue!-Character("a").asciiValue!)]=true;  // update the used[x-'a']
        }
        return ans;  // return the ans
    }
}

316. Remove Duplicate Letters in Dart

// Time Complexity : O(n) where n is the length of the vector nums and space complexity is O(1)

class Solution {
  String removeDuplicateLetters(String s) {
    List<int> cnt = List.filled(26, 0);  // vector to store the cnt
    List<bool> used = List.filled(26, false);  // vector to store the used
    for (int i = 0; i < s.length; i++) {cnt[s[i].codeUnitAt(0) - 'a'.codeUnitAt(0)]++;}  // loop for x
    String ans = "";  // variable to store the ans
    for (int i = 0; i < s.length; i++) {  // loop for x
      cnt[s[i].codeUnitAt(0) - 'a'.codeUnitAt(0)]--;  // decrement the cnt[x-'a']
      if (used[s[i].codeUnitAt(0) - 'a'.codeUnitAt(0)]) {continue;}  // if used[x-'a'] is true continue
      while (ans.length > 0 && ans[ans.length - 1] > s[i] && cnt[ans[ans.length - 1].codeUnitAt(0) - 'a'.codeUnitAt(0)] > 0) {  // loop until ans.size() is not equal to 0 and ans.back() is greater than x and cnt[ans.back()-'a'] is not equal to 0
        used[ans[ans.length - 1].codeUnitAt(0) - 'a'.codeUnitAt(0)] = false;  // update the used[ans.back()-'a']
        ans = ans.substring(0, ans.length - 1);  // pop the ans
      }
      ans += s[i];  // update the ans
      used[s[i].codeUnitAt(0) - 'a'.codeUnitAt(0)] = true;  // update the used[x-'a']
    }
    return ans;  // return the ans
  }
}

949. Largest Time for Given Digits in c++

// Time Complexity : O(1) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    string largestTimeFromDigits(vector<int>& arr){
        string ans=""; // variable to store the ans
        sort(arr.begin(),arr.end()); // sort the arr
        do{ // do while loop
            string h=to_string(arr[0])+to_string(arr[1]); // variable to store the h
            string m=to_string(arr[2])+to_string(arr[3]); // variable to store the m
            if(h<"24" && m<"60")ans=h+":"+m; // if h is less than 24 and m is less than 60 update the ans
        }while(next_permutation(arr.begin(),arr.end())); // next_permutation
        return ans; // return the ans
    }
};

949. Largest Time for Given Digits in java

// Time Complexity : O(1) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public String largestTimeFromDigits(int[] arr) {
        String ans=""; // variable to store the ans
        Arrays.sort(arr); // sort the arr
        do{ // do while loop
            String h=String.valueOf(arr[0])+String.valueOf(arr[1]); // variable to store the h
            String m=String.valueOf(arr[2])+String.valueOf(arr[3]); // variable to store the m
            if(h.compareTo("24")<0 && m.compareTo("60")<0)ans=h+":"+m; // if h is less than 24 and m is less than 60 update the ans
        }while(next_permutation(arr)); // next_permutation
        return ans; // return the ans
    }

public boolean next_permutation(int[] arr){
    int n=arr.length; // variable to store the size of the arr
    int i=n-2; // variable to store the i
    while(i>=0 && arr[i]>=arr[i+1])i--; // loop until i is greater than or equal to 0 and arr[i] is greater than or equal to arr[i+1]
    if(i<0)return false; // if i is less than 0 return false
    int j=n-1; // variable to store the j
    while(arr[j]<=arr[i])j--; // loop until arr[j] is less than or equal to arr[i]
    swap(arr,i,j); // swap the arr[i] and arr[j]
    reverse(arr,i+1,n-1); // reverse the arr
    return true; // return true
}
public void swap(int[] arr,int i,int j){
    int temp=arr[i]; // variable to store the temp
    arr[i]=arr[j]; // update the arr[i]
    arr[j]=temp; // update the arr[j]
}
public void reverse(int[] arr,int i,int j){
    while(i<j){ // loop until i is less than j
        swap(arr,i,j); // swap the arr[i] and arr[j]
        i++; // increment the i
        j--; // decrement the j
    }
  }
}

949. Largest Time for Given Digits in python

// Time Complexity : O(1) where n is the size of the vector nums and space complexity is O(1)

class Solution(object):
    def largestTimeFromDigits(self, arr):
        """
        :type arr: List[int]
        :rtype: str
        """
        ans="" # variable to store the ans
        arr.sort() # sort the arr
        def next_permutation(arr): # function to find the next permutation
            n=len(arr) # variable to store the size of the arr
            i=n-2 # variable to store the i
            while i>=0 and arr[i]>=arr[i+1]:i-=1 # loop until i is greater than or equal to 0 and arr[i] is greater than or equal to arr[i+1]
            if i<0:return False # if i is less than 0 return false
            j=n-1 # variable to store the j
            while arr[j]<=arr[i]:j-=1 # loop until arr[j] is less than or equal to arr[i]
            arr[i],arr[j]=arr[j],arr[i] # swap the arr[i] and arr[j]
            arr[i+1:]=arr[i+1:][::-1] # reverse the arr
            return True # return true
        while next_permutation(arr): # next_permutation
            h=str(arr[0])+str(arr[1]) # variable to store the h
            m=str(arr[2])+str(arr[3]) # variable to store the m
            if h<"24" and m<"60":ans=h+":"+m # if h is less than 24 and m is less than 60 update the ans
        return ans # return the ans

949. Largest Time for Given Digits in python3

// Time Complexity : O(1) where n is the size of the vector nums and space complexity is O(1)

class Solution:
    def largestTimeFromDigits(self, arr: List[int]) -> str:
        ans="" # variable to store the ans
        arr.sort() # sort the arr
        def next_permutation(arr): # function to find the next permutation
            n=len(arr) # variable to store the size of the arr
            i=n-2 # variable to store the i
            while i>=0 and arr[i]>=arr[i+1]:i-=1 # loop until i is greater than or equal to 0 and arr[i] is greater than or equal to arr[i+1]
            if i<0:return False # if i is less than 0 return false
            j=n-1 # variable to store the j
            while arr[j]<=arr[i]:j-=1 # loop until arr[j] is less than or equal to arr[i]
            arr[i],arr[j]=arr[j],arr[i] # swap the arr[i] and arr[j]
            arr[i+1:]=arr[i+1:][::-1] # reverse the arr
            return True # return true
        while next_permutation(arr): # next_permutation
            h=str(arr[0])+str(arr[1]) # variable to store the h
            m=str(arr[2])+str(arr[3]) # variable to store the m
            if h<"24" and m<"60":ans=h+":"+m # if h is less than 24 and m is less than 60 update the ans
        return ans # return the ans

949. Largest Time for Given Digits in c

// Time Complexity : O(1) where n is the size of the vector nums and space complexity is O(1)

char * largestTimeFromDigits(int* arr, int arrSize){
    char *ans=(char*)malloc(sizeof(char)*6); // variable to store the ans
    memset(ans,'\0',sizeof(ans)); // memset the ans
    qsort(arr,arrSize,sizeof(int),cmp); // sort the arr
    do{ // do while loop
        char h[3]; // variable to store the h
        char m[3]; // variable to store the m
        sprintf(h,"%d%d",arr[0],arr[1]); // update the h
        sprintf(m,"%d%d",arr[2],arr[3]); // update the m
        if(strcmp(h,"24")<0 && strcmp(m,"60")<0)sprintf(ans,"%s:%s",h,m); // if h is less than 24 and m is less than 60 update the ans
    }while(next_permutation(arr,arr+arrSize)); // next_permutation
    return ans; // return the ans
}

int cmp(const void *a,const void *b){ // function to compare
    return *(int*)a-*(int*)b; // return the compare
}

949. Largest Time for Given Digits in c#

// Time Complexity : O(1) where n is the size of the vector nums and space complexity is O(1)

public class Solution {
    public string LargestTimeFromDigits(int[] arr) {
        string ans=""; // variable to store the ans
        Array.Sort(arr); // sort the arr
        do{ // do while loop
            string h=arr[0].ToString()+arr[1].ToString(); // variable to store the h
            string m=arr[2].ToString()+arr[3].ToString(); // variable to store the m
            if(h.CompareTo("24")<0 && m.CompareTo("60")<0)ans=h+":"+m; // if h is less than 24 and m is less than 60 update the ans
        }while(next_permutation(arr)); // next_permutation
        return ans; // return the ans
    }

public bool next_permutation(int[] arr){
    int n=arr.Length; // variable to store the size of the arr
    int i=n-2; // variable to store the i
    while(i>=0 && arr[i]>=arr[i+1])i--; // loop until i is greater than or equal to 0 and arr[i] is greater than or equal to arr[i+1]
    if(i<0)return false; // if i is less than 0 return false
    int j=n-1; // variable to store the j
    while(arr[j]<=arr[i])j--; // loop until arr[j] is less than or equal to arr[i]
    swap(arr,i,j); // swap the arr[i] and arr[j]
    reverse(arr,i+1,n-1); // reverse the arr
    return true; // return true
}

public void swap(int[] arr,int i,int j){
    int temp=arr[i]; // variable to store the temp
    arr[i]=arr[j]; // update the arr[i]
    arr[j]=temp; // update the arr[j]
}

public void reverse(int[] arr,int i,int j){
    while(i<j){ // loop until i is less than j
        swap(arr,i,j); // swap the arr[i] and arr[j]
        i++; // increment the i
        j--; // decrement the j
    }
  }
}

949. Largest Time for Given Digits in Javascript

// Time Complexity : O(1) where n is the size of the vector nums and space complexity is O(1)

var largestTimeFromDigits = function(arr) {
    let ans=""; // variable to store the ans
    arr.sort((a,b)=>a-b); // sort the arr
    function next_permutation(arr){ // function to find the next permutation
        let n=arr.length; // variable to store the size of the arr
        let i=n-2; // variable to store the i
        while(i>=0 && arr[i]>=arr[i+1])i--; // loop until i is greater than or equal to 0 and arr[i] is greater than or equal to arr[i+1]
        if(i<0)return false; // if i is less than 0 return false
        let j=n-1; // variable to store the j
        while(arr[j]<=arr[i])j--; // loop until arr[j] is less than or equal to arr[i]
        [arr[i],arr[j]]=[arr[j],arr[i]]; // swap the arr[i] and arr[j]
        arr.splice(i+1,n-i-1,...arr.slice(i+1).reverse()); // reverse the arr
        return true; // return true
    }
    while(next_permutation(arr)){ // next_permutation
        let h=arr[0].toString()+arr[1].toString(); // variable to store the h
        let m=arr[2].toString()+arr[3].toString(); // variable to store the m
        if(h<"24" && m<"60")ans=h+":"+m; // if h is less than 24 and m is less than 60 update the ans
    }
    return ans; // return the ans
};

949. Largest Time for Given Digits in Swift

// Time Complexity : O(1) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    func largestTimeFromDigits(_ arr: [Int]) -> String {
        var ans=""; // variable to store the ans
        var arr=arr.sorted() // sort the arr
        func next_permutation(_ arr: inout [Int]) -> Bool{ // function to find the next permutation
            let n=arr.count; // variable to store the size of the arr
            var i=n-2; // variable to store the i
            while i>=0 && arr[i]>=arr[i+1]{i-=1;} // loop until i is greater than or equal to 0 and arr[i] is greater than or equal to arr[i+1]
            if i<0{return false;} // if i is less than 0 return false
            var j=n-1; // variable to store the j
            while arr[j]<=arr[i]{j-=1;} // loop until arr[j] is less than or equal to arr[i]
            arr.swapAt(i,j); // swap the arr[i] and arr[j]
            arr[i+1...].reverse(); // reverse the arr
            return true; // return true
        }
        while next_permutation(&arr){ // next_permutation
            let h=String(arr[0])+String(arr[1]); // variable to store the h
            let m=String(arr[2])+String(arr[3]); // variable to store the m
            if h<"24" && m<"60"{ans=h+":"+m;} // if h is less than 24 and m is less than 60 update the ans
        }
        return ans; // return the ans
    }
}

949. Largest Time for Given Digits in Dart

// Time Complexity : O(1) where n is the size of the vector nums and space complexity is O(1)

class Solution {
  String largestTimeFromDigits(List<int> arr) {
    String ans=""; // variable to store the ans
    arr.sort(); // sort the arr
    bool next_permutation(List<int> arr){ // function to find the next permutation
      int n=arr.length; // variable to store the size of the arr
      int i=n-2; // variable to store the i
      while(i>=0 && arr[i]>=arr[i+1])i--; // loop until i is greater than or equal to 0 and arr[i] is greater than or equal to arr[i+1]
      if(i<0)return false; // if i is less than 0 return false
      int j=n-1; // variable to store the j
      while(arr[j]<=arr[i])j--; // loop until arr[j] is less than or equal to arr[i]
      swap(arr,i,j); // swap the arr[i] and arr[j]
      reverse(arr,i+1,n-1); // reverse the arr
      return true; // return true
    }
    while(next_permutation(arr)){ // next_permutation
      String h=arr[0].toString()+arr[1].toString(); // variable to store the h
      String m=arr[2].toString()+arr[3].toString(); // variable to store the m
      if(h.compareTo("24")<0 && m.compareTo("60")<0)ans=h+":"+m; // if h is less than 24 and m is less than 60 update the ans
    }
    return ans; // return the ans
  }
  void swap(List<int> arr,int i,int j){
    int temp=arr[i]; // variable to store the temp
    arr[i]=arr[j]; // update the arr[i]
    arr[j]=temp; // update the arr[j]
  }
  void reverse(List<int> arr,int i,int j){
    while(i<j){ // loop until i is less than j
      swap(arr,i,j); // swap the arr[i] and arr[j]
      i++; // increment the i
      j--; // decrement the j
    }
  }
}

557. Reverse Words in a String III in c++

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    string reverseWords(string s) { // function to reverse the words
        int n=s.size(); // variable to store the size of the string
        int i=0; // variable to store the i
        for(int j=0;j<=n;j++){ // loop until j is less than or equal to n
            if(j==n || s[j]==' '){ // if j is equal to n or s[j] is equal to ' '
                reverse(s.begin()+i,s.begin()+j); // reverse the s
                i=j+1; // update the i
            }
        }
        return s; // return the s
    }
};

557. Reverse Words in a String III in java

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public String reverseWords(String s) { // function to reverse the words
        int n=s.length(); // variable to store the size of the string
        int i=0; // variable to store the i
        for(int j=0;j<=n;j++){ // loop until j is less than or equal to n
            if(j==n || s.charAt(j)==' '){ // if j is equal to n or s[j] is equal to ' '
                s=s.substring(0,i)+new StringBuilder(s.substring(i,j)).reverse().toString()+s.substring(j); // reverse the s
                i=j+1; // update the i
            }
        }
        return s; // return the s
    }
}

// OR 

class Solution {
    public String reverseWords(String s) { // function to reverse the words
        String[] arr=s.split(" "); // split the s
        for(int i=0;i<arr.length;i++)arr[i]=new StringBuilder(arr[i]).reverse().toString(); // loop for i
        return String.join(" ",arr); // return the s
    }
}

557. Reverse Words in a String III in python

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution(object):
    def reverseWords(self, s):
        """
        :type s: str
        :rtype: str
        """
        s=s.split() # split the s
        for i in range(len(s)):s[i]=s[i][::-1] # loop for i
        return " ".join(s) # return the s

557. Reverse Words in a String III in python3

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution:
    def reverseWords(self, s: str) -> str:
        s=s.split() # split the s
        for i in range(len(s)):s[i]=s[i][::-1] # loop for i
        return " ".join(s) # return the s

557. Reverse Words in a String III in c

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

#include <string.h> // Include the string.h header for strlen

void reverse(char *s, int n); // Function declaration for reverse

char * reverseWords(char *s) {
    int n = strlen(s);
    int i = 0;
    for (int j = 0; j <= n; j++) {
        if (j == n || s[j] == ' ') {
            reverse(s + i, j - i); // Reverse only a part of the string
            i = j + 1;
        }
    }
    return s;
}

void reverse(char *s, int n) {
    for (int i = 0; i < n / 2; i++) {
        char temp = s[i];
        s[i] = s[n - i - 1];
        s[n - i - 1] = temp;
    }
}


557. Reverse Words in a String III in c#

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

public class Solution {
    public string ReverseWords(string s) { // function to reverse the words
        string[] arr=s.Split(); // split the s
        for(int i=0;i<arr.Length;i++)arr[i]=new string(arr[i].Reverse().ToArray()); // loop for i
        return string.Join(" ",arr); // return the s
    }
}

557. Reverse Words in a String III in Javascript

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

var reverseWords = function(s) {
    s=s.split(" "); // split the s
    for(let i=0;i<s.length;i++)s[i]=s[i].split("").reverse().join(""); // loop for i
    return s.join(" "); // return the s
};

557. Reverse Words in a String III in Swift

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    func reverseWords(_ s: String) -> String {
        var words = s.split(separator: " ").map { String($0.reversed()) } // Split and reverse words
        return words.joined(separator: " ") // Join the reversed words
    }
}

557. Reverse Words in a String III in Dart

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
  String reverseWords(String s) {
    List<String> words = s.split(" "); // Split the input string into words
    for (int i = 0; i < words.length; i++) {
      String word = words[i];
      words[i] = String.fromCharCodes(word.runes.toList().reversed); // Reverse each word
    }
    return words.join(" "); // Join the reversed words with spaces
  }
}

84. Largest Rectangle in Histogram in c++

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(n)

class Solution {
public:
    int largestRectangleArea(vector<int>& heights) { // function to find the largest rectangle area
        int n=heights.size(); // variable to store the size of the heights
        vector<int>left(n),right(n); // vector to store the left and right
        stack<int>s; // stack to store the int
        for(int i=0;i<n;i++){ // loop for i
            while(!s.empty() && heights[s.top()]>=heights[i])s.pop(); // loop until s is not empty and heights[s.top()] is greater than or equal to heights[i]
            if(s.empty())left[i]=0; // if s is empty update the left[i]
            else left[i]=s.top()+1; // else update the left[i]
            s.push(i); // push the i
        }
     // loop until s is not empty
        for(int i=n-1;i>=0;i--){ // loop for i
            while(!s.empty() && heights[s.top()]>=heights[i])s.pop(); // loop until s is not empty and heights[s.top()] is greater than or equal to heights[i]
            if(s.empty())right[i]=n-1; // if s is empty update the right[i]
            else right[i]=s.top()-1; // else update the right[i]
            s.push(i); // push the i
        }
        int ans=0; // variable to store the ans
        for(int i=0;i<n;i++)ans=max(ans,(right[i]-left[i]+1)*heights[i]); // loop for i
        // The +1 is used because it's calculating the width of the rectangle formed by right[i] and left[i] and, in this context, 
        // it's necessary to include the current element as well. So, you add 1 to account for the width that includes the current element.
        // The usage of +1 or -1 depends on the specific context and how the algorithm is structured to calculate the width of the rectangle correctly. 
        // In one case, it's used to exclude the current element, and in the other case, it's used to include the current element in the width calculation.
        return ans; // return the ans
    }
};

// OR 

class Solution {
public:
    int largestRectangleArea(vector<int>& heights) { // function to find the largest rectangle area
        int n=heights.size(); // variable to store the size of the heights
        stack<int>s; // stack to store the int
        int ans=0; // variable to store the ans
        for(int i=0;i<=n;i++){ // loop for i
            while(!s.empty() && (i==n || heights[s.top()]>=heights[i])){ // loop until s is not empty and (i is equal to n or heights[s.top()] is greater than or equal to heights[i])
                int h=heights[s.top()]; // variable to store the h
                s.pop(); // pop the s
                int w; // variable to store the w
                if(s.empty())w=i; // if s is empty update the w
                else w=i-s.top()-1; // else update the w
                ans=max(ans,h*w); // update the ans
            }
            s.push(i); // push the i
        }
        return ans; // return the ans
    }
};

// OR

class Solution {
public:
    int largestRectangleArea(vector<int>& heights) { // function to find the largest rectangle area
        int n=heights.size(); // variable to store the size of the heights
        vector<int> nextSmaller(n , n); // vector to store the nextSmaller
        vector<int> prevSmaller(n , -1); // vector to store the prevSmaller
        stack<int>s; // stack to store the int
        for(int i=0;i<n;i++){ // loop for i
            while(!s.empty() && heights[s.top()]>heights[i]){ // loop until s is not empty and heights[s.top()] is greater than heights[i]
                nextSmaller[s.top()]=i; // update the nextSmaller
                s.pop(); // pop the s
            }
            s.push(i); // push the i
        }
       if(!s.empty()) prevSmaller[i] = st.top(); // if s is not empty update the prevSmaller
        st.push(i); // push the i
    }

        int ans=0; // variable to store the ans
        for(int i=0;i<n;i++){ // loop for i
            int width=nextSmaller[i]-prevSmaller[i]-1; // variable to store the width
            // Here, you calculate the width of the rectangle using nextSmaller[i] - previousSmaller[i] - 1. 
            // The -1 is used because it's subtracting the index of the previous smaller element from the index of the next smaller element,
            // and this width calculation doesn't include the current element itself, 
            // so you subtract 1 to account for the width between the two neighboring smaller elements.
            int area=width*heights[i]; // variable to store the area
            ans=max(ans,area); // update the ans
        }
        return ans; // return the ans
};










2305. Fair Distribution of Cookies in c++

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    void helper(vector<int>& cookies, int k, vector<int>& temp, int index, int& ans) { // function to find the helper
        if (temp.size() == k) { // if temp.size() is equal to k
            int maxDiff = INT_MIN; // variable to store the maxDiff
            int minDiff = INT_MAX; // variable to store the minDiff
            for (int i = 0; i < temp.size(); i++) { // loop for i
                for (int j = i + 1; j < temp.size(); j++) { // loop for j
                    maxDiff = max(maxDiff, abs(temp[i] - temp[j])); // update the maxDiff
                    minDiff = min(minDiff, abs(temp[i] - temp[j])); // update the minDiff
                }
            }
            ans = min(ans, maxDiff - minDiff); // update the ans
            return;
        }
        for (int i = index; i < cookies.size(); i++) { // loop for i
            temp.push_back(cookies[i]); // push the cookies[i]
            helper(cookies, k, temp, i + 1, ans); // helper
            temp.pop_back(); // pop the temp
        }
    }
    int distributeCookies(vector<int>& cookies, int k) {
        int ans = INT_MAX;
        vector<int> temp;
        helper(cookies, k, temp, 0, ans);
        return ans;
        
    }
};







78. Subsets in c++

// Time Complexity : O(n*2^n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) { // function to find the subsets
        int n=nums.size(); // variable to store the size of the nums
        vector<vector<int>>ans; // vector to store the ans
        for(int i=0;i<(1<<n);i++){ // loop for i
            vector<int>temp; // vector to store the temp
            for(int j=0;j<n;j++){ // loop for j
                if(i&(1<<j))temp.push_back(nums[j]); // if i&(1<<j) push the nums[j]
            }
            ans.push_back(temp); // push the temp
        }
        return ans; // return the ans
    }
};

// OR

class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) { // function to find the subsets
        int n=nums.size(); // variable to store the size of the nums
        vector<vector<int>>ans; // vector to store the ans
        vector<int>temp; // vector to store the temp
        helper(nums,ans,temp,0); // helper
        return ans; // return the ans
    }
    void helper(vector<int>& nums,vector<vector<int>>& ans,vector<int>& temp,int index){ // function to find the helper
        ans.push_back(temp); // push the temp
        for(int i=index;i<nums.size();i++){ // loop for i
            temp.push_back(nums[i]); // push the nums[i]
            helper(nums,ans,temp,i+1); // helper
            temp.pop_back(); // pop the temp
        }
    }
};

// OR

class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) { // function to find the subsets
        int n=nums.size(); // variable to store the size of the nums
        vector<vector<int>>ans; // vector to store the ans
        vector<int>temp; // vector to store the temp
        helper(nums,ans,temp,0); // helper
        return ans; // return the ans
    }
    void helper(vector<int>& nums,vector<vector<int>>& ans,vector<int>& temp,int index){ // function to find the helper
        if(index==nums.size()){ // if index is equal to nums.size()
            ans.push_back(temp); // push the temp
            return;
        }
        temp.push_back(nums[index]); // push the nums[index]
        helper(nums,ans,temp,index+1); // helper
        temp.pop_back(); // pop the temp
        helper(nums,ans,temp,index+1); // helper
    }
};




90. Subsets II

// Time Complexity : O(n*2^n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) { // function to find the subsetsWithDup
        int n=nums.size(); // variable to store the size of the nums
        vector<vector<int>>ans; // vector to store the ans
        sort(nums.begin(),nums.end()); // sort the nums
        for(int i=0;i<(1<<n);i++){ // loop for i
            vector<int>temp; // vector to store the temp
            bool flag=true; // variable to store the flag
            for(int j=0;j<n;j++){ // loop for j
                if(i&(1<<j)){ // if i&(1<<j)
                    if(j>0 && nums[j]==nums[j-1] && !(i&(1<<(j-1)))){ // if j is greater than 0 and nums[j] is equal to nums[j-1] and !(i&(1<<(j-1)))
                        flag=false; // update the flag
                        break; // break
                    }
                    temp.push_back(nums[j]); // push the nums[j]
                }
            }
            if(flag)ans.push_back(temp); // if flag is true push the temp
        }
        return ans; // return the ans
    }
};


// OR

class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) { // function to find the subsetsWithDup
        int n=nums.size(); // variable to store the size of the nums
        vector<vector<int>>ans; // vector to store the ans
        vector<int>temp; // vector to store the temp
        sort(nums.begin(),nums.end()); // sort the nums
        helper(nums,ans,temp,0); // helper
        return ans; // return the ans
    }
    void helper(vector<int>& nums,vector<vector<int>>& ans,vector<int>& temp,int index){ // function to find the helper
        ans.push_back(temp); // push the temp
        for(int i=index;i<nums.size();i++){ // loop for i
            if(i>index && nums[i]==nums[i-1])continue; // if i is greater than index and nums[i] is equal to nums[i-1] continue
            temp.push_back(nums[i]); // push the nums[i]
            helper(nums,ans,temp,i+1); // helper
            temp.pop_back(); // pop the temp
        }
    }
};

// OR

class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) { // function to find the subsetsWithDup
        int n=nums.size(); // variable to store the size of the nums
        vector<vector<int>>ans; // vector to store the ans
        vector<int>temp; // vector to store the temp
        sort(nums.begin(),nums.end()); // sort the nums
        helper(nums,ans,temp,0); // helper
        return ans; // return the ans
    }
    void helper(vector<int>& nums,vector<vector<int>>& ans,vector<int>& temp,int index){ // function to find the helper
        if(index==nums.size()){ // if index is equal to nums.size()
            ans.push_back(temp); // push the temp
            return;
        }
        temp.push_back(nums[index]); // push the nums[index]
        helper(nums,ans,temp,index+1); // helper
        temp.pop_back(); // pop the temp
        while(index+1<nums.size() && nums[index]==nums[index+1])index++; // loop until index+1 is less than nums.size() and nums[index] is equal to nums[index+1]
        helper(nums,ans,temp,index+1); // helper
    }
};








79. Word Search in c++

// Time Complexity : O(n*m*4^l) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) { // function to find the exist
        int n=board.size(); // variable to store the size of the board
        int m=board[0].size(); // variable to store the size of the board
        for(int i=0;i<n;i++){ // loop for i
            for(int j=0;j<m;j++){ // loop for j
                if(board[i][j]==word[0] && dfs(board,word,i,j,0))return true; // if board[i][j] is equal to word[0] and dfs(board,word,i,j,0) return true
            }
        }
        return false; // return false
    }
    bool dfs(vector<vector<char>>& board,string word,int i,int j,int index){ // function to find the dfs
        if(index==word.size())return true; // if index is equal to word.size() return true
        if(i<0 || i>=board.size() || j<0 || j>=board[0].size() || board[i][j]!=word[index])return false; // if i is less than 0 or i is greater than or equal to board.size() or j is less than 0 or j is greater than or equal to board[0].size() or board[i][j] is not equal to word[index] return false
        char temp=board[i][j]; // variable to store the temp
        board[i][j]='*'; // update the board[i][j]
        bool found=dfs(board,word,i+1,j,index+1) || dfs(board,word,i-1,j,index+1) || dfs(board,word,i,j+1,index+1) || dfs(board,word,i,j-1,index+1); // variable to store the found
        board[i][j]=temp; // update the board[i][j]
        return found; // return the found
    }
};


// OR
// Time Complexity : O(n*m*4^l) where n is the size of the vector nums and space complexity is O(1)
#include <vector>
#include <string>

class Solution {
public:
    bool exist(std::vector<std::vector<char>>& board, std::string word) {
        int m = board.size();
        int n = board[0].size();
        
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (dfs(board, word, i, j, 0)) {
                    return true;
                }
            }
        }
        
        return false;
    }
private:
    bool dfs(std::vector<std::vector<char>>& board, std::string& word, int i, int j, int k) {
        if (i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || board[i][j] != word[k]) {
            return false;
        }
        
        if (k == word.size() - 1) {
            return true;
        }
        
        char temp = board[i][j];
        board[i][j] = '*';  // Mark the current cell as visited to avoid revisiting it
        
        // Explore adjacent cells in all four directions
        bool result = dfs(board, word, i - 1, j, k + 1) ||  // Up
                      dfs(board, word, i + 1, j, k + 1) ||  // Down
                      dfs(board, word, i, j - 1, k + 1) ||  // Left
                      dfs(board, word, i, j + 1, k + 1);    // Right
        
        board[i][j] = temp;  // Restore the cell to its original state
        
        return result;
    }
};



89. Gray Code in c++

// Time Complexity : O(n*2^n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    vector<int> grayCode(int n) { // function to find the grayCode
        vector<int>ans; // vector to store the ans
        for(int i=0;i<(1<<n);i++){ // loop for i
            ans.push_back(i^(i>>1)); // push the i^(i>>1)
        }
        return ans; // return the ans
    }
};

// OR

class Solution {
public:
    vector<int> grayCode(int n) { // function to find the grayCode
        vector<int>ans; // vector to store the ans
        ans.push_back(0); // push the 0
        for(int i=0;i<n;i++){ // loop for i
            int size=ans.size(); // variable to store the size
            for(int j=size-1;j>=0;j--){ // loop for j
                ans.push_back(ans[j]|(1<<i)); // push the ans[j]|(1<<i)
            }
        }
        return ans; // return the ans
    }
};




126. Word Ladder II in c++

// Time Complexity : O(n*2^n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
  unordered_map<string , int> mp; // unordered_map to store the string and int
    vector<vector<string>> ans; // vector to store the ans
    string b; // variable to store the b for beginWord
    private:
    void  dfs(string word , vector<string>& seq){
        if(word == b){ // if word is equal to b
            reverse(seq.begin() , seq.end()); // reverse the seq
            ans.push_back(seq); // push the seq
            reverse(seq.begin() , seq.end()); // reverse the seq
            return;
        }
        int step = mp[word]; // variable to store the step
        for(int i = 0 ; i < word.size() ; i++){ // loop for i
            char original = word[i]; // variable to store the original
            for(char ch = 'a' ; ch <= 'z' ; ch++){ // loop for ch
                word[i] = ch; // update the word[i]
                if(mp.find(word) != mp.end() && mp[word] == step - 1){ // if mp.find(word) is not equal to mp.end() and mp[word] is equal to step-1
                    seq.push_back(word); // push the word
                    dfs(word , seq); // dfs
                    seq.pop_back(); // pop the seq
                }
            }
            word[i] = original; // update the word[i]
        }
    }
public:
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) { // function to find the findLadders
        unordered_set<string> st(wordList.begin() , wordList.end()); // unordered_set to store the string
        b = beginWord; // update the b
        queue<string> q; // queue to store the string
        q.push(beginWord); // push the beginWord
        mp[beginWord] = 1; // update the mp[beginWord]
        st.erase(beginWord); // erase the beginWord
        while(!q.empty()){ // loop until q is not empty
            string word = q.front(); // variable to store the word
            q.pop(); // pop the q
            int step = mp[word]; // variable to store the step
            if(word == endWord) break; // if word is equal to endWord break
            for(int i = 0 ; i < word.size() ; i++){ // loop for i
                char original = word[i]; // variable to store the original
                for(char ch = 'a' ; ch <= 'z' ; ch++){ // loop for ch
                    word[i] = ch; // update the word[i]
                    if(st.find(word) != st.end()){ // if st.find(word) is not equal to st.end()
                        mp[word] = step + 1; // update the mp[word]
                        q.push(word); // push the word
                        st.erase(word); // erase the word
                    }
                }
                word[i] = original; // update the word[i]
            }
        }
        if(mp.find(endWord) != mp.end()){ // if mp.find(endWord) is not equal to mp.end()
            vector<string> seq; // vector to store the seq
            seq.push_back(endWord); // push the endWord
            dfs(endWord , seq); // dfs
        }
        return ans; // return the ans
    }
};


        



767. Reorganize String in c++

// Time Complexity : O(N⋅logk) where n is the size of the vector nums and space complexity is O(k)


class Solution {
public:
    string reorganizeString(string s) { // function to reorganize the string
        int n=s.size(); // variable to store the size of the string
        unordered_map<char,int>mp; // unordered_map to store the char and int
        for(auto x:s)mp[x]++; // loop for x
        priority_queue<pair<int,char>>pq; // priority_queue to store the pair
        for(auto x:mp)pq.push({x.second,x.first}); // loop for x
        string ans=""; // variable to store the ans
        while(pq.size()>1){ // loop until pq.size is greater than 1
            auto x=pq.top(); // variable to store the top of the pq
            pq.pop(); // pop the pq
            auto y=pq.top(); // variable to store the top of the pq
            pq.pop(); // pop the pq
            ans+=x.second; // update the ans
            ans+=y.second; // update the ans
            if(x.first>1)pq.push({x.first-1,x.second}); // if x.first is greater than 1 push the pq
            if(y.first>1)pq.push({y.first-1,y.second}); // if y.first is greater than 1 push the pq
        }
        if(pq.size()==1){ // if pq.size is equal to 1
            if(pq.top().first>1)return ""; // if pq.top().first is greater than 1 return ""
            else ans+=pq.top().second; // else update the ans
        }
        return ans; // return the ans
    }
};

2nd Method using Approach 2: Counting and Odd/Even

// Time Complexity : O(N) where n is the size of the vector nums and space complexity is O(k)

class Solution {
public:
    string reorganizeString(string s) { // function to reorganize the string
        int n=s.size(); // variable to store the size of the string
        vector<int>mp(26); // vector to store the mp
        for(auto x:s)mp[x-'a']++; // loop for x
        int max=0; // variable to store the max
        int index=0; // variable to store the index
        for(int i=0;i<26;i++){ // loop until i is less than 26
            if(mp[i]>max){ // if mp[i] is greater than max
                max=mp[i]; // update the max
                index=i; // update the index
            }
        }
        if(max>(n+1)/2)return ""; // if max is greater than (n+1)/2 return ""
        string ans(n,' '); // variable to store the ans
        int i=0; // variable to store the i
        while(mp[index]>0){ // loop until mp[index] is greater than 0
            ans[i]=(char)(index+'a'); // update the ans
            i+=2; // increment the i
            mp[index]--; // decrement the mp[index]
        }
        for(int j=0;j<26;j++){ // loop until j is less than 26
            while(mp[j]>0){ // loop until mp[j] is greater than 0
                if(i>=n)i=1; // if i is greater than or equal to n update the i
                ans[i]=(char)(j+'a'); // update the ans
                i+=2; // increment the i
                mp[j]--; // decrement the mp[j]
            }
        }
        return ans; // return the ans
    }
};

767. Reorganize String in java

// Time Complexity : O(N⋅logk) where n is the size of the vector nums and space complexity is O(k)

class Solution {
    public String reorganizeString(String s) { // function to reorganize the string
        int n=s.length(); // variable to store the size of the string
        HashMap<Character,Integer>mp=new HashMap<>(); // HashMap to store the char and int
        for(int i=0;i<n;i++)mp.put(s.charAt(i),mp.getOrDefault(s.charAt(i),0)+1); // loop for i
        PriorityQueue<Pair<Integer,Character>>pq=new PriorityQueue<>((a,b)->b.getKey()-a.getKey()); // priority_queue to store the pair
        for(Map.Entry<Character,Integer>entry:mp.entrySet())pq.add(new Pair(entry.getValue(),entry.getKey())); // loop for entry
        StringBuilder ans=new StringBuilder(); // variable to store the ans
        while(pq.size()>1){ // loop until pq.size is greater than 1
            Pair<Integer,Character>x=pq.poll(); // variable to store the top of the pq
            Pair<Integer,Character>y=pq.poll(); // variable to store the top of the pq
            ans.append(x.getValue()); // update the ans
            ans.append(y.getValue()); // update the ans
            if(x.getKey()>1)pq.add(new Pair(x.getKey()-1,x.getValue())); // if x.getKey() is greater than 1 push the pq
            if(y.getKey()>1)pq.add(new Pair(y.getKey()-1,y.getValue())); // if y.getKey() is greater than 1 push the pq
        }
        if(pq.size()==1){ // if pq.size is equal to 1
            if(pq.peek().getKey()>1)return ""; // if pq.peek().getKey() is greater than 1 return ""
            else ans.append(pq.peek().getValue()); // else update the ans
        }
        return ans.toString(); // return the ans
    }
}

2nd Method using Approach 2: Counting and Odd/Even

// Time Complexity : O(N) where n is the size of the vector nums and space complexity is O(k)

class Solution {
    public String reorganizeString(String s) { // function to reorganize the string
        int n=s.length(); // variable to store the size of the string
        int[]mp=new int[26]; // vector to store the mp
        for(int i=0;i<n;i++)mp[s.charAt(i)-'a']++; // loop for i
        int max=0; // variable to store the max
        int index=0; // variable to store the index
        for(int i=0;i<26;i++){ // loop until i is less than 26
            if(mp[i]>max){ // if mp[i] is greater than max
                max=mp[i]; // update the max
                index=i; // update the index
            }
        }
        if(max>(n+1)/2)return ""; // if max is greater than (n+1)/2 return ""
        char[]ans=new char[n]; // variable to store the ans
        int i=0; // variable to store the i
        while(mp[index]>0){ // loop until mp[index] is greater than 0
            ans[i]=(char)(index+'a'); // update the ans
            i+=2; // increment the i
            mp[index]--; // decrement the mp[index]
        }
        for(int j=0;j<26;j++){ // loop until j is less than 26
            while(mp[j]>0){ // loop until mp[j] is greater than 0
                if(i>=n)i=1; // if i is greater than or equal to n update the i
                ans[i]=(char)(j+'a'); // update the ans
                i+=2; // increment the i
                mp[j]--; // decrement the mp[j]
            }
        }
        return new String(ans); // return the ans
    }
}




1356. Sort Integers by The Number of 1 Bits in c++

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    vector<int> sortByBits(vector<int>& arr) { // function to find the sortByBits
        sort(arr.begin(),arr.end(),[](int a,int b){ // sort the arr
            int x=__builtin_popcount(a); // variable to store the __builtin_popcount(a)
            int y=__builtin_popcount(b); // variable to store the __builtin_popcount(b)
            if(x==y)return a<b; // if x is equal to y return a<b
            return x<y; // return x<y
        });
        return arr; // return the arr
    }
};

// 2nd Method

class Solution
{
public:
    vector<int> sortByBits(vector<int> &arr)
    {
        auto comparator = [](int a, int b)
        {
            // int countA = __builtin_popcount(a);
            // int countB = __builtin_popcount(b);
            int countA = countBits(a);
            int countB = countBits(b);
            if (countA < countB)
                return true;
            else if (countA > countB)
                return false;
            else
                return a < b;
        };
        sort(arr.begin(), arr.end(), comparator);
        return arr;
    }

private:
    static int countBits(int num)
    {
        int count = 0;
        while (num > 0)
        {
            if (num & 1)
                count++;
            num >>= 1;
        }
        return count;
    }
};

1356. Sort Integers by The Number of 1 Bits in java

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)


class Solution {
    public int[] sortByBits(int[] arr) { // function to find the sortByBits
        Integer[]arr1=new Integer[arr.length]; // Integer[] to store the arr
        for(int i=0;i<arr.length;i++)arr1[i]=arr[i]; // loop for i
        Arrays.sort(arr1,(a,b)->{ // sort the arr
            int x=Integer.bitCount(a); // variable to store the Integer.bitCount(a)
            int y=Integer.bitCount(b); // variable to store the Integer.bitCount(b)
            if(x==y)return a-b; // if x is equal to y return a-b
            return x-y; // return x-y
        });
        for(int i=0;i<arr.length;i++)arr[i]=arr1[i]; // loop for i
        return arr; // return the arr
    }
}

// 2nd Method

import java.util.Arrays;

public class Solution {
    public int[] sortByBits(int[] arr) {
        Integer[] boxedArr = new Integer[arr.length];
        for (int i = 0; i < arr.length; i++) {
            boxedArr[i] = arr[i];
        }

        Arrays.sort(boxedArr, (a, b) -> {
            int countA = Integer.bitCount(a);
            int countB = Integer.bitCount(b);

            if (countA < countB) {
                return -1;
            } else if (countA > countB) {
                return 1;
            } else {
                return Integer.compare(a, b);
            }
        });

        for (int i = 0; i < boxedArr.length; i++) {
            arr[i] = boxedArr[i];
        }

        return arr;
    }
}






1921. Eliminate Maximum Number of Monsters in c++

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    int eliminateMaximum(vector<int>& dist, vector<int>& speed) { // function to find the eliminateMaximum
        int n=dist.size(); // variable to store the size of the dist
        vector<double>time(n); // vector to store the time
        for(int i=0;i<n;i++)time[i]=(double)dist[i]/speed[i]; // loop for i
        sort(time.begin(),time.end()); // sort the time
        int ans=0; // variable to store the ans
        for(int i=0;i<n;i++){ // loop for i
            if(time[i]<=i)return ans; // if time[i] is less than or equal to i return ans
            ans++; // increment the ans
        }
        return ans; // return the ans
    }
};

1921. Eliminate Maximum Number of Monsters in swift

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    func eliminateMaximum(_ dist: [Int], _ speed: [Int]) -> Int { // function to find the eliminateMaximum
        let n = dist.count // variable to store the size of the dist
        var time = [Double](repeating: 0.0, count: n) // vector to store the time
        for i in 0..<n { // loop for i
            time[i] = Double(dist[i]) / Double(speed[i]) // update the time[i]
        }
        time.sort() // sort the time
        var ans = 0 // variable to store the ans
        for i in 0..<n { // loop for i
            if time[i] <= Double(i) { // if time[i] is less than or equal to i
                return ans // return ans
            }
            ans += 1 // increment the ans
        }
        return ans // return the ans
    }
}


1768. Merge Strings Alternately in c++

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    string mergeAlternately(string word1, string word2) { // function to find the mergeAlternately
        int n=word1.size(); // variable to store the size of the word1
        int m=word2.size(); // variable to store the size of the word2
        string ans=""; // variable to store the ans
        int i=0; // variable to store the i
        int j=0; // variable to store the j
        while(i<n && j<m){ // loop until i is less than n and j is less than m
           if(i<n) ans.push_back(word1[i++]); // if i is less than n push the word1[i++]
            if(j<m) ans.push_back(word2[j++]); // if j is less than m push the word2[j++]
        }
        return ans; // return the ans
    }
};

1768. Merge Strings Alternately in swift

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    func mergeAlternately(_ word1: String, _ word2: String) -> String { // function to find the mergeAlternately
        let n = word1.count // variable to store the size of the word1
        let m = word2.count // variable to store the size of the word2
        var ans = "" // variable to store the ans
        var i = 0 // variable to store the i
        var j = 0 // variable to store the j
        while i < n && j < m { // loop until i is less than n and j is less than m
            if i < n { // if i is less than n
                ans.append(word1[word1.index(word1.startIndex, offsetBy: i)]) // append the word1[word1.index(word1.startIndex, offsetBy: i)]
                i += 1 // increment the i
            }
            if j < m { // if j is less than m
                ans.append(word2[word2.index(word2.startIndex, offsetBy: j)]) // append the word2[word2.index(word2.startIndex, offsetBy: j)]
                j += 1 // increment the j
            }
        }
        return ans // return the ans
    }
}

      

1679. Max Number of K-Sum Pairs in c++

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    int maxOperations(vector<int>& nums, int k) { // function to find the maxOperations
        int n=nums.size(); // variable to store the size of the nums
        sort(nums.begin(),nums.end()); // sort the nums
        int i=0; // variable to store the i
        int j=n-1; // variable to store the j
        int ans=0; // variable to store the ans
        while(i<j){ // loop until i is less than j
            if(nums[i]+nums[j]==k){ // if nums[i]+nums[j] is equal to k
                ans++; // increment the ans
                i++; // increment the i
                j--; // decrement the j
            }
            else if(nums[i]+nums[j]>k)j--; // else if nums[i]+nums[j] is greater than k decrement the j
            else i++; // else increment the i
        }
        return ans; // return the ans
    }
};

1679. Max Number of K-Sum Pairs in swift

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    func maxOperations(_ nums: [Int], _ k: Int) -> Int { // function to find the maxOperations
        let n = nums.count // variable to store the size of the nums
        var nums = nums.sorted() // sort the nums
        var i = 0 // variable to store the i
        var j = n - 1 // variable to store the j
        var ans = 0 // variable to store the ans
        while i < j { // loop until i is less than j
            if nums[i] + nums[j] == k { // if nums[i]+nums[j] is equal to k
                ans += 1 // increment the ans
                i += 1 // increment the i
                j -= 1 // decrement the j
            } else if nums[i] + nums[j] > k { // else if nums[i]+nums[j] is greater than k
                j -= 1 // decrement the j
            } else { // else
                i += 1 // increment the i
            }
        }
        return ans // return the ans
    }
}


1456. Maximum Number of Vowels in a Substring of Given Length in c++

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    int maxVowels(string s, int k) { // function to find the maxVowels
        int n=s.size(); // variable to store the size of the s
        int max_count=0; // variable to store the max_count
        int count=0; // variable to store the count
        for(int i=0;i<n;i++){ // loop for i
            if(i>=k && isVowel(s[i-k]))count--; // if i is greater than or equal to k and isVowel(s[i-k]) decrement the count
            if(isVowel(s[i]))count++; // if isVowel(s[i]) increment the count
            max_count=max(max_count,count); // update the max_count
        }
        return max_count; // return the max_count
    }
    bool isVowel(char ch){ // function to find the isVowel
        return ch=='a' || ch=='e' || ch=='i' || ch=='o' || ch=='u'; // return ch=='a' || ch=='e' || ch=='i' || ch=='o' || ch=='u'
    }
};

1456. Maximum Number of Vowels in a Substring of Given Length in swift

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    func maxVowels(_ s: String, _ k: Int) -> Int {
    var max = 0
    var arr = Array(s)
    var count = 0

    for i in 0..<arr.count{
        if (arr[i] == "a" || arr[i] == "e" || arr[i] == "i" || arr[i] == "o" || arr[i] == "u" ||
            arr[i] == "A" || arr[i] == "E" || arr[i] == "I" || arr[i] == "O" || arr[i] == "U") {
            count += 1
        }
        
        if i >= k {
            if (arr[i-k] == "a" || arr[i-k] == "e" || arr[i-k] == "i" || arr[i-k] == "o" || arr[i-k] == "u" ||
                arr[i-k] == "A" || arr[i-k] == "E" || arr[i-k] == "I" || arr[i-k] == "O" || arr[i-k] == "U") {
                count -= 1
            }
        }
        
        if count > max {
            max = count
            
        }
    }
    
    return max
}
}

1930. Unique Length-3 Palindromic Subsequences in c++

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    int countPalindromicSubsequence(string s) { // function to find the countPalindromicSubsequence
        int n=s.size(); // variable to store the size of the s
        vector<int>first(26,-1); // vector to store the first
        vector<int>last(26,-1); // vector to store the last
        for(int i=0;i<n;i++){ // loop for i
            if(first[s[i]-'a']==-1)first[s[i]-'a']=i; // if first[s[i]-'a'] is equal to -1 update the first[s[i]-'a']
            last[s[i]-'a']=i; // update the last[s[i]-'a']
        }
        int ans=0; // variable to store the ans
        for(int i=0;i<26;i++){ // loop for i
            if(first[i]!=-1 && last[i]!=-1 && first[i]!=last[i]){ // if first[i] is not equal to -1 and last[i] is not equal to -1 and first[i] is not equal to last[i]
                unordered_set<char>st; // unordered_set to store the char
                for(int j=first[i]+1;j<last[i];j++)st.insert(s[j]); // loop for j
                ans+=st.size(); // update the ans
            }
        }
        return ans; // return the ans
    }
};

1980. Find Unique Binary String in c++

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    string findDifferentBinaryString(vector<string>& nums) { // function to find the findDifferentBinaryString
        int n=nums.size(); // variable to store the size of the nums
        string ans=""; // variable to store the ans
        for(int i=0;i<n;i++)ans+=nums[i][i]=='0'?'1':'0'; // loop for i
        return ans; // return the ans
    }
};

1657. Determine if Two Strings Are Close in c++

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    bool closeStrings(string word1, string word2) { // function to find the closeStrings
        int n=word1.size(); // variable to store the size of the word1
        int m=word2.size(); // variable to store the size of the word2
        if(n!=m)return false; // if n is not equal to m return false
        vector<int>mp1(26); // vector to store the mp1
        vector<int>mp2(26); // vector to store the mp2
        for(int i=0;i<n;i++)mp1[word1[i]-'a']++; // loop for i
        for(int i=0;i<m;i++)mp2[word2[i]-'a']++; // loop for i
        for(int i=0;i<26;i++){ // loop for i
            if((mp1[i]==0 && mp2[i]!=0) || (mp1[i]!=0 && mp2[i]==0))return false; // if (mp1[i] is equal to 0 and mp2[i] is not equal to 0) or (mp1[i] is not equal to 0 and mp2[i] is equal to 0) return false
        }
        sort(mp1.begin(),mp1.end()); // sort the mp1
        sort(mp2.begin(),mp2.end()); // sort the mp2
        for(int i=0;i<26;i++){ // loop for i
            if(mp1[i]!=mp2[i])return false; // if mp1[i] is not equal to mp2[i] return false
        }
        return true; // return true
    }
};

1838. Frequency of the Most Frequent Element in c++

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    int maxFrequency(vector<int>& nums, int k) { // function to find the maxFrequency
        int n=nums.size(); // variable to store the size of the nums
        sort(nums.begin(),nums.end()); // sort the nums
        long long sum=0; // variable to store the sum
        int ans=0; // variable to store the ans
        int i=0; // variable to store the i
        for(int j=0;j<n;j++){ // loop for j
            sum+=nums[j]; // update the sum
            while((long long)nums[j]*(j-i+1)-sum>k){ // while (nums[j]*(j-i+1)-sum) is greater than k
                sum-=nums[i]; // decrement the sum
                i++; // increment the i
            }
            ans=max(ans,j-i+1); // update the ans
        }
        return ans; // return the ans
    }
};

2401. Longest Nice Subarray in c++

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    int longestNiceSubarray(vector<int>& nums) {
        ios_base::sync_with_stdio(false) , cin.tie(0) , cout.tie(0); // fast I/O
        int n=nums.size(); // variable to store the size of the nums
        int ans = 0 , curr = 0 , i = 0; // variable to store the ans , curr , i
        for(int j=0;j<n;j++){ // loop for j
            while(curr & nums[j] > 0){  // while curr & nums[j] is greater than 0
                curr ^= nums[i++]; // update the curr
                curr |= nums[j]; // update the curr
            }
            ans = max(ans , j - i + 1); // update the ans
        }
        return ans; // return the ans
    }
};

// A sub array is valid when no two elements have same position set bit. Like 1001 and 110 can be in one window but not with 1111.
// We are checking using AND operation because if no two bit in our window have same set bit then the AND operation will give 0 if not then we need to shrink the window for making it valid for our current element's insertion.
// So OR operation is setting those bits on which are already on by any of the element in the window. So if the window becomes invalid then then the cur element has some bit which has already been set by any of the previously added element, so we will shrink the window till it becomes valid again by removing the left most element.
// When we are removing an element then we are also removing it's set bits so we do the XOR operation of used with the leftmost element to remove it's set bits from consideration.
// Why xor is working is because xor will only make those bits 1 which are different. So suppose we have 11001 and we want to remove 9 - 1001 so . 11001^1001 will give 10000 , and we can see that only those bits are off which we wanted to remove.
// Then when the window becomes valid we can insert our new element in it by doing OR operation with the used variable , so that we can mark those bits used which are set in cur element.
// Then we can check the size of the window for our answer.

2150. Find All Lonely Numbers in the Array in c++

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution
{
public:
    vector<int> findAllLonelyNumbers(vector<int>& nums) { // function to find the findAllLonelyNumbers
        int n=nums.size(); // variable to store the size of the nums
        vector<int>ans; // vector to store the ans
        int freq[100001] = {0}; // variable to store the freq
        for(auto x:nums)freq[x]++; // loop for x
        for(auto x:nums){ // loop for x
            if(freq[x]==1 && (!freq[x-1] || !freq[x+1]))ans.push_back(x); // if freq[x] is equal to 1 and (!freq[x-1] or !freq[x+1]) push the x
        }
        return ans; // return the ans
    }
};

1727. Largest Submatrix With Rearrangements in c++

// Time Complexity : O(n*m) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    int largestSubmatrix(vector<vector<int>>& matrix) { // function to find the largestSubmatrix
        int n=matrix.size(); // variable to store the size of the matrix
        int m=matrix[0].size(); // variable to store the size of the matrix
        for(int i=1;i<n;i++){ // loop for i
            for(int j=0;j<m;j++){ // loop for j
                if(matrix[i][j]==1)matrix[i][j]+=matrix[i-1][j]; // if matrix[i][j] is equal to 1 update the matrix[i][j]
            }
        }
        int ans=0; // variable to store the ans
        for(int i=0;i<n;i++){ // loop for i
            sort(matrix[i].begin(),matrix[i].end()); // sort the matrix[i]
            for(int j=0;j<m;j++){ // loop for j
                ans=max(ans,matrix[i][j]*(m-j)); // update the ans
            }
        }
        return ans; // return the ans
    }
};

1552. Magnetic Force Between Two Balls in c++

// Time Complexity : O(nlogn) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    int maxDistance(vector<int>& position, int m) { // function to find the maxDistance
        int n=position.size(); // variable to store the size of the position
        sort(position.begin(),position.end()); // sort the position
        int low=1; // variable to store the low
        int high=position[n-1]-position[0]; // variable to store the high
        int ans=0; // variable to store the ans
        while(low<=high){ // loop until low is less than or equal to high
            int mid=(low+high)/2; // variable to store the mid
            if(isValid(position,mid,m)){ // if isValid(position,mid,m)
                ans=mid; // update the ans
                low=mid+1; // update the low
            }
            else high=mid-1; // else update the high
        }
        return ans; // return the ans
    }
    bool isValid(vector<int>&position,int mid,int m){ // function to find the isValid
        int n=position.size(); // variable to store the size of the position
        int count=1; // variable to store the count
        int last=position[0]; // variable to store the last
        for(int i=1;i<n;i++){ // loop for i
            if(position[i]-last>=mid){ // if position[i]-last is greater than or equal to mid
                count++; // increment the count
                last=position[i]; // update the last
            }
        }
        return count>=m; // return count is greater than or equal to m
    }
};

1160. Find Words That Can Be Formed by Characters in c++

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

#pragma GCC optimize("Ofast","inline","fast-math","unroll-loops","no-stack-protector")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native","f16c")
static const auto fast = []() {ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();
class Solution {
public:
    int countCharacters(vector<string>& words, string chars) { // function to find the countCharacters
        int n=words.size(); // variable to store the size of the words
        int m=chars.size(); // variable to store the size of the chars
        vector<int>mp(26); // vector to store the mp
        for(int i=0;i<m;i++)mp[chars[i]-'a']++; // loop for i
        int ans=0; // variable to store the ans
        for(int i=0;i<n;i++){ // loop for i
            vector<int>temp(26); // vector to store the temp
            for(int j=0;j<words[i].size();j++)temp[words[i][j]-'a']++; // loop for j
            bool flag=true; // variable to store the flag
            for(int j=0;j<26;j++){ // loop for j
                if(temp[j]>mp[j]){ // if temp[j] is greater than mp[j]
                    flag=false; // update the flag
                    break; // break
                }
            }
            if(flag)ans+=words[i].size(); // if flag is true update the ans
        }
        return ans; // return the ans
    }
};

// 2nd Method

#pragma GCC optimize("Ofast","inline","fast-math","unroll-loops","no-stack-protector")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native","f16c")
static const auto fast = []() {ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();
#include <vector>
#include <string>
#include <unordered_map>

class Solution {
public:
    int countCharacters(const std::vector<std::string>& words, const std::string& chars) {
        int count = 0;

        // Count the frequency of characters in chars using an array (assuming ASCII characters)
        std::vector<int> charCount(26, 0);
        for (char ch : chars) {
            charCount[ch - 'a']++;
        }

        // Check if a word can be formed using the characters in chars
        for (const std::string& word : words) {
            std::vector<int> wordCount(26, 0);

            // Count the frequency of each character in the current word
            for (char ch : word) {
                wordCount[ch - 'a']++;
            }

            // Check if the characters in the word can be formed using chars
            bool validWord = true;
            for (int i = 0; i < 26; i++) {
                if (wordCount[i] > charCount[i]) {
                    validWord = false;
                    break;
                }
            }

            // If the word is valid, add its length to the count
            if (validWord) {
                count += word.length();
            }
        }

        return count;
    }
};

1160. Find Words That Can Be Formed by Characters in java

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public int countCharacters(String[] words, String chars) { // function to find the countCharacters
        int n=words.length; // variable to store the size of the words
        int m=chars.length(); // variable to store the size of the chars
        int[]mp=new int[26]; // vector to store the mp
        for(int i=0;i<m;i++)mp[chars.charAt(i)-'a']++; // loop for i
        int ans=0; // variable to store the ans
        for(int i=0;i<n;i++){ // loop for i
            int[]temp=new int[26]; // vector to store the temp
            for(int j=0;j<words[i].length();j++)temp[words[i].charAt(j)-'a']++; // loop for j
            boolean flag=true; // variable to store the flag
            for(int j=0;j<26;j++){ // loop for j
                if(temp[j]>mp[j]){ // if temp[j] is greater than mp[j]
                    flag=false; // update the flag
                    break; // break
                }
            }
            if(flag)ans+=words[i].length(); // if flag is true update the ans
        }
        return ans; // return the ans
    }
}

// 2nd Method

import java.util.HashMap;

public class Solution {
    public int countCharacters(String[] words, String chars) {
        int count = 0;

        // Count the frequency of characters in chars using a HashMap
        HashMap<Character, Integer> charCount = new HashMap<>();
        for (char ch : chars.toCharArray()) {
            charCount.put(ch, charCount.getOrDefault(ch, 0) + 1);
        }

        // Check if a word can be formed using the characters in chars
        for (String word : words) {
            HashMap<Character, Integer> wordCount = new HashMap<>();

            // Count the frequency of each character in the current word
            for (char ch : word.toCharArray()) {
                wordCount.put(ch, wordCount.getOrDefault(ch, 0) + 1);
            }

            // Check if the characters in the word can be formed using chars
            boolean validWord = true;
            for (char ch : wordCount.keySet()) {
                if (wordCount.get(ch) > charCount.getOrDefault(ch, 0)) {
                    validWord = false;
                    break;
                }
            }

            // If the word is valid, add its length to the count
            if (validWord) {
                count += word.length();
            }
        }

        return count;
    }
}

330. Patching Array in c++

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    int minPatches(vector<int>& nums, int n) { // function to find the minPatches
        long long maxReach=0; // variable to store the maxReach
        int ans=0; // variable to store the ans
        for(int num : nums) { // loop for num
            while(num > maxReach + 1) { // while num is greater than maxReach+1
                ans++; // increment the ans
                maxReach += maxReach + 1; // update the maxReach
                if(maxReach >= n) return ans; // if maxReach is greater than or equal to n return ans
            }
            maxReach += num; // update the maxReach
            if(maxReach >= n) return ans; // if maxReach is greater than or equal to n return ans
        }
        while(maxReach < n) { // while maxReach is less than n
            ans++; // increment the ans
            maxReach += maxReach + 1; // update the maxReach
        }
        return ans; // return the ans
    }
};

322. Coin Change in c++

// Time Complexity : O(n*m) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    int coinChange(vector<int>& coins, int amount) { // function to find the coinChange
        int n=coins.size(); // variable to store the size of the coins
        vector<int>dp(amount+1,INT_MAX); // vector to store the dp
        dp[0]=0; // update the dp[0]
        for(int i=1;i<=amount;i++){ // loop for i
            for(int j=0;j<n;j++){ // loop for j
                if(i-coins[j]>=0 && dp[i-coins[j]]!=INT_MAX)dp[i]=min(dp[i],dp[i-coins[j]]+1); // if i-coins[j] is greater than or equal to 0 and dp[i-coins[j]] is not equal to INT_MAX update the dp[i]
            }
        }
        return dp[amount]==INT_MAX?-1:dp[amount]; // return dp[amount] is equal to INT_MAX?-1:dp[amount]
    }
};

73. Set Matrix Zeroes in c++

// Time Complexity : O(n*m) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) { // function to find the setZeroes
        int n=matrix.size(); // variable to store the size of the matrix
        int m=matrix[0].size(); // variable to store the size of the matrix
        bool row=false; // variable to store the row
        bool col=false; // variable to store the col
        for(int i=0;i<n;i++){ // loop for i
            for(int j=0;j<m;j++){ // loop for j
                if(matrix[i][j]==0){ // if matrix[i][j] is equal to 0
                    if(i==0)row=true; // if i is equal to 0 update the row
                    if(j==0)col=true; // if j is equal to 0 update the col
                    matrix[i][0]=0; // update the matrix[i][0]
                    matrix[0][j]=0; // update the matrix[0][j]
                }
            }
        }
        for(int i=1;i<n;i++){ // loop for i
            for(int j=1;j<m;j++){ // loop for j
                if(matrix[i][0]==0 || matrix[0][j]==0)matrix[i][j]=0; // if matrix[i][0] is equal to 0 or matrix[0][j] is equal to 0 update the matrix[i][j]
            }
        }
        if(row){ // if row
            for(int i=0;i<m;i++)matrix[0][i]=0; // loop for i
        }
        if(col){ // if col
            for(int i=0;i<n;i++)matrix[i][0]=0; // loop for i
        }
    }
};

// 2nd Method

#include <vector>

class Solution {
public:
    void setZeroes(std::vector<std::vector<int>>& matrix) {
        int n = matrix.size();
        int m = matrix[0].size();

        // Use first row and first column as flags
        bool firstRowZero = false;
        bool firstColZero = false;

        // Check if the first row should be zeroed
        for (int j = 0; j < m; j++) {
            if (matrix[0][j] == 0) {
                firstRowZero = true;
                break;
            }
        }

        // Check if the first column should be zeroed
        for (int i = 0; i < n; i++) {
            if (matrix[i][0] == 0) {
                firstColZero = true;
                break;
            }
        }

        // Use the first row and first column as flags to mark zero positions
        for (int i = 1; i < n; i++) {
            for (int j = 1; j < m; j++) {
                if (matrix[i][j] == 0) {
                    matrix[0][j] = 0; // Mark the column
                    matrix[i][0] = 0; // Mark the row
                }
            }
        }

        // Set zeroes based on the flags in the first row and first column
        for (int i = 1; i < n; i++) {
            for (int j = 1; j < m; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }

        // Set zeroes in the first row and first column if needed
        if (firstRowZero) {
            for (int j = 0; j < m; j++) {
                matrix[0][j] = 0;
            }
        }

        if (firstColZero) {
            for (int i = 0; i < n; i++) {
                matrix[i][0] = 0;
            }
        }
    }
};

65. Valid Number in c++

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    bool isNumber(string s) { // function to find the isNumber
        int n=s.size(); // variable to store the size of the s
        int i=0; // variable to store the i
        while(i<n && s[i]==' ')i++; // while i is less than n and s[i] is equal to ' ' increment the i
        if(i<n && (s[i]=='+' || s[i]=='-'))i++; // if i is less than n and (s[i] is equal to '+' or s[i] is equal to '-') increment the i
        bool isNumeric=false; // variable to store the isNumeric
        while(i<n && isdigit(s[i])){ // while i is less than n and isdigit(s[i])
            i++; // increment the i
            isNumeric=true; // update the isNumeric
        }
        if(i<n && s[i]=='.'){ // if i is less than n and s[i] is equal to '.'
            i++; // increment the i
            while(i<n && isdigit(s[i])){ // while i is less than n and isdigit(s[i])
                i++; // increment the i
                isNumeric=true; // update the isNumeric
            }
        }
        if(isNumeric && i<n && (s[i]=='e' || s[i]=='E')){ // if isNumeric and i is less than n and s[i] is equal to 'e' or s[i] is equal to 'E'
            i++; // increment the i
            isNumeric=false; // update the isNumeric
            if(i<n && (s[i]=='+' || s[i]=='-'))i++; // if i is less than n and (s[i] is equal to '+' or s[i] is equal to '-') increment the i
            if(i == n) return false; // if i is equal to n return false // Missing digits after 'e'
            while(i<n && isdigit(s[i])){ // while i is less than n and isdigit(s[i])
                i++; // increment the i
                isNumeric=true; // update the isNumeric
            }
        }
        while(i<n && s[i]==' ')i++; // while i is less than n and s[i] is equal to ' ' increment the i
        return isNumeric && i==n; // return isNumeric and i is equal to n
    }
};

65. Valid Number in java

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public boolean isNumber(String s) { // function to find the isNumber
        int n=s.length(); // variable to store the size of the s
        int i=0; // variable to store the i
        while(i<n && s.charAt(i)==' ')i++; // while i is less than n and s.charAt(i) is equal to ' ' increment the i
        if(i<n && (s.charAt(i)=='+' || s.charAt(i)=='-'))i++; // if i is less than n and (s.charAt(i) is equal to '+' or s.charAt(i) is equal to '-') increment the i
        boolean isNumeric=false; // variable to store the isNumeric
        while(i<n && Character.isDigit(s.charAt(i))){ // while i is less than n and Character.isDigit(s.charAt(i))
            i++; // increment the i
            isNumeric=true; // update the isNumeric
        }
        if(i<n && s.charAt(i)=='.'){ // if i is less than n and s.charAt(i) is equal to '.'
            i++; // increment the i
            while(i<n && Character.isDigit(s.charAt(i))){ // while i is less than n and Character.isDigit(s.charAt(i))
                i++; // increment the i
                isNumeric=true; // update the isNumeric
            }
        }
        if(isNumeric && i<n && (s.charAt(i)=='e' || s.charAt(i)=='E')){ // if isNumeric and i is less than n and s.charAt(i) is equal to 'e' or s.charAt(i) is equal to 'E'
            i++; // increment the i
            isNumeric=false; // update the isNumeric
            if(i<n && (s.charAt(i)=='+' || s.charAt(i)=='-'))i++; // if i is less than n and (s.charAt(i) is equal to '+' or s.charAt(i) is equal to '-') increment the i
            if(i == n) return false; // if i is equal to n return false // Missing digits after 'e'
            while(i<n && Character.isDigit(s.charAt(i))){ // while i is less than n and Character.isDigit(s.charAt(i))
                i++; // increment the i
                isNumeric=true; // update the isNumeric
            }
        }
        while(i<n && s.charAt(i)==' ')i++; // while i is less than n and s.charAt(i) is equal to ' ' increment the i
        return isNumeric && i==n; // return isNumeric and i is equal to n
    }
}

451. Sort Characters By Frequency in c++ using unordered_map

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    string frequencySort(string s) { // function to find the frequencySort
        int n=s.size(); // variable to store the size of the s
        unordered_map<char,int>mp; // unordered_map to store the char
        for(int i=0;i<n;i++)mp[s[i]]++; // loop for i
        vector<pair<int,char>>v; // vector to store the pair
        for(auto x:mp)v.push_back({x.second,x.first}); // loop for x
        sort(v.begin(),v.end()); // sort the v
        string ans=""; // variable to store the ans
        for(int i=v.size()-1;i>=0;i--){ // loop for i
            while(v[i].first--)ans+=v[i].second; // while v[i].first-- update the ans
        }
        return ans; // return the ans
    }
};

// 2nd Method using priority_queue

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    string frequencySort(string s) { // function to find the frequencySort
        int n=s.size(); // variable to store the size of the s
        unordered_map<char,int>mp; // unordered_map to store the char
        for(int i=0;i<n;i++)mp[s[i]]++; // loop for i
        priority_queue<pair<int,char>>pq; // priority_queue to store the pair
        for(auto x:mp)pq.push({x.second,x.first}); // loop for x
        string ans=""; // variable to store the ans
        while(!pq.empty()){ // while pq is not empty
            pair<int,char>temp=pq.top(); // variable to store the temp
            pq.pop(); // pop the pq
            while(temp.first--)ans+=temp.second; // while temp.first-- update the ans
        }
        return ans; // return the ans
    }
};

// 3rd Method using bucket sort

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    string frequencySort(string s) { // function to find the frequencySort
        int n=s.size(); // variable to store the size of the s
        unordered_map<char,int>mp; // unordered_map to store the char
        for(int i=0;i<n;i++)mp[s[i]]++; // loop for i
        vector<string>bucket(n+1,""); // vector to store the bucket
        for(auto x:mp){ // loop for x
            int freq=x.second; // variable to store the freq
            char ch=x.first; // variable to store the ch
            bucket[freq]+=string(freq,ch); // update the bucket[freq]
        }
        string ans=""; // variable to store the ans
        for(int i=n;i>=0;i--){ // loop for i
            if(bucket[i].size()>0)ans+=bucket[i]; // if bucket[i].size() is greater than 0 update the ans
        }
        return ans; // return the ans
    }
};

// 4th Method using counting sort

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    string frequencySort(string s) { // function to find the frequencySort
        int n=s.size(); // variable to store the size of the s
        unordered_map<char,int>mp; // unordered_map to store the char
        for(int i=0;i<n;i++)mp[s[i]]++; // loop for i
        vector<int>freq; // vector to store the freq
        for(auto x:mp)freq.push_back(x.second); // loop for x
        sort(freq.begin(),freq.end()); // sort the freq
        string ans=""; // variable to store the ans
        for(int i=freq.size()-1;i>=0;i--){ // loop for i
            for(auto x:mp){ // loop for x
                if(x.second==freq[i]){ // if x.second is equal to freq[i]
                    while(freq[i]--)ans+=x.first; // while freq[i]-- update the ans
                    mp.erase(x.first); // erase the x.first
                    break; // break
                }
            }
        }
        return ans; // return the ans
    }
};

451. Sort Characters By Frequency in java using unordered_map

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public String frequencySort(String s) { // function to find the frequencySort
        int n=s.length(); // variable to store the size of the s
        HashMap<Character,Integer>mp=new HashMap<>(); // unordered_map to store the char
        for(int i=0;i<n;i++)mp.put(s.charAt(i),mp.getOrDefault(s.charAt(i),0)+1); // loop for i
        ArrayList<Pair<Integer,Character>>v=new ArrayList<>(); // vector to store the pair
        for(Map.Entry<Character,Integer>entry:mp.entrySet())v.add(new Pair<>(entry.getValue(),entry.getKey())); // loop for entry
        Collections.sort(v); // sort the v
        String ans=""; // variable to store the ans
        for(int i=v.size()-1;i>=0;i--){ // loop for i
            while(v.get(i).getKey()-->0)ans+=v.get(i).getValue(); // while v[i].first-- update the ans
        }
        return ans; // return the ans
    }
}

// 2nd Method using priority_queue

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public String frequencySort(String s) { // function to find the frequencySort
        int n=s.length(); // variable to store the size of the s
        HashMap<Character,Integer>mp=new HashMap<>(); // unordered_map to store the char
        for(int i=0;i<n;i++)mp.put(s.charAt(i),mp.getOrDefault(s.charAt(i),0)+1); // loop for i
        PriorityQueue<Pair<Integer,Character>>pq=new PriorityQueue<>(); // priority_queue to store the pair
        for(Map.Entry<Character,Integer>entry:mp.entrySet())pq.add(new Pair<>(entry.getValue(),entry.getKey())); // loop for entry
        String ans=""; // variable to store the ans
        while(!pq.isEmpty()){ // while pq is not empty
            Pair<Integer,Character>temp=pq.poll(); // variable to store the temp
            while(temp.getKey()-->0)ans+=temp.getValue(); // while temp.first-- update the ans
        }
        return ans; // return the ans
    }
}

// 3rd Method using bucket sort

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public String frequencySort(String s) { // function to find the frequencySort
        int n=s.length(); // variable to store the size of the s
        HashMap<Character,Integer>mp=new HashMap<>(); // unordered_map to store the char
        for(int i=0;i<n;i++)mp.put(s.charAt(i),mp.getOrDefault(s.charAt(i),0)+1); // loop for i
        String[]bucket=new String[n+1]; // vector to store the bucket
        for(Map.Entry<Character,Integer>entry:mp.entrySet()){ // loop for entry
            int freq=entry.getValue(); // variable to store the freq
            char ch=entry.getKey(); // variable to store the ch
            bucket[freq]+=String.join("",Collections.nCopies(freq,String.valueOf(ch))); // update the bucket[freq]
        }
        String ans=""; // variable to store the ans
        for(int i=n;i>=0;i--){ // loop for i
            if(bucket[i].length()>0)ans+=bucket[i]; // if bucket[i].length() is greater than 0 update the ans
        }
        return ans; // return the ans
    }
}

// 4th Method using counting sort

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public String frequencySort(String s) { // function to find the frequencySort
        int n=s.length(); // variable to store the size of the s
        HashMap<Character,Integer>mp=new HashMap<>(); // unordered_map to store the char
        for(int i=0;i<n;i++)mp.put(s.charAt(i),mp.getOrDefault(s.charAt(i),0)+1); // loop for i
        ArrayList<Integer>freq=new ArrayList<>(); // vector to store the freq
        for(Map.Entry<Character,Integer>entry:mp.entrySet())freq.add(entry.getValue()); // loop for entry
        Collections.sort(freq); // sort the freq
        String ans=""; // variable to store the ans
        for(int i=freq.size()-1;i>=0;i--){ // loop for i
            for(Map.Entry<Character,Integer>entry:mp.entrySet()){ // loop for entry
                if(entry.getValue()==freq.get(i)){ // if entry.getValue() is equal to freq[i]
                    while(freq.get(i)-->0)ans+=entry.getKey(); // while freq[i]-- update the ans
                    mp.remove(entry.getKey()); // erase the entry.getKey()
                    break; // break
                }
            }
        }
        return ans; // return the ans
    }
}


347. Top K Frequent Elements in c++ using unordered_map

// Time Complexity : O(nlogk) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) { // function to find the topKFrequent
        int n=nums.size(); // variable to store the size of the nums
        unordered_map<int,int>mp; // unordered_map to store the mp
        for(int i=0;i<n;i++)mp[nums[i]]++; // loop for i
        vector<pair<int,int>>v; // vector to store the pair
        for(auto x:mp)v.push_back({x.second,x.first}); // loop for x
        sort(v.begin(),v.end()); // sort the v
        vector<int>ans; // vector to store the ans
        for(int i=v.size()-1;i>=0;i--){ // loop for i
            ans.push_back(v[i].second); // push the v[i].second
            if(ans.size()==k)break; // if ans.size() is equal to k break
        }
        return ans; // return the ans
    }
};

//2nd Method using priority_queue

// Time Complexity : O(nlogk) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) { // function to find the topKFrequent
        int n=nums.size(); // variable to store the size of the nums
        unordered_map<int,int>mp; // unordered_map to store the mp
        for(int i=0;i<n;i++)mp[nums[i]]++; // loop for i
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq; // priority_queue to store the pair
        for(auto x:mp){ // loop for x
            pq.push({x.second,x.first}); // push the pq
            if(pq.size()>k)pq.pop(); // if pq.size() is greater than k pop the pq
        }
        vector<int>ans; // vector to store the ans
        while(!pq.empty()){ // while pq is not empty
            pair<int,int>temp=pq.top(); // variable to store the temp
            pq.pop(); // pop the pq
            ans.push_back(temp.second); // push the temp.second
        }
        return ans; // return the ans
    }
};

// 3rd Method using bucket sort

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) { // function to find the topKFrequent
        int n=nums.size(); // variable to store the size of the nums
        unordered_map<int,int>mp; // unordered_map to store the mp
        for(int i=0;i<n;i++)mp[nums[i]]++; // loop for i
        vector<vector<int>>bucket(n+1); // vector to store the bucket
        for(auto x:mp){ // loop for x
            int freq=x.second; // variable to store the freq
            int num=x.first; // variable to store the num
            bucket[freq].push_back(num); // push the bucket[freq]
        }
        vector<int>ans; // vector to store the ans
        for(int i=n;i>=0;i--){ // loop for i
            for(int j=0;j<bucket[i].size();j++){ // loop for j
                ans.push_back(bucket[i][j]); // push the bucket[i][j]
                if(ans.size()==k)return ans; // if ans.size() is equal to k return ans
            }
        }
        return ans; // return the ans
    }
};

// 4th Method using counting sort

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) { // function to find the topKFrequent
        int n=nums.size(); // variable to store the size of the nums
        unordered_map<int,int>mp; // unordered_map to store the mp
        for(int i=0;i<n;i++)mp[nums[i]]++; // loop for i
        vector<int>freq; // vector to store the freq
        for(auto x:mp)freq.push_back(x.second); // loop for x
        sort(freq.begin(),freq.end()); // sort the freq
        vector<int>ans; // vector to store the ans
        for(int i=freq.size()-1;i>=0;i--){ // loop for i
            for(auto x:mp){ // loop for x
                if(x.second==freq[i]){ // if x.second is equal to freq[i]
                    while(freq[i]--)ans.push_back(x.first); // while freq[i]-- push the x.first
                    mp.erase(x.first); // erase the x.first
                    break; // break
                }
            }
            if(ans.size()==k)return ans; // if ans.size() is equal to k return ans
        }
        return ans; // return the ans
    }
};

347. Top K Frequent Elements in java using unordered_map

// Time Complexity : O(nlogk) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public List<Integer> topKFrequent(int[] nums, int k) { // function to find the topKFrequent
        int n=nums.length; // variable to store the size of the nums
        HashMap<Integer,Integer>mp=new HashMap<>(); // unordered_map to store the mp
        for(int i=0;i<n;i++)mp.put(nums[i],mp.getOrDefault(nums[i],0)+1); // loop for i
        ArrayList<Pair<Integer,Integer>>v=new ArrayList<>(); // vector to store the pair
        for(Map.Entry<Integer,Integer>entry:mp.entrySet())v.add(new Pair<>(entry.getValue(),entry.getKey())); // loop for entry
        Collections.sort(v); // sort the v
        ArrayList<Integer>ans=new ArrayList<>(); // vector to store the ans
        for(int i=v.size()-1;i>=0;i--){ // loop for i
            ans.add(v.get(i).getValue()); // push the v[i].second
            if(ans.size()==k)break; // if ans.size() is equal to k break
        }
        return ans; // return the ans
    }
}

//2nd Method using priority_queue

// Time Complexity : O(nlogk) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public List<Integer> topKFrequent(int[] nums, int k) { // function to find the topKFrequent
        int n=nums.length; // variable to store the size of the nums
        HashMap<Integer,Integer>mp=new HashMap<>(); // unordered_map to store the mp
        for(int i=0;i<n;i++)mp.put(nums[i],mp.getOrDefault(nums[i],0)+1); // loop for i
        PriorityQueue<Pair<Integer,Integer>>pq=new PriorityQueue<>(); // priority_queue to store the pair
        for(Map.Entry<Integer,Integer>entry:mp.entrySet()){ // loop for entry
            pq.add(new Pair<>(entry.getValue(),entry.getKey())); // push the pq
            if(pq.size()>k)pq.poll(); // if pq.size() is greater than k pop the pq
        }
        ArrayList<Integer>ans=new ArrayList<>(); // vector to store the ans
        while(!pq.isEmpty()){ // while pq is not empty
            Pair<Integer,Integer>temp=pq.poll(); // variable to store the temp
            ans.add(temp.getValue()); // push the temp.second
        }
        return ans; // return the ans
    }
};

// 3rd Method using bucket sort

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public List<Integer> topKFrequent(int[] nums, int k) { // function to find the topKFrequent
        int n=nums.length; // variable to store the size of the nums
        HashMap<Integer,Integer>mp=new HashMap<>(); // unordered_map to store the mp
        for(int i=0;i<n;i++)mp.put(nums[i],mp.getOrDefault(nums[i],0)+1); // loop for i
        String[]bucket=new String[n+1]; // vector to store the bucket
        for(Map.Entry<Integer,Integer>entry:mp.entrySet()){ // loop for entry
            int freq=entry.getValue(); // variable to store the freq
            int num=entry.getKey(); // variable to store the num
            bucket[freq]+=String.join("",Collections.nCopies(freq,String.valueOf(num))); // update the bucket[freq]
        }
        ArrayList<Integer>ans=new ArrayList<>(); // vector to store the ans
        for(int i=n;i>=0;i--){ // loop for i
            for(int j=0;j<bucket[i].length();j++){ // loop for j
                ans.add(bucket[i].charAt(j)); // push the bucket[i][j]
                if(ans.size()==k)return ans; // if ans.size() is equal to k return ans
            }
        }
        return ans; // return the ans
    }
};

// 4th Method using counting sort

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public List<Integer> topKFrequent(int[] nums, int k) { // function to find the topKFrequent
        int n=nums.length; // variable to store the size of the nums
        HashMap<Integer,Integer>mp=new HashMap<>(); // unordered_map to store the mp
        for(int i=0;i<n;i++)mp.put(nums[i],mp.getOrDefault(nums[i],0)+1); // loop for i
        ArrayList<Integer>freq=new ArrayList<>(); // vector to store the freq
        for(Map.Entry<Integer,Integer>entry:mp.entrySet())freq.add(entry.getValue()); // loop for entry
        Collections.sort(freq); // sort the freq
        ArrayList<Integer>ans=new ArrayList<>(); // vector to store the ans
        for(int i=freq.size()-1;i>=0;i--){ // loop for i
            for(Map.Entry<Integer,Integer>entry:mp.entrySet()){ // loop for entry
                if(entry.getValue()==freq.get(i)){ // if entry.getValue() is equal to freq[i]
                    while(freq.get(i)-->0)ans.add(entry.getKey()); // while freq[i]-- push the entry.getKey()
                    mp.remove(entry.getKey()); // erase the entry.getKey()
                    break; // break
                }
            }
            if(ans.size()==k)return ans; // if ans.size() is equal to k return ans
        }
        return ans; // return the ans
    }
};

264. Ugly Number II in c++

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
public:
    int nthUglyNumber(int n) { // function to find the nthUglyNumber
        vector<int>dp(n); // vector to store the dp
        dp[0]=1; // update the dp[0]
        int i2=0; // variable to store the i2
        int i3=0; // variable to store the i3
        int i5=0; // variable to store the i5
        for(int i=1;i<n;i++){ // loop for i
            dp[i]=min({dp[i2]*2,dp[i3]*3,dp[i5]*5}); // update the dp[i]
            if(dp[i]==dp[i2]*2)i2++; // if dp[i] is equal to dp[i2]*2 increment the i2
            if(dp[i]==dp[i3]*3)i3++; // if dp[i] is equal to dp[i3]*3 increment the i3
            if(dp[i]==dp[i5]*5)i5++; // if dp[i] is equal to dp[i5]*5 increment the i5
        }
        return dp[n-1]; // return the dp[n-1]
    }
};

264. Ugly Number II in java

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

class Solution {
    public int nthUglyNumber(int n) { // function to find the nthUglyNumber
        int[]dp=new int[n]; // vector to store the dp
        dp[0]=1; // update the dp[0]
        int i2=0; // variable to store the i2
        int i3=0; // variable to store the i3
        int i5=0; // variable to store the i5
        for(int i=1;i<n;i++){ // loop for i
            dp[i]=Math.min(Math.min(dp[i2]*2,dp[i3]*3),dp[i5]*5); // update the dp[i]
            if(dp[i]==dp[i2]*2)i2++; // if dp[i] is equal to dp[i2]*2 increment the i2
            if(dp[i]==dp[i3]*3)i3++; // if dp[i] is equal to dp[i3]*3 increment the i3
            if(dp[i]==dp[i5]*5)i5++; // if dp[i] is equal to dp[i5]*5 increment the i5
        }
        return dp[n-1]; // return the dp[n-1]
    }
}

943. Find the Shortest Superstring in c++

// Time Complexity : O(n^2 * 2^n) where n is the size of the vector nums and space complexity is O(n * 2^n)

class Solution {
public:
    string shortestSuperstring(vector<string>& words) {
        int n = words.size();
        vector<vector<int>> cost(n, vector<int>(n));
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                cost[i][j] = words[j].length();
                for (int k = 1; k <= min(words[i].length(), words[j].length()); ++k) {
                    if (words[i].substr(words[i].size() - k) == words[j].substr(0, k)) {
                        cost[i][j] = words[j].length() - k;
                    }
                }
            }
        }
        vector<vector<int>> dp(1 << n, vector<int>(n, INT_MAX / 2));
        vector<vector<int>> parent(1 << n, vector<int>(n, -1));
        for (int i = 0; i < n; ++i) {
            dp[1 << i][i] = words[i].size();
        }
        for (int mask = 0; mask < (1 << n); ++mask) {
            for (int bit = 0; bit < n; ++bit) {
                if ((mask >> bit) & 1) {
                    int pmask = mask ^ (1 << bit);
                    for (int i = 0; i < n; ++i) {
                        if ((pmask >> i) & 1) {
                            if (dp[pmask][i] + cost[i][bit] < dp[mask][bit]) {
                                dp[mask][bit] = dp[pmask][i] + cost[i][bit];
                                parent[mask][bit] = i;
                            }
                        }
                    }
                }
            }
        }
        vector<int> perm(n);
        vector<bool> seen(n);
        int mask = (1 << n) - 1;
        int p = min_element(dp[mask].begin(), dp[mask].end()) - dp[mask].begin();
        int s = dp[mask][p];
        for (int i = n - 1; i >= 0; --i) {
            perm[i] = p;
            seen[p] = true;
            int pp = parent[mask][p];
            mask ^= 1 << p;
            p = pp;
        }
        vector<int> indices(n);
        for (int i = 0; i < n; ++i) {
            indices[perm[i]] = i;
        }
        string res = words[perm[0]];
        for (int i = 1; i < n; ++i) {
            int overlap = cost[perm[i - 1]][perm[i]];
            res += words[perm[i]].substr(words[perm[i]].size() - overlap);
        }
        return res;
    }
};

312. Burst Balloons in c++

// Time Complexity : O(n^3) where n is the size of the vector nums and space complexity is O(n^2)

class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> dp(n + 2, vector<int>(n + 2));
        vector<int> val(n + 2);
        val[0] = val[n + 1] = 1;
        for (int i = 1; i <= n; i++) {
            val[i] = nums[i - 1];
        }
        for (int len = 1; len <= n; len++) {
            for (int left = 1; left <= n - len + 1; left++) {
                int right = left + len - 1;
                for (int k = left; k <= right; k++) {
                    dp[left][right] = max(dp[left][right], dp[left][k - 1] + val[left - 1] * val[k] * val[right + 1] + dp[k + 1][right]);
                }
            }
        }
        return dp[1][n];
    }
};

1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix in c++

// Time Complexity : O(m * n * 2^(m * n)) where n is the size of the vector nums and space complexity is O(m * n * 2^(m * n))

#include <vector>
#include <queue>
#include <unordered_set>
using namespace std;

class Solution {
public:
    int minFlips(vector<vector<int>>& mat) {
        int n = mat.size();
        int m = mat[0].size();
        int target = 0;

        // Convert the matrix to a single integer using bits
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                target = (target << 1) | mat[i][j];
            }
        }

        // Initialize the queue for BFS
        queue<pair<int, int>> q;
        unordered_set<int> visited;

        // Push the initial state (matrix and steps) into the queue
        q.push({0, 0});
        visited.insert(0);

        // Define the directions for flipping neighbors
        vector<pair<int, int>> dirs = {{0, 0}, {1, 0}, {-1, 0}, {0, 1}, {0, -1}};

        while (!q.empty()) {
            auto curr = q.front();
            q.pop();

            int currMatrix = curr.first;
            int steps = curr.second;

            // Check if the current matrix is the target (all zeros)
            if (currMatrix == target) {
                return steps;
            }

            // Perform the BFS by flipping cells and adding new states to the queue
            for (int i = 0; i < n; ++i) {
                for (int j = 0; j < m; ++j) {
                    int nextMatrix = currMatrix;

                    // Flip the cell and its neighbors
                    for (auto& dir : dirs) {
                        int ni = i + dir.first;
                        int nj = j + dir.second;

                        if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                            nextMatrix ^= (1 << (ni * m + nj));
                        }
                    }

                    // Check if the new state is not visited
                    if (visited.find(nextMatrix) == visited.end()) {
                        q.push({nextMatrix, steps + 1});
                        visited.insert(nextMatrix);
                    }
                }
            }
        }

        // If the target is not reachable, return -1
        return -1;
    }
};

1155. Number of Dice Rolls With Target Sum in c++

// Time Complexity : O(d * f * target) where n is the size of the vector nums and space complexity is O(d * target)\

class Solution {
public:
    int numRollsToTarget(int d, int f, int target) {
        int mod = 1e9 + 7;
        vector<vector<int>> dp(d + 1, vector<int>(target + 1));
        dp[0][0] = 1;
        for (int i = 1; i <= d; ++i) {
            for (int j = 1; j <= f; ++j) {
                for (int k = j; k <= target; ++k) {
                    dp[i][k] = (dp[i][k] + dp[i - 1][k - j]) % mod;
                }
            }
        }
        return dp[d][target];
    }
};


    
2827. Number of Beautiful Integers in the Range in c++

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

Explanation:

dp[10][10][10][20][2][2];: The 6D DP array used to store the results of subproblems, where each dimension represents a different aspect of the problem.
ans(...) function: The core recursive function responsible for calculating whether the given number is "beautiful" based on the defined conditions.
i: The current position in the number string being considered.
odd: The count of odd digits encountered so far.
even: The count of even digits encountered so far.
mod: The sum of digits encountered so far modulo k.
flag1: Indicates whether a leading zero has been encountered in the current number.
flag2: Indicates whether the current number is within the range [L, R].
k: The modulo value.
s: The original number string.
The base case checks if the end of the number string has been reached and whether the number satisfies the problem's "beautiful" conditions.
The first if statement with dp array checks if the result for the current state has already been calculated. If yes, it returns the precomputed result.
end is set to 10 initially, and if flag2 is true, it's adjusted based on the value of the current digit to ensure that numbers beyond the current range are not considered.
The variable res will accumulate the count of "beautiful" numbers that meet the conditions.
If flag1 is 0, it recursively calculates the result with the same state variables (without a leading zero).
The loop over j iterates over digits up to end (controlled by flag2 or capped at 9), and calculates new state variables based on the current digit.
The continue statement skips numbers with leading zeros when flag1 is 0.
Two cases are handled based on whether the current digit is the maximum possible digit within the current range (end - 1). Depending on this condition, the next state variables and the recursive call are adjusted.
find(...) function:
Initializes the DP array, converts the given number to a string, and calls the ans function.numberOfBeautifulIntegers(...) function : Computes the count of "beautiful" integers between the given range and modulo k.

class Solution
{
public:
    
    int dp[10][10][10][20][2][2];  // 6D dp array to store the dp values 
    
    long long ans(int i,int odd,int even,int mod,int flag1,int flag2,int k,string &s)  // function to find the number of beautiful integers in the range
    { 
        if(i==s.length())   // if i is equal to the length of the string
        {
            return odd==even && mod==0 && odd>0;  // return odd is equal to even and mod is equal to 0 and odd is greater than 0
        }
        
        if(dp[i][odd][even][mod][flag1][flag2]!=-1){  // if dp[i][odd][even][mod][flag1][flag2] is not equal to -1
            return dp[i][odd][even][mod][flag1][flag2];  // return dp[i][odd][even][mod][flag1][flag2]
        }
        
        int end=10;  // variable to store the end
        
        if(flag2)     // if flag2 is equal to 1
        {
            end=s[i]-'0'+1;  // update the end
        }
        
        int res=0;  // variable to store the res
        
        if(flag1==0){  // if flag1 is equal to 0
            res+=ans(i+1,odd,even,mod,0,0,k,s);  // update the res
        }
        
        for(int j=0;j<end;j++){  // loop until j is less than end
            if(flag1==0 && j==0)  // if flag1 is equal to 0 and j is equal to 0
            {
                continue;
            }
            
            if(j==end-1){  // if j is equal to end-1
                res+=ans(i+1,odd+j%2,even+(j%2==0),((mod*10)+j)%k,1,flag2,k,s);  // update the res
            }
            else
            {
                res+=ans(i+1,odd+j%2,even+(j%2==0),((mod*10)+j)%k,1,0,k,s);  // update the res
            }
        }
        
        return dp[i][odd][even][mod][flag1][flag2]=res;   // return dp[i][odd][even][mod][flag1][flag2]=res
    }
    
    long long find(int val,int k)
    {
        memset(dp,-1,sizeof(dp));  // memset the dp array with -1
        string s=to_string(val);  // convert the val to string
        
        return ans(0,0,0,0,0,1,k,s);  // return the ans
    }
    
    long long numberOfBeautifulIntegers(long long low, long long high, int k) {  // function to find the number of beautiful integers in the range
        
        return find(high,k)-find(low-1,k);  // return find(high,k)-find(low-1,k)
    }
};

2nd Method 

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

Explanation:

dp[12][12][12][2][22][2];: The 6D DP array used to store the results of subproblems, where each dimension represents a different aspect of the problem.
helper(...) function: The core recursive function responsible for calculating whether the given number is "beautiful."
pos: The current position in the number string being considered.
even: The count of even digits encountered so far.
odd: The count of odd digits encountered so far.
tight: Indicates if the number is within the given range.
summ: The sum of digits encountered so far modulo k.
zero: Indicates if the current number contains a leading zero.
if (pos >= n.length()): Checks if all digits have been considered, and whether the current number is "beautiful" according to the problem constraints.
if (dp[pos][even][odd][tight][summ][zero] != -1): Checks if the result for the current state has already been calculated and returns it.
The loop over digit iterates from 0 to limit, where limit depends on whether the number is still within bounds.
newTight, newEven, and newOdd are updated based on the current digit and its properties.
Recursive call to helper with updated state variables and accumulation of results in res.
dp is updated with the calculated res value for the current state.
numberOfBeautifulIntegers(...): Main function to calculate the count of "beautiful" integers in the given range.
Conversion of lower and upper bounds to string representations.
Initializing the DP array with -1 and then calculating the counts of "beautiful" integers for the upper and lower bounds.
The result is the difference between the counts of "beautiful" integers for the upper and lower bounds.

int newTight = (tight && digit == n[pos] - '0');
newTight: This variable determines if the number being formed is still within the specified range [L, R].
It's calculated by taking the logical AND (&&) of two conditions:
tight: A flag that indicates whether the current number is still within bounds.
digit == n[pos] - '0': Checks if the current digit is equal to the corresponding digit in the original number string.
Essentially, if the current number is tight and the current digit matches the original digit, then newTight remains 1, indicating that the number is still within bounds.
int newEven = even + (digit % 2 == 0 && (digit > 0 || !zero));
newEven: This variable represents the count of even digits encountered so far in the current number.
It's calculated by adding the current digit's even-ness to the existing count of even digits.
The even-ness of the digit is determined by the condition digit % 2 == 0.
However, there's a special case to handle leading zeros: If the digit is zero and zero is true (indicating a leading zero), it's not considered even. So, (digit > 0 || !zero) ensures that zero is not counted as even if it's a leading zero.
int newOdd = odd + (digit & 1);
newOdd: This variable represents the count of odd digits encountered so far in the current number.
It's calculated by adding the least significant bit (LSB) of the digit to the existing count of odd digits.
The operation digit & 1 isolates the LSB of the digit, which will be 1 if the digit is odd and 0 if it's even.
res += helper(n, k, pos + 1, newEven, newOdd, newTight, (summ * 10 + digit) % k, (zero && digit == 0));
This line is where the recursive call to the helper function happens with updated state variables.
n is the original number string, k is the modulo, and pos + 1 represents the next position in the number string.
The other arguments (newEven, newOdd, newTight, (summ * 10 + digit) % k, and (zero && digit == 0)) are updated values for the state variables in the next recursive call.
res is accumulated with the result of the recursive call, contributing to the final result for the current state.

(summ * 10 + digit) % k:
This expression calculates the new sum modulo k after appending the current digit to the sum.
summ: Represents the sum of digits encountered so far in the number string modulo k.
digit: The current digit being considered.
summ * 10 + digit: This operation effectively appends the current digit to the existing sum by multiplying the current sum by 10 and adding the current digit.
% k: Finally, the result is taken modulo k to ensure that the sum remains within the constraints of the modulo.
(zero && digit == 0):
This expression evaluates whether the current number has a leading zero.
zero: A boolean variable that indicates if the current number contains a leading zero.
digit == 0: Checks if the current digit is zero.
zero && digit == 0: The logical AND (&&) of these conditions returns true only if both zero is true and the current digit is zero.

class Solution {
public:

    int dp[12][12][12][2][22][2];  // 6D dp array to store the dp values

    int G(string& number, int k, int pos=0,int even=0, int odd=0, int tight = 1, int summ=0, bool zero = true){  // function to find the number of beautiful integers in the range
        if (pos >= number.length()){    // if pos is greater than or equal to the length of the number
            return (even==odd && !zero && summ == 0);  // return even is equal to odd and not zero and summ is equal to 0
        }

        if (dp[pos][even][odd][tight][summ][zero] != -1)   // if dp[pos][even][odd][tight][summ][zero] is not equal to -1
            return dp[pos][even][odd][tight][summ][zero];  // return dp[pos][even][odd][tight][summ][zero]

        int res = 0;
        for(int digit = 0; digit <= (tight ? number[pos]-'0' : 9); digit++){  // loop until digit is less than or equal to (tight ? number[pos]-'0' : 9)
            int newTight = (tight && digit == number[pos]-'0');  // variable to store the newTight 
            int newEven = even + (digit%2==0 && (digit>0 || !zero));  // variable to store the newEven
            int newOdd = odd + (digit&1); // variable to store the newOdd   
            res += G(number, k, pos+1, newEven, newOdd, newTight, (summ*10+digit)%k, (zero && digit == 0));  // update the res
        }

        dp[pos][even][odd][tight][summ][zero] = res;  // dp[pos][even][odd][tight][summ][zero] is equal to res
        return res;  // return res
    }

    int numberOfBeautifulIntegers(int low, int high, int k) {
        string lows = to_string(low-1);  // convert the low-1 to string
        string highs = to_string(high);  // convert the high to string

        memset(dp,-1,sizeof(dp));  // memset the dp array with -1
        int upper = G(highs,k);  // variable to store the upper
        memset(dp,-1,sizeof(dp));  // memset the dp array with -1
        int lower = G(lows,k);  // variable to store the lower
        return upper - lower;  // return upper - lower
    }
};

2827. Number of Beautiful Integers in the Range in java

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)


class Solution {
   int[][][][][][] dp;
   int k;

   public int numberOfBeautifulIntegers(int low, int high, int k) {
       String sLow = String.valueOf(low - 1);
       String sHigh = String.valueOf(high);
       this.k = k;

       int maxSize = 12;
       dp = new int[2][maxSize][maxSize][maxSize][20][2];

       for (int i = 0; i < 2; i++) {
           for (int j = 0; j < maxSize; j++) {
               for (int l = 0; l < maxSize; l++) {
                   for (int m = 0; m < maxSize; m++) {
                       for (int n = 0; n < 20; n++) {
                           Arrays.fill(dp[i][j][l][m][n], -1);
                       }
                   }
               }
           }
       }

       int maxi = helper(sHigh, 1, 0, 0, 0, 0, 1);

       for (int i = 0; i < 2; i++) {
           for (int j = 0; j < maxSize; j++) {
               for (int l = 0; l < maxSize; l++) {
                   for (int m = 0; m < maxSize; m++) {
                       for (int n = 0; n < 20; n++) {
                           Arrays.fill(dp[i][j][l][m][n], -1);
                       }
                   }
               }
           }
       }

       int mini = helper(sLow, 1, 0, 0, 0, 0, 1);

       return maxi - mini;
   }

   private int helper(String s, int tight, int pos, int odd, int even, int sum, int zero) {
       if (pos == s.length()) {
           return zero == 0 && sum == 0 && odd == even ? 1 : 0;
       }

       if (dp[tight][pos][odd][even][sum][zero] != -1) {
           return dp[tight][pos][odd][even][sum][zero];
       }

       int start = 0;
       int end = (tight == 1 ? s.charAt(pos) - '0' : 9);
       int ans = (zero == 1 ? helper(s, 0, pos + 1, odd, even, sum, zero) : 0);

       for (int i = start; i <= end; i++) {
           int newTight = (tight == 1 && i == s.charAt(pos) - '0') ? 1 : 0;
           int newOdd = odd + (i % 2);
           int newEven = even + ((zero == 0 || i > 0) && i % 2 == 0 ? 1 : 0);

           if (zero == 1 && i != 0) {
               ans += helper(s, newTight, pos + 1, newOdd, newEven, i, 0);
           } else if (zero == 0) {
               ans += helper(s, newTight, pos + 1, newOdd, newEven, (sum * 10 + i) % k, 0);
           }
       }

       return dp[tight][pos][odd][even][sum][zero] = ans;
   }
}

2nd Method 

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(1)

import java.util.Arrays;

class Solution {
    int[][][][][][] dp = new int[10][10][10][20][2][2]; // 6D DP array to store dp values
    
    int ans(int i, int odd, int even, int mod, int flag1, int flag2, int k, String s) {
        if (i == s.length()) {
            return (odd == even && mod == 0 && odd > 0) ? 1 : 0;
        }
        
        if (dp[i][odd][even][mod][flag1][flag2] != -1) {
            return dp[i][odd][even][mod][flag1][flag2];
        }
        
        int end = 10;
        
        if (flag2 == 1) {
            end = s.charAt(i) - '0' + 1;
        }
        
        int res = 0;
        
        if (flag1 == 0) {
            res += ans(i + 1, odd, even, mod, 0, 0, k, s);
        }
        
        for (int j = 0; j < end; j++) {
            if (flag1 == 0 && j == 0) {
                continue;
            }
            
            if (j == end - 1) {
                res += ans(i + 1, odd + j % 2, even + ((j % 2 == 0) ? 1 : 0), ((mod * 10) + j) % k, 1, flag2, k, s);
            } else {
                res += ans(i + 1, odd + j % 2, even + ((j % 2 == 0) ? 1 : 0), ((mod * 10) + j) % k, 1, 0, k, s);
            }
        }
        
        return dp[i][odd][even][mod][flag1][flag2] = res;
    }
    
    int find(int val, int k) {
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                for (int k1 = 0; k1 < 10; k1++) {
                    for (int l = 0; l < 20; l++) {
                        for (int m = 0; m < 2; m++) {
                            Arrays.fill(dp[i][j][k1][l][m], -1);
                        }
                    }
                }
            }
        }
        
        String s = Integer.toString(val);
        return ans(0, 0, 0, 0, 0, 1, k, s);
    }
    
    int numberOfBeautifulIntegers(long low, long high, int k) {
        return find((int) high, k) - find((int) low - 1, k);
    }
}


2973. Find Number of Coins to Place in Tree Nodes

//start of jonathanirvings' template v3.0.3 (BETA)

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
typedef pair<string,string> pss;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pii> vii;
typedef vector<LL> vl;
typedef vector<vl> vvl;

double EPS = 1e-9;
int INF = 1000000005;
long long INFF = 1000000000000000005LL;
double PI = acos(-1);
int dirx[8] = {-1,0,0,1,-1,-1,1,1};
int diry[8] = {0,1,-1,0,-1,1,-1,1};

#ifdef TESTING
  #define DEBUG fprintf(stderr,"====TESTING====\n")
  #define VALUE(x) cerr << "The value of " << #x << " is " << x << endl
  #define debug(...) fprintf(stderr, __VA_ARGS__)
#else
  #define DEBUG 
  #define VALUE(x)
  #define debug(...)
#endif

#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))
#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))
#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))
#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))
#define FOREACH(a,b) for (auto &(a) : (b))
#define REP(i,n) FOR(i,0,n)
#define REPN(i,n) FORN(i,1,n)
#define MAX(a,b) a = max(a,b)
#define MIN(a,b) a = min(a,b)
#define SQR(x) ((LL)(x) * (x))
#define RESET(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ALL(v) v.begin(),v.end()
#define ALLA(arr,sz) arr,arr+sz
#define SIZE(v) (int)v.size()
#define SORT(v) sort(ALL(v))
#define REVERSE(v) reverse(ALL(v))
#define SORTA(arr,sz) sort(ALLA(arr,sz))
#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))
#define PERMUTE next_permutation
#define TC(t) while(t--)

inline string IntToString(LL a){
  char x[100];
  sprintf(x,"%lld",a); string s = x;
  return s;
}

inline LL StringToInt(string a){
  char x[100]; LL res;
  strcpy(x,a.c_str()); sscanf(x,"%lld",&res);
  return res;
}

inline string GetString(void){
  char x[1000005];
  scanf("%s",x); string s = x;
  return s;
}

inline string uppercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';
  return s;
}

inline string lowercase(string s){
  int n = SIZE(s); 
  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';
  return s;
}

inline void OPEN (string s) {
  #ifndef TESTING
  freopen ((s + ".in").c_str (), "r", stdin);
  freopen ((s + ".out").c_str (), "w", stdout);
  #endif
}

#ifdef TESTING
int main() {}
#endif

//end of jonathanirvings' template v3.0.3 (BETA)

class Solution {
public:
  int n;
  vvi adj;
  vi cost;
  vector<LL> risan;

  vi dfs(int u,int pt)
  {
    vi now = {cost[u]};
    for (int v : adj[u]) if (v != pt)
    {
      vi nxt = dfs(v,u);
      for (int x : nxt) now.pb(x);
    }
    SORT(now);
    if (SIZE(now) > 6) now.erase(now.begin() + 2, now.end() - 3);
    if (SIZE(now) < 3) risan[u] = 1;
    else
    {
      risan[u] = 0;
      int m = SIZE(now);
      MAX(risan[u],(LL)now[m-1] * now[m-2] * now[m-3]);
      MAX(risan[u],(LL)now[0] * now[1] * now[m-1]);
    }
    return now;
  }
  
  vector<long long> placedCoins(vector<vector<int>>& edges, vector<int>& _cost) {
    cost = _cost;
    n = SIZE(cost);
    
    adj.resize(n);
    REP(i,n) adj[i].clear();
    REP(i,SIZE(edges))
    {
      adj[edges[i][0]].pb(edges[i][1]);
      adj[edges[i][1]].pb(edges[i][0]);
    }
    risan.resize(n);
    dfs(0,-1);
    return risan;
  }
};











// https://leetcode.com/problems/arithmetic-subarrays/



struct MyMinMaxData { // for "MyBinaryMinMaxTree_ValTraitsT" and "MyBinaryMinMaxTreeBaseT" used for "min" query. (see below) 
    int xMin;  // the min value in the range. (inclusive) used for "min" query. 
    int xMax; // the max value in the range. (inclusive) used for "max" query. 

    constexpr MyMinMaxData() = default;  // default constructor and destructor. 
    explicit constexpr MyMinMaxData(int t): xMin(t), xMax(t) {} // constructor with one parameter.
    constexpr MyMinMaxData(int tMin, int tMax): xMin(tMin), xMax(tMax) {} // constructor with two parameters.
};

#ifndef MY_FORCEINLINE // if not defined, define it as empty.
    #define MY_FORCEINLINE      __attribute__((always_inline)) //  __forceinline used in MSVC. 
#endif // MY_FORCEINLINE
// Note:
//    valid comparators: <, >.
//    invalid comparators: <=, >=.
//    see "isEqual_()".
//
template<class ValT>  // ValT: the value type. 
struct MyBinaryMinMaxTree_ValTraitsT {  // the value traits for "MyBinaryMinMaxTreeBaseT".
    typedef ValT                    value_t;   // the value type.
    typedef value_t&                reference;  // the reference type.
    typedef const value_t&          const_reference;  // the const reference type. 

    static constexpr const std::size_t C_MAX_VALUE_SIZE_TO_CALL_BY_VALUE = 8;
    using val_call_arg_t = typename std::conditional< (sizeof(value_t) <= C_MAX_VALUE_SIZE_TO_CALL_BY_VALUE), value_t, reference >::type;  // the value type used for calling functions.
    using const_val_call_arg_t = typename std::conditional< (sizeof(value_t) <= C_MAX_VALUE_SIZE_TO_CALL_BY_VALUE), const value_t, const_reference >::type; // the const value type used for calling functions.
 
    static MY_FORCEINLINE constexpr const_val_call_arg_t limitValMin() noexcept { return std::numeric_limits<value_t>::min(); } // the min value of the value type.
    static MY_FORCEINLINE constexpr const_val_call_arg_t limitValMax() noexcept { return std::numeric_limits<value_t>::max(); } // the max value of the value type.
};
//
template<class ValT // ValT: the value type.
    , class CmpT = std::less<ValT> // CmpT: the comparator type.
    , class CtnrT = std::vector<ValT> // CtnrT: the container type.
    , class IdxT = typename CtnrT::difference_type  // IdxT: the index type.
    , class TraitsT = MyBinaryMinMaxTree_ValTraitsT<ValT> // TraitsT: the value traits type.
    , bool UseIdxInNodeB = false
    >
class MyBinaryMinMaxTreeBaseT {  // the base class for "MyBinaryMinMaxTreeT".
public:
    typedef ValT                value_type; // the value type.
    typedef value_type          value_t; // the value type.
    typedef CmpT                comparator_t; // the comparator type.
    typedef CtnrT               container_t;// the container type.
    typedef IdxT                index_t; // the index type. 
    typedef TraitsT             traits_t;// the value traits type.
    static constexpr const bool B_USE_INDEX_IN_NODE = UseIdxInNodeB; // whether use index in node.

    static constexpr const index_t C_INDEX_NPOS = ((index_t)-1LL); // the invalid index value.

    typedef typename traits_t::reference                reference; // the reference type.
    typedef typename traits_t::const_reference          const_reference; // the const reference type.
    typedef typename traits_t::val_call_arg_t           val_call_arg_t; // the value type used for calling functions.
    typedef typename traits_t::const_val_call_arg_t     const_val_call_arg_t; // the const value type used for calling functions.

    typedef typename container_t::pointer               pointer;
    typedef typename container_t::const_pointer         const_pointer;

    using res_value_data_t = typename std::conditional< B_USE_INDEX_IN_NODE, index_t, value_t >::type;
    struct MinMaxData {
        res_value_data_t xMin;
        res_value_data_t xMax;

        constexpr MinMaxData() = default;
        constexpr explicit MinMaxData(res_value_data_t t): xMin(t), xMax(t) {}
        constexpr MinMaxData(res_value_data_t tMin, res_value_data_t tMax): xMin(tMin), xMax(tMax) {}

        constexpr MinMaxData(const MinMaxData& oth): xMin(oth.xMin), xMax(oth.xMax) {}
        constexpr MinMaxData(MinMaxData&& oth) noexcept: xMin(std::move(oth.xMin)), xMax(std::move(oth.xMax)) {}

        constexpr void swap(MinMaxData& oth) noexcept {
            std::swap(xMin, oth.xMin);
            std::swap(xMax, oth.xMax);
        }
        constexpr MinMaxData& operator=(const MinMaxData& oth) {
            xMin = oth.xMin;
            xMax = oth.xMax;
            return *this;
        }
        constexpr MinMaxData& operator=(MinMaxData&& oth) noexcept {
            xMin = std::move(oth.xMin);
            xMax = std::move(oth.xMax);
            return *this;
        }
    };
    typedef MinMaxData      res_data_t;

protected:
    // the root is in level 0, the capacity of level h is (2^h).
    //
    // according to experiments, set C_TOP_UPDATE_LEVEL  to 4 is better.
    //    it seems that set it to [2, 7] is OK, values greater than 7 is not good.
    static constexpr const index_t C_TOP_UPDATE_LEVEL = 4;
    //
    static constexpr const index_t C_TOP_UPDATE_LEVEL_INDEX_BEGIN = ((1 << C_TOP_UPDATE_LEVEL) - 1);
    static constexpr const index_t C_TOP_UPDATE_LEVEL_INDEX_END = ((1 << (C_TOP_UPDATE_LEVEL+1)) - 1);
    static constexpr const index_t C_CNT_MAX_TO_DIRECT_CMP = (1 << C_TOP_UPDATE_LEVEL);

    typedef MinMaxData                  node_t;
    typedef std::vector<node_t>         node_container_t;

protected:
    constexpr MyBinaryMinMaxTreeBaseT()
        : m_defVal(), m_elemCnt(0)
    {
        prepareForNodeContainer_();
    }
    constexpr MyBinaryMinMaxTreeBaseT(const value_t& defVal, index_t elemCnt, const comparator_t& cmp)
        : m_cmp(cmp), m_defVal(defVal), m_elemCnt(std::max(elemCnt, 0))
    {
        m_arrElem.resize(m_elemCnt, m_defVal);
        prepareForNodeContainer_();
    }
    constexpr MyBinaryMinMaxTreeBaseT(value_t&& defVal, index_t elemCnt, const comparator_t& cmp)
        : m_cmp(cmp), m_defVal(std::move(defVal)), m_elemCnt(std::max(elemCnt, 0))
    {
        m_arrElem.resize(m_elemCnt, m_defVal);
        prepareForNodeContainer_();
    }
    constexpr MyBinaryMinMaxTreeBaseT(const value_t& defVal, const container_t& arrElem, const comparator_t& cmp)
        : m_cmp(cmp), m_defVal(defVal), m_arrElem(arrElem)
    {
        //assert( std::uint64_t(m_arrElem.size()) <= std::uint64_t(std::numeric_limits<index_t>::max()) );
        m_elemCnt = static_cast<index_t>(m_arrElem.size());
        prepareForNodeContainer_();
    }
    constexpr MyBinaryMinMaxTreeBaseT(value_t&& defVal, container_t&& arrElem, const comparator_t& cmp)
        : m_cmp(cmp), m_defVal(std::move(defVal)), m_arrElem(std::move(arrElem))
    {
        //assert( std::uint64_t(m_arrElem.size()) <= std::uint64_t(std::numeric_limits<index_t>::max()) );
        m_elemCnt = static_cast<index_t>(m_arrElem.size());
        prepareForNodeContainer_();
    }
    virtual ~MyBinaryMinMaxTreeBaseT() {}

    constexpr MyBinaryMinMaxTreeBaseT(const MyBinaryMinMaxTreeBaseT& oth)
        : m_cmp(oth.m_cmp), m_defVal(oth.m_defVal), m_elemCnt(oth.m_elemCnt), m_arrElem(oth.m_arrElem)
        , m_levelCnt(oth.m_levelCnt), m_nodeCnt(oth.m_nodeCnt)
    {
        //
    }
    constexpr MyBinaryMinMaxTreeBaseT(MyBinaryMinMaxTreeBaseT&& oth) noexcept
        : m_cmp(std::move(oth.m_cmp)), m_defVal(std::move(oth.m_defVal)), m_elemCnt(oth.m_elemCnt), m_arrElem(std::move(oth.m_arrElem))
        , m_levelCnt(oth.m_levelCnt), m_nodeCnt(oth.m_nodeCnt)
    {
        //
    }

    constexpr void swap(MyBinaryMinMaxTreeBaseT& oth) noexcept {
        if (this != &oth)
            doSwap_();
    }
    constexpr MyBinaryMinMaxTreeBaseT& operator=(const MyBinaryMinMaxTreeBaseT& oth) {
        if (this != &oth) {
            MyBinaryMinMaxTreeBaseT tmpObj(oth);
            this->doSwap_(tmpObj);
        }
        return *this;
    }
    constexpr MyBinaryMinMaxTreeBaseT& operator=(MyBinaryMinMaxTreeBaseT&& oth) noexcept {
        if (this != &oth) {
            MyBinaryMinMaxTreeBaseT tmpObj(std::move(oth));
            this->doSwap_(tmpObj);
        }
        return *this;
    }

protected:
    constexpr void doSwap_(MyBinaryMinMaxTreeBaseT& oth) noexcept {
        //assert(this != &oth);
        std::swap(m_cmp, oth.m_cmp);
        std::swap(m_defVal, oth.m_defVal);
        std::swap(m_elemCnt, oth.m_elemCnt);
        std::swap(m_arrElem, oth.m_arrElem);
        std::swap(m_levelCnt, oth.m_levelCnt);
        std::swap(m_nodeCnt, oth.m_nodeCnt);
    }

public:
    void updateElem(index_t elemIdx, const value_t& newVal) {
        const value_t oldVal(std::move(m_arrElem[elemIdx]));
        m_arrElem[elemIdx] = newVal;
        onElemValUpdated(elemIdx, oldVal);
    }
    void updateElem(index_t elemIdx, value_t&& newVal) {
        const value_t oldVal(std::move(m_arrElem[elemIdx]));
        m_arrElem[elemIdx] = std::move(newVal);
        onElemValUpdated(elemIdx, oldVal);
    }
    
    virtual void onElemValUpdated(index_t elemIdx, const_val_call_arg_t oldVal) = 0;

public:
    MY_FORCEINLINE const_val_call_arg_t getDefValue() const { return m_defVal; }

    MY_FORCEINLINE bool isEmpty() const { return 0 == m_elemCnt; }
    MY_FORCEINLINE index_t getElemCount() const { return m_elemCnt; }
    MY_FORCEINLINE const container_t& getElemContainer() const { return m_arrElem; }

    MY_FORCEINLINE const_val_call_arg_t getElem(index_t elemIdx) const {
        //assert(0 <= elemIdx && elemIdx < m_elemCnt);
        return m_arrElem[elemIdx];
    }
    MY_FORCEINLINE const_pointer getElemPtr(index_t elemIdx) const {
        //assert(0 <= elemIdx && elemIdx < m_elemCnt);
        return &m_arrElem[elemIdx];
    }

protected:
    static MY_FORCEINLINE bool isLeftChild_(index_t i) { return (1 & i) != 0; }
    static MY_FORCEINLINE bool isRightChild_(index_t i) { return (1 & i) == 0; }
    static MY_FORCEINLINE index_t parentIndex_(index_t i) { return ((i - 1) >> 1); }
    static MY_FORCEINLINE index_t anotherChildIndex_(index_t i) { return (isLeftChild_(i) ? i+1 : i-1); }

    MY_FORCEINLINE index_t getLevelCount_() const { return m_levelCnt; }
    MY_FORCEINLINE index_t getNodeCount_() const { return m_nodeCnt; }

    // transform: element index <--> (fictive) node index.
    MY_FORCEINLINE index_t getNodeIndexOfElem_(index_t elemIdx) const { return m_nodeCnt + elemIdx; }
    MY_FORCEINLINE index_t getElemIndexByElemNodeIndex_(index_t elemNodeIdx) const { return elemNodeIdx - m_nodeCnt; }

    MY_FORCEINLINE bool isLess_(const_val_call_arg_t v1, const_val_call_arg_t v2) const { return m_cmp(v1, v2); }
    //
    MY_FORCEINLINE bool isEqual_(const_val_call_arg_t v1, const_val_call_arg_t v2) const { return (!m_cmp(v1, v2) && !m_cmp(v2, v1)); }
    MY_FORCEINLINE bool isNotEqual_(const_val_call_arg_t v1, const_val_call_arg_t v2) const { return (m_cmp(v1, v2) || m_cmp(v2, v1)); }
    //
    MY_FORCEINLINE const_val_call_arg_t minValOf_(const_val_call_arg_t v1, const_val_call_arg_t v2) const { return (m_cmp(v1, v2) ? v1 : v2); }
    MY_FORCEINLINE const_val_call_arg_t maxValOf_(const_val_call_arg_t v1, const_val_call_arg_t v2) const { return (m_cmp(v2, v1) ? v1 : v2); }
    //
    MY_FORCEINLINE const_pointer ptrMinValOf_(const_pointer pcv1, const_pointer pcv2) const { return (m_cmp(*pcv1, *pcv2) ? pcv1 : pcv2); }
    MY_FORCEINLINE const_pointer ptrMaxValOf_(const_pointer pcv1, const_pointer pcv2) const { return (m_cmp(*pcv2, *pcv1) ? pcv1 : pcv2); }

private:
    void prepareForNodeContainer_() {
        const index_t requiredCntOfLastNodeLevel = ((m_elemCnt+1) >> 1);
        m_levelCnt = C_TOP_UPDATE_LEVEL + 1;
        m_nodeCnt = C_TOP_UPDATE_LEVEL_INDEX_END;
        index_t cntNodeOfLastNodeLevel = (1 << C_TOP_UPDATE_LEVEL);
        while (cntNodeOfLastNodeLevel < requiredCntOfLastNodeLevel) {
            ++m_levelCnt;
            cntNodeOfLastNodeLevel <<= 1;
            m_nodeCnt += cntNodeOfLastNodeLevel;
        }
    }

private:
    comparator_t m_cmp;
    value_t m_defVal;
    //
    index_t m_elemCnt;
    container_t m_arrElem;
    // the max level value of the tree.
    //    the level of the element array is "m_levelCnt", which level
    //    is stored in the element array, actually NOT stored in the tree.
    index_t m_levelCnt;
    // the number of tree nodes.
    //    It is also the (fictive) node index in tree of the first element in "m_arrElem".
    index_t m_nodeCnt;
};
//
// declaration of MyBinaryMinMaxTreeT.
template<class ValT
    , class CmpT = std::less<ValT>
    , class CtnrT = std::vector<ValT>
    , class IdxT = typename CtnrT::difference_type
    , class TraitsT = MyBinaryMinMaxTree_ValTraitsT<ValT>
    , bool UseIdxInNodeB = false
    >
class MyBinaryMinMaxTreeT;
//
// Parital specialized template, used for (UseIdxInNodeB == false).
template<class ValT, class CmpT, class CtnrT, class IdxT, class TraitsT>
class MyBinaryMinMaxTreeT<ValT, CmpT, CtnrT, IdxT, TraitsT, false> final
    : public MyBinaryMinMaxTreeBaseT<ValT, CmpT, CtnrT, IdxT, TraitsT, false>
{
public:
    typedef MyBinaryMinMaxTreeBaseT<ValT, CmpT, CtnrT, IdxT, TraitsT, false>        super_t;

public:
    typedef typename super_t::value_t                       value_t;
    typedef typename super_t::comparator_t                  comparator_t;
    typedef typename super_t::container_t                   container_t;
    typedef typename super_t::index_t                       index_t;
    typedef typename super_t::traits_t                      traits_t;

    typedef typename super_t::val_call_arg_t                val_call_arg_t;
    typedef typename super_t::const_val_call_arg_t          const_val_call_arg_t;
    typedef typename super_t::res_value_data_t              res_value_data_t;
    typedef typename super_t::res_data_t                    res_data_t;
    typedef typename super_t::node_t                        node_t;
    typedef typename super_t::node_container_t              node_container_t;

public:
    static MY_FORCEINLINE constexpr const_val_call_arg_t limitValMin() noexcept { return traits_t::limitValMin(); }
    static MY_FORCEINLINE constexpr const_val_call_arg_t limitValMax() noexcept { return traits_t::limitValMax(); }
    
public:
    constexpr MyBinaryMinMaxTreeT()
        : super_t()
        , m_defNode(limitValMax(), limitValMin())
    {
        doConstructInitTreeByDefVal_();
    }
    constexpr MyBinaryMinMaxTreeT(const value_t& defVal, index_t elemCnt, const comparator_t& cmp = comparator_t())
        : super_t(defVal, elemCnt, cmp)
        , m_defNode(limitValMax(), limitValMin())
    {
        doConstructInitTreeByDefVal_();
    }
    constexpr MyBinaryMinMaxTreeT(value_t&& defVal, index_t elemCnt, const comparator_t& cmp = comparator_t())
        : super_t(std::move(defVal), elemCnt, cmp)
        , m_defNode(limitValMax(), limitValMin())
    {
        doConstructInitTreeByDefVal_();
    }
    constexpr MyBinaryMinMaxTreeT(const value_t& defVal, const container_t& arrElem, const comparator_t& cmp = comparator_t())
        : super_t(defVal, arrElem, cmp)
        , m_defNode(limitValMax(), limitValMin())
    {
        doConstructInitTreeBySpecVal_();
    }
    constexpr MyBinaryMinMaxTreeT(value_t&& defVal, container_t&& arrElem, const comparator_t& cmp = comparator_t())
        : super_t(std::move(defVal), std::move(arrElem), cmp)
        , m_defNode(limitValMax(), limitValMin())
    {
        doConstructInitTreeBySpecVal_();
    }
    virtual ~MyBinaryMinMaxTreeT() {}

    constexpr MyBinaryMinMaxTreeT(const MyBinaryMinMaxTreeT& oth)
        : super_t(oth)
        , m_defNode(oth.m_defNode), m_arrNode(oth.m_arrNode)
    {
        //
    }
    constexpr MyBinaryMinMaxTreeT(MyBinaryMinMaxTreeT&& oth) noexcept
        : super_t(std::move(oth))
        , m_defNode(std::move(oth.m_defNode)), m_arrNode(std::move(oth.m_arrNode))
    {
        //
    }

    constexpr void swap(MyBinaryMinMaxTreeT& oth) noexcept {
        if (this != &oth)
            this->doSwap_();
    }
    constexpr MyBinaryMinMaxTreeT& operator=(const MyBinaryMinMaxTreeT& oth) {
        if (this != &oth) {
            MyBinaryMinMaxTreeT tmpObj(oth);
            this->doSwap_(tmpObj);
        }
        return *this;
    }
    constexpr MyBinaryMinMaxTreeT& operator=(MyBinaryMinMaxTreeT&& oth) noexcept {
        if (this != &oth) {
            MyBinaryMinMaxTreeT tmpObj(std::move(oth));
            this->doSwap_(tmpObj);
        }
        return *this;
    }

private:
    constexpr void doSwap_(MyBinaryMinMaxTreeT& oth) noexcept {
        //assert(this != &oth);
        this->super_t::doSwap_(oth);
        std::swap(m_defNode, oth.m_defNode);
        std::swap(m_arrNode, oth.m_arrNode);
    }

public:
    virtual void onElemValUpdated(index_t elemIdx, const_val_call_arg_t oldVal) override final {
        const_val_call_arg_t newVal = this->getElem(elemIdx);
        const index_t nodeIdx = this->getNodeIndexOfElem_(elemIdx);
        bool isUpdateMinDone = false;
        bool isUpdateMaxDone = false;
        index_t i, anotherIdx, parentIdx;
        if (this->isLess_(newVal, oldVal)) {
            // update last node level
            i = nodeIdx;
            parentIdx = this->parentIndex_(i);
            if (this->isLess_(newVal, m_arrNode[parentIdx].xMin)) {
                m_arrNode[parentIdx].xMin = newVal;
            } else {
                isUpdateMinDone = true;
            }
            anotherIdx = this->anotherChildIndex_(i);
            anotherIdx = this->getElemIndexByElemNodeIndex_(anotherIdx);
            auto pcMaxVal = (anotherIdx < this->getElemCount() ? this->ptrMaxValOf_(&newVal, this->getElemPtr(anotherIdx)) : &newVal);
            if (this->isNotEqual_(*pcMaxVal, m_arrNode[parentIdx].xMax)) {
                m_arrNode[parentIdx].xMax = *pcMaxVal;
            } else {
                isUpdateMaxDone = true;
            }
            // update other node levels
            while ( (!isUpdateMinDone || !isUpdateMaxDone) && super_t::C_TOP_UPDATE_LEVEL_INDEX_END <= parentIdx ) {
                i = parentIdx;
                parentIdx = this->parentIndex_(i);
                // update TreeNode.xMin
                if (!isUpdateMinDone) {
                    if (this->isLess_(newVal, m_arrNode[parentIdx].xMin)) {
                        m_arrNode[parentIdx].xMin = newVal;
                    } else {
                        isUpdateMinDone = true;
                    }
                }
                // update TreeNode.xMax
                if (!isUpdateMaxDone) {
                    anotherIdx = this->anotherChildIndex_(i);
                    pcMaxVal = this->ptrMaxValOf_(pcMaxVal, &m_arrNode[anotherIdx].xMax);
                    if (this->isNotEqual_(*pcMaxVal, m_arrNode[parentIdx].xMax)) {
                        m_arrNode[parentIdx].xMax = *pcMaxVal;
                    } else {
                        isUpdateMaxDone = true;
                    }
                }
            }
        } else if (this->isLess_(oldVal, newVal)) {
            // update last node level
            i = nodeIdx;
            parentIdx = this->parentIndex_(i);
            if (this->isLess_(m_arrNode[parentIdx].xMax, newVal)) {
                m_arrNode[parentIdx].xMax = newVal;
            } else {
                isUpdateMaxDone = true;
            }
            anotherIdx = this->anotherChildIndex_(i);
            anotherIdx = this->getElemIndexByElemNodeIndex_(anotherIdx);
            auto pcMinVal = (anotherIdx < this->getElemCount() ? this->ptrMinValOf_(&newVal, this->getElemPtr(anotherIdx)) : &newVal);
            if (this->isNotEqual_(*pcMinVal, m_arrNode[parentIdx].xMin)) {
                m_arrNode[parentIdx].xMin = *pcMinVal;
            } else {
                isUpdateMinDone = true;
            }
            // update other node levels
            while ( (!isUpdateMinDone || !isUpdateMaxDone) && super_t::C_TOP_UPDATE_LEVEL_INDEX_END <= parentIdx ) {
                i = parentIdx;
                parentIdx = this->parentIndex_(i);
                // update TreeNode.xMin
                if (!isUpdateMinDone) {
                    anotherIdx = this->anotherChildIndex_(i);
                    pcMinVal = this->ptrMinValOf_(pcMinVal, &m_arrNode[anotherIdx].xMin);
                    if (this->isNotEqual_(*pcMinVal, m_arrNode[parentIdx].xMin)) {
                        m_arrNode[parentIdx].xMin = *pcMinVal;
                    } else {
                        isUpdateMinDone = true;
                    }
                }
                // update TreeNode.xMax
                if (!isUpdateMaxDone) {
                    if (this->isLess_(m_arrNode[parentIdx].xMax, newVal)) {
                        m_arrNode[parentIdx].xMax = newVal;
                    } else {
                        isUpdateMaxDone = true;
                    }
                }
            }
        } else {// (==)
            // do nothing.
        }
    }

    void findMinMax(res_data_t& res, index_t elemIdxBegin, index_t elemIdxEnd) const {
        //assert(0 <= elemIdxBegin && elemIdxBegin < elemIdxEnd && elemIdxEnd <= m_elemCnt);
        const value_t* pcMinVal = this->getElemPtr(elemIdxBegin);
        const value_t* pcMaxVal = pcMinVal;
        index_t i = elemIdxBegin + 1;
        index_t j = elemIdxEnd - 1;
        index_t cntTmp = j - i + 1;
        const value_t* pcTmp;
        index_t t;
        if (cntTmp <= super_t::C_CNT_MAX_TO_DIRECT_CMP) {
            for (t = i; t <= j; ++t) {
                pcTmp = this->getElemPtr(t);
                if (this->isLess_(*pcTmp, *pcMinVal)) {
                    pcMinVal = pcTmp;
                } else if (this->isLess_(*pcMaxVal, *pcTmp)) {
                    pcMaxVal = pcTmp;
                }
            }
            res.xMin = *pcMinVal;
            res.xMax = *pcMaxVal;
            return;
        }
        //
        index_t tmpIdx = this->getNodeIndexOfElem_(i - 1);
        if (this->isLeftChild_(tmpIdx)) {
            i = this->parentIndex_(tmpIdx);
        } else {
            i = this->parentIndex_(tmpIdx) + 1;
        }
        tmpIdx = this->getNodeIndexOfElem_(j);
        if (this->isRightChild_(tmpIdx)) {
            j = this->parentIndex_(tmpIdx);
        } else {
            pcTmp = this->getElemPtr(j);
            if (this->isLess_(*pcTmp, *pcMinVal)) {
                pcMinVal = pcTmp;
            } else if (this->isLess_(*pcMaxVal, *pcTmp)) {
                pcMaxVal = pcTmp;
            }
            j = this->parentIndex_(tmpIdx) - 1;
        }
        cntTmp = j - i + 1;
        const node_t* pcNode;
        while (super_t::C_CNT_MAX_TO_DIRECT_CMP < cntTmp) {
            if (this->isLeftChild_(i)) {
                i = this->parentIndex_(i);
            } else {
                pcNode = &m_arrNode[i];
                pcMinVal = this->ptrMinValOf_(pcMinVal, &pcNode->xMin);
                pcMaxVal = this->ptrMaxValOf_(pcMaxVal, &pcNode->xMax);
                i = this->parentIndex_(i) + 1;
            }

            if (this->isRightChild_(j)) {
                j = this->parentIndex_(j);
            } else {
                pcNode = &m_arrNode[j];
                pcMinVal = this->ptrMinValOf_(pcMinVal, &pcNode->xMin);
                pcMaxVal = this->ptrMaxValOf_(pcMaxVal, &pcNode->xMax);
                j = this->parentIndex_(j) - 1;
            }

            cntTmp = j - i + 1;
        }
        if (0 < cntTmp) {
            for (t = i; t <= j; ++t) {
                pcNode = &m_arrNode[t];
                pcMinVal = this->ptrMinValOf_(pcMinVal, &pcNode->xMin);
                pcMaxVal = this->ptrMaxValOf_(pcMaxVal, &pcNode->xMax);
            }
        }
        res.xMin = *pcMinVal;
        res.xMax = *pcMaxVal;
    }

private:
    void doConstructInitTreeByDefVal_() {
        if (this->isEmpty())
            return;
        index_t currEnd = this->getNodeCount_();
        m_arrNode.resize(currEnd);
        index_t i = this->getNodeIndexOfElem_(0);
        index_t j = this->getNodeIndexOfElem_(this->getElemCount() - 1);
        index_t t;
        while (super_t::C_TOP_UPDATE_LEVEL_INDEX_END <= i) {
            currEnd = i;
            i = this->parentIndex_(i);
            j = this->parentIndex_(j);
            //
            for (t = currEnd - 1; j < t; --t) {
                m_arrNode[t] = m_defNode;
            }
            //assert(t == j);
            for ( ; i <= t; --t) {
                m_arrNode[t] = node_t(this->getDefValue());
            }
        }
    }
    void doConstructInitTreeBySpecVal_() {
        if (this->isEmpty())
            return;
        index_t currEnd = this->getNodeCount_();
        m_arrNode.resize(currEnd);
        // the last node level
        index_t i = this->parentIndex_(this->getNodeIndexOfElem_(0));
        index_t elemIdx = this->getElemCount() - 1;
        index_t nodeIdx = this->getNodeIndexOfElem_(elemIdx);
        index_t j = this->parentIndex_(nodeIdx);
        index_t t;
        for (t = currEnd - 1; j < t; --t) {
            m_arrNode[t] = m_defNode;
        }
        //assert(t == j);
        if (this->isLeftChild_(nodeIdx)) {
            m_arrNode[t] = node_t(this->getElem(elemIdx));
            --t;
            --elemIdx;
        }
        for ( ; i <= t; --t, elemIdx-=2) {
            if (this->isLess_(this->getElem(elemIdx-1), this->getElem(elemIdx))) {
                m_arrNode[t] = node_t(this->getElem(elemIdx-1), this->getElem(elemIdx));
            } else {
                m_arrNode[t] = node_t(this->getElem(elemIdx), this->getElem(elemIdx-1));
            }
        }
        // other node levels
        while (super_t::C_TOP_UPDATE_LEVEL_INDEX_END <= i) {
            currEnd = i;
            i = this->parentIndex_(i);
            j = this->parentIndex_(j);
            //
            for (t = currEnd - 1; j < t; --t) {
                m_arrNode[t] = m_defNode;
            }
            //assert(t == j);
            nodeIdx = (t << 1) + 1;
            for ( ; i <= t; --t, nodeIdx-=2) {
                m_arrNode[t] = node_t(
                    this->minValOf_(m_arrNode[nodeIdx].xMin, m_arrNode[nodeIdx+1].xMin)
                    , this->maxValOf_(m_arrNode[nodeIdx].xMax, m_arrNode[nodeIdx+1].xMax)
                );
            }
        }
    }

private:
    node_t m_defNode;
    node_container_t m_arrNode;
};
//
// Parital specialized template, used for (UseIdxInNodeB == true).
template<class ValT, class CmpT, class CtnrT, class IdxT, class TraitsT>
class MyBinaryMinMaxTreeT<ValT, CmpT, CtnrT, IdxT, TraitsT, true> final
    : public MyBinaryMinMaxTreeBaseT<ValT, CmpT, CtnrT, IdxT, TraitsT, true>
{
public:
    typedef MyBinaryMinMaxTreeBaseT<ValT, CmpT, CtnrT, IdxT, TraitsT, true>        super_t;

public:
    typedef typename super_t::value_t                       value_t;
    typedef typename super_t::comparator_t                  comparator_t;
    typedef typename super_t::container_t                   container_t;
    typedef typename super_t::index_t                       index_t;
    typedef typename super_t::traits_t                      traits_t;

    typedef typename super_t::val_call_arg_t                val_call_arg_t;
    typedef typename super_t::const_val_call_arg_t          const_val_call_arg_t;
    typedef typename super_t::res_value_data_t              res_value_data_t;
    typedef typename super_t::res_data_t                    res_data_t;
    typedef typename super_t::node_t                        node_t;
    typedef typename super_t::node_container_t              node_container_t;

public:
    constexpr MyBinaryMinMaxTreeT()
        : super_t()
        , m_defNode(super_t::C_INDEX_NPOS)
    {
        doConstructInitTreeByDefVal_();
    }
    constexpr MyBinaryMinMaxTreeT(const value_t& defVal, index_t elemCnt, const comparator_t& cmp = comparator_t())
        : super_t(defVal, elemCnt, cmp)
        , m_defNode(super_t::C_INDEX_NPOS)
    {
        doConstructInitTreeByDefVal_();
    }
    constexpr MyBinaryMinMaxTreeT(value_t&& defVal, index_t elemCnt, const comparator_t& cmp = comparator_t())
        : super_t(std::move(defVal), elemCnt, cmp)
        , m_defNode(super_t::C_INDEX_NPOS)
    {
        doConstructInitTreeByDefVal_();
    }
    constexpr MyBinaryMinMaxTreeT(const value_t& defVal, const container_t& arrElem, const comparator_t& cmp = comparator_t())
        : super_t(defVal, arrElem, cmp)
        , m_defNode(super_t::C_INDEX_NPOS)
    {
        doConstructInitTreeBySpecVal_();
    }
    constexpr MyBinaryMinMaxTreeT(value_t&& defVal, container_t&& arrElem, const comparator_t& cmp = comparator_t())
        : super_t(std::move(defVal), std::move(arrElem), cmp)
        , m_defNode(super_t::C_INDEX_NPOS)
    {
        doConstructInitTreeBySpecVal_();
    }
    virtual ~MyBinaryMinMaxTreeT() {}

    constexpr MyBinaryMinMaxTreeT(const MyBinaryMinMaxTreeT& oth)
        : super_t(oth)
        , m_defNode(oth.m_defNode), m_arrNode(oth.m_arrNode)
    {
        //
    }
    constexpr MyBinaryMinMaxTreeT(MyBinaryMinMaxTreeT&& oth) noexcept
        : super_t(std::move(oth))
        , m_defNode(std::move(oth.m_defNode)), m_arrNode(std::move(oth.m_arrNode))
    {
        //
    }

    constexpr void swap(MyBinaryMinMaxTreeT& oth) noexcept {
        if (this != &oth)
            this->doSwap_();
    }
    constexpr MyBinaryMinMaxTreeT& operator=(const MyBinaryMinMaxTreeT& oth) {
        if (this != &oth) {
            MyBinaryMinMaxTreeT tmpObj(oth);
            this->doSwap_(tmpObj);
        }
        return *this;
    }
    constexpr MyBinaryMinMaxTreeT& operator=(MyBinaryMinMaxTreeT&& oth) noexcept {
        if (this != &oth) {
            MyBinaryMinMaxTreeT tmpObj(std::move(oth));
            this->doSwap_(tmpObj);
        }
        return *this;
    }

private:
    constexpr void doSwap_(MyBinaryMinMaxTreeT& oth) noexcept {
        //assert(this != &oth);
        this->super_t::doSwap_(oth);
        std::swap(m_defNode, oth.m_defNode);
        std::swap(m_arrNode, oth.m_arrNode);
    }

public:
    virtual void onElemValUpdated(index_t elemIdx, const_val_call_arg_t oldVal) override final {
        const_val_call_arg_t newVal = this->getElem(elemIdx);
        const index_t nodeIdx = this->getNodeIndexOfElem_(elemIdx);
        bool isUpdateMinDone = false;
        bool isUpdateMaxDone = false;
        index_t i, anotherIdx, parentIdx;
        bool hasFoundOldValAlternative;
        if (this->isLess_(newVal, oldVal)) {
            // update last node level
            i = nodeIdx;
            parentIdx = this->parentIndex_(i);
            if (m_arrNode[parentIdx].xMin != elemIdx) {
                if (this->isLess_(newVal, this->getElem(m_arrNode[parentIdx].xMin))) {
                    m_arrNode[parentIdx].xMin = elemIdx;
                } else {
                    isUpdateMinDone = true;
                }
            }
            index_t idxMaxVal = elemIdx;
            hasFoundOldValAlternative = false;
            if (m_arrNode[parentIdx].xMax == elemIdx) {
                anotherIdx = this->anotherChildIndex_(i);
                anotherIdx = this->getElemIndexByElemNodeIndex_(anotherIdx);
                if (anotherIdx < this->getElemCount()) {
                    if (this->isLess_(this->getElem(anotherIdx), oldVal)) {
                        idxMaxVal = idxMaxValOf_(idxMaxVal, anotherIdx);
                    } else {
                        //assert(this->isEqual_(this->getElem(anotherIdx), oldVal));
                        idxMaxVal = anotherIdx;
                        hasFoundOldValAlternative = true;
                    }
                    m_arrNode[parentIdx].xMax = idxMaxVal;
                }
            } else {
                isUpdateMaxDone = true;
            }
            // update other node levels
            while ( (!isUpdateMinDone || !isUpdateMaxDone) && super_t::C_TOP_UPDATE_LEVEL_INDEX_END <= parentIdx ) {
                i = parentIdx;
                parentIdx = this->parentIndex_(i);
                // update TreeNode.xMin
                if (!isUpdateMinDone) {
                    if (m_arrNode[parentIdx].xMin != elemIdx) {
                        if (this->isLess_(newVal, this->getElem(m_arrNode[parentIdx].xMin))) {
                            m_arrNode[parentIdx].xMin = elemIdx;
                        } else {
                            isUpdateMinDone = true;
                        }
                    }
                }
                // update TreeNode.xMax
                if (!isUpdateMaxDone) {
                    if (m_arrNode[parentIdx].xMax == elemIdx) {
                        if (!hasFoundOldValAlternative) {
                            anotherIdx = this->anotherChildIndex_(i);
                            anotherIdx = m_arrNode[anotherIdx].xMax;
                            if (idxIsNotNpos_(anotherIdx)) {
                                if (this->isLess_(this->getElem(anotherIdx), oldVal)) {
                                    idxMaxVal = idxMaxValOf_(idxMaxVal, anotherIdx);
                                } else {
                                    //assert(this->isEqual_(this->getElem(anotherIdx), oldVal));
                                    idxMaxVal = anotherIdx;
                                    hasFoundOldValAlternative = true;
                                }
                            }
                        }
                        m_arrNode[parentIdx].xMax = idxMaxVal;
                    } else {
                        isUpdateMaxDone = true;
                    }
                }
            }
        } else if (this->isLess_(oldVal, newVal)) {
            // update last node level
            i = nodeIdx;
            parentIdx = this->parentIndex_(i);
            if (m_arrNode[parentIdx].xMax != elemIdx) {
                if (this->isLess_(this->getElem(m_arrNode[parentIdx].xMax), newVal)) {
                    m_arrNode[parentIdx].xMax = elemIdx;
                } else {
                    isUpdateMaxDone = true;
                }
            }
            index_t idxMinVal = elemIdx;
            hasFoundOldValAlternative = false;
            if (m_arrNode[parentIdx].xMin == elemIdx) {
                anotherIdx = this->anotherChildIndex_(i);
                anotherIdx = this->getElemIndexByElemNodeIndex_(anotherIdx);
                if (anotherIdx < this->getElemCount()) {
                    if (this->isLess_(oldVal, this->getElem(anotherIdx))) {
                        idxMinVal = idxMinValOf_(idxMinVal, anotherIdx);
                    } else {
                        //assert(this->isEqual_(oldVal, this->getElem(anotherIdx)));
                        idxMinVal = anotherIdx;
                        hasFoundOldValAlternative = true;
                    }
                    m_arrNode[parentIdx].xMin = idxMinVal;
                }
            } else {
                isUpdateMinDone = true;
            }
            // update other node levels
            while ( (!isUpdateMinDone || !isUpdateMaxDone) && super_t::C_TOP_UPDATE_LEVEL_INDEX_END <= parentIdx ) {
                i = parentIdx;
                parentIdx = this->parentIndex_(i);
                // update TreeNode.xMin
                if (!isUpdateMinDone) {
                    if (m_arrNode[parentIdx].xMin == elemIdx) {
                        if (!hasFoundOldValAlternative) {
                            anotherIdx = this->anotherChildIndex_(i);
                            anotherIdx = m_arrNode[anotherIdx].xMin;
                            if (idxIsNotNpos_(anotherIdx)) {
                                if (this->isLess_(oldVal, this->getElem(anotherIdx))) {
                                    idxMinVal = idxMinValOf_(idxMinVal, anotherIdx);
                                } else {
                                    //assert(this->isEqual_(oldVal, this->getElem(anotherIdx)));
                                    idxMinVal = anotherIdx;
                                    hasFoundOldValAlternative = true;
                                }
                            }
                        }
                        m_arrNode[parentIdx].xMin = idxMinVal;
                    } else {
                        isUpdateMinDone = true;
                    }
                }
                // update TreeNode.xMax
                if (!isUpdateMaxDone) {
                    if (m_arrNode[parentIdx].xMax != elemIdx) {
                        if (this->isLess_(this->getElem(m_arrNode[parentIdx].xMax), newVal)) {
                            m_arrNode[parentIdx].xMax = elemIdx;
                        } else {
                            isUpdateMaxDone = true;
                        }
                    }
                }
            }
        } else {// (==)
            // do nothing.
        }
    }
    
    void findMinMax(res_data_t& res, index_t elemIdxBegin, index_t elemIdxEnd) const {
        //assert(0 <= elemIdxBegin && elemIdxBegin < elemIdxEnd && elemIdxEnd <= m_elemCnt);
        res.xMin = res.xMax = elemIdxBegin;
        index_t i = elemIdxBegin + 1;
        index_t j = elemIdxEnd - 1;
        index_t cntTmp = j - i + 1;
        index_t t;
        if (cntTmp <= super_t::C_CNT_MAX_TO_DIRECT_CMP) {
            for (t = i; t <= j; ++t) {
                if (this->isLess_(this->getElem(t), this->getElem(res.xMin))) {
                    res.xMin = t;
                } else if (this->isLess_(this->getElem(res.xMax), this->getElem(t))) {
                    res.xMax = t;
                }
            }
            return;
        }
        
        index_t tmpIdx = this->getNodeIndexOfElem_(i - 1);
        if (this->isLeftChild_(tmpIdx)) {
            i = this->parentIndex_(tmpIdx);
        } else {
            i = this->parentIndex_(tmpIdx) + 1;
        }
        tmpIdx = this->getNodeIndexOfElem_(j);
        if (this->isRightChild_(tmpIdx)) {
            j = this->parentIndex_(tmpIdx);
        } else {
            if (this->isLess_(this->getElem(j), this->getElem(res.xMin))) {
                res.xMin = j;
            } else if (this->isLess_(this->getElem(res.xMax), this->getElem(j))) {
                res.xMax = j;
            }
            j = this->parentIndex_(tmpIdx) - 1;
        }
        cntTmp = j - i + 1;
        const node_t* pcNode;
        while (super_t::C_CNT_MAX_TO_DIRECT_CMP < cntTmp) {
            if (this->isLeftChild_(i)) {
                i = this->parentIndex_(i);
            } else {
                pcNode = &m_arrNode[i];
                res.xMin = idxMinValOf_(res.xMin, pcNode->xMin);
                res.xMax = idxMaxValOf_(res.xMax, pcNode->xMax);
                i = this->parentIndex_(i) + 1;
            }

            if (this->isRightChild_(j)) {
                j = this->parentIndex_(j);
            } else {
                pcNode = &m_arrNode[j];
                res.xMin = idxMinValOf_(res.xMin, pcNode->xMin);
                res.xMax = idxMaxValOf_(res.xMax, pcNode->xMax);
                j = this->parentIndex_(j) - 1;
            }

            cntTmp = j - i + 1;
        }
        if (0 < cntTmp) {
            for (t = i; t <= j; ++t) {
                pcNode = &m_arrNode[t];
                res.xMin = idxMinValOf_(res.xMin, pcNode->xMin);
                res.xMax = idxMaxValOf_(res.xMax, pcNode->xMax);
            }
        }
    }

private:
    static MY_FORCEINLINE bool idxIsNpos_(index_t idx) { return (super_t::C_INDEX_NPOS == idx); }
    static MY_FORCEINLINE bool idxIsNotNpos_(index_t idx) { return (super_t::C_INDEX_NPOS != idx); }
    
    inline index_t withNpos_idxMinValOf_(index_t idx1, index_t idx2) const {
        return ( idxIsNotNpos_(idx1)
                    ? (idxIsNotNpos_(idx2) ? (this->isLess_(this->getElem(idx1), this->getElem(idx2)) ? idx1 : idx2) : idx1)
                    : idx2
            );
    }
    inline index_t withNpos_idxMaxValOf_(index_t idx1, index_t idx2) const {
        return ( idxIsNotNpos_(idx1)
                    ? (idxIsNotNpos_(idx2) ? (this->isLess_(this->getElem(idx2), this->getElem(idx1)) ? idx1 : idx2) : idx1)
                    : idx2
            );
    }
    //
    inline index_t idxMinValOf_(index_t idx1, index_t idx2) const { return (this->isLess_(this->getElem(idx1), this->getElem(idx2)) ? idx1 : idx2); }
    inline index_t idxMaxValOf_(index_t idx1, index_t idx2) const { return (this->isLess_(this->getElem(idx2), this->getElem(idx1)) ? idx1 : idx2); }

    void doConstructInitTreeByDefVal_() {
        if (this->isEmpty())
            return;
        index_t currEnd = this->getNodeCount_();
        m_arrNode.resize(currEnd);
        // the last node level
        index_t i = this->parentIndex_(this->getNodeIndexOfElem_(0));
        index_t elemIdx = this->getElemCount() - 1;
        index_t nodeIdx = this->getNodeIndexOfElem_(elemIdx);
        index_t j = this->parentIndex_(nodeIdx);
        index_t t;
        for (t = currEnd - 1; j < t; --t) {
            m_arrNode[t] = m_defNode;
        }
        //assert(t == j);
        if (this->isLeftChild_(nodeIdx)) {
            m_arrNode[t] = node_t(elemIdx);
            --t;
            --elemIdx;
        }
        for ( ; i <= t; --t, elemIdx-=2) {
            m_arrNode[t] = node_t(elemIdx-1, elemIdx);
        }
        // other node levels
        index_t prevJ;
        while (super_t::C_TOP_UPDATE_LEVEL_INDEX_END <= i) {
            currEnd = i;
            i = this->parentIndex_(i);
            prevJ = j;
            j = this->parentIndex_(j);
            //
            for (t = currEnd - 1; j < t; --t) {
                m_arrNode[t] = m_defNode;
            }
            //assert(t == j);
            nodeIdx = (t << 1) + 1;
            if (prevJ == nodeIdx) {
                // the previous j is left child.
                m_arrNode[t] = m_arrNode[nodeIdx];
                --t;
                nodeIdx -= 2;
            }
            for ( ; i <= t; --t, nodeIdx-=2) {
                m_arrNode[t] = node_t(m_arrNode[nodeIdx].xMin, m_arrNode[nodeIdx+1].xMax);
            }
        }
    }
    void doConstructInitTreeBySpecVal_() {
        if (this->isEmpty())
            return;
        index_t currEnd = this->getNodeCount_();
        m_arrNode.resize(currEnd);
        // the last node level
        index_t i = this->parentIndex_(this->getNodeIndexOfElem_(0));
        index_t elemIdx = this->getElemCount() - 1;
        index_t nodeIdx = this->getNodeIndexOfElem_(elemIdx);
        index_t j = this->parentIndex_(nodeIdx);
        index_t t;
        for (t = currEnd - 1; j < t; --t) {
            m_arrNode[t] = m_defNode;
        }
        //assert(t == j);
        if (this->isLeftChild_(nodeIdx)) {
            m_arrNode[t] = node_t(elemIdx);
            --t;
            --elemIdx;
        }
        for ( ; i <= t; --t, elemIdx-=2) {
            if (this->isLess_(this->getElem(elemIdx-1), this->getElem(elemIdx))) {
                m_arrNode[t] = node_t(elemIdx-1, elemIdx);
            } else {
                m_arrNode[t] = node_t(elemIdx, elemIdx-1);
            }
        }
        // other node levels
        index_t prevJ;
        while (super_t::C_TOP_UPDATE_LEVEL_INDEX_END <= i) {
            currEnd = i;
            i = this->parentIndex_(i);
            prevJ = j;
            j = this->parentIndex_(j);
            //
            for (t = currEnd - 1; j < t; --t) {
                m_arrNode[t] = m_defNode;
            }
            //assert(t == j);
            nodeIdx = (t << 1) + 1;
            if (prevJ == nodeIdx) {
                // the previous j is left child.
                m_arrNode[t] = m_arrNode[nodeIdx];
                --t;
                nodeIdx -= 2;
            }
            for ( ; i <= t; --t, nodeIdx-=2) {
                m_arrNode[t] = node_t(
                    idxMinValOf_(m_arrNode[nodeIdx].xMin, m_arrNode[nodeIdx+1].xMin)
                    , idxMaxValOf_(m_arrNode[nodeIdx].xMax, m_arrNode[nodeIdx+1].xMax)
                );
            }
        }
    }

private:
    node_t m_defNode;
    node_container_t m_arrNode;
};

//////////////////////////////////////////////////////////////
typedef MyBinaryMinMaxTreeT< int, std::less<int>, std::vector<int>, int >                                                   MyBinMinMax_ValTree;
typedef MyBinaryMinMaxTreeT< int, std::less<int>, std::vector<int>, int, MyBinaryMinMaxTree_ValTraitsT<int>, true >         MyBinMinMax_IdxTree;

void myTest_testIndexNpos() {
    std::cout << "MyBinMinMax_IdxTree::C_INDEX_NPOS = " << MyBinMinMax_IdxTree::C_INDEX_NPOS << "\n";
    std::cout << "MAX, size_t: " << std::numeric_limits<std::size_t>::max()
                << ", uint32_t: " << std::numeric_limits<std::uint32_t>::max()
                << ", uint64_t: " << std::numeric_limits<std::uint64_t>::max()
                << "\n";
    std::size_t szNpos1 = (std::size_t)-1;
    std::size_t szNpos2 = (std::size_t)-1LL;
    std::uint32_t u32Npos = (std::uint32_t)-1LL;
    std::int64_t i64Npos = (std::int64_t)-1;
    std::uint64_t u64Npos = (std::uint64_t)-1;
    std::cout << "szNpos1 = " << szNpos1 << ", szNpos2 = " << szNpos2
                << ", u32Npos = " << u32Npos
                << ", i64Npos = " << i64Npos << ", u64Npos = " << u64Npos
                << "\n";
}

std::vector<int> myTest_generateRandomData(int iCnt, int iMin, int iMax) {
    std::vector<int> vNums(iCnt);
    const int iRange = (iMax - iMin + 1);
    std::srand( (unsigned)(iRange / 3 + iMax) );
    for (int i = 0; i < iCnt; ++i) {
        vNums[i] = (std::rand() % iRange) + iMin;
    }
    return std::move(vNums);
}

template<class TreeT>
TreeT myTest_createTree_withRandomData(int iCnt, int iDef, int iMin, int iMax)
{
    std::vector<int> vNums( myTest_generateRandomData(iCnt, iMin, iMax) );
    return std::move( TreeT(iDef, std::move(vNums)) );
}

template<class CmpT, class CtnrT, class IdxT, class TraitsT, bool UseIdxInNodeB>
void myTest_updateTree_byNums(MyBinaryMinMaxTreeT<int, CmpT, CtnrT, IdxT, TraitsT, UseIdxInNodeB>& tTree, const CtnrT& vNums)
{
    typedef MyBinaryMinMaxTreeT<int, CmpT, CtnrT, IdxT, TraitsT, UseIdxInNodeB> TheTreeType;

    IdxT iCntToUp = tTree.getElemCount();
    iCntToUp = std::min(iCntToUp, static_cast<IdxT>(vNums.size()));
    for (IdxT i = 0; i < iCntToUp; ++i) {
        tTree.updateElem(i, vNums[i]);
    }
}

//////////////////////////////////////////////////////////////



class Solution {
public:
    vector<bool> checkArithmeticSubarrays(vector<int>& nums, vector<int>& l, vector<int>& r) {
        return std::move(checkArithmeticSubarrays_v1(nums, l, r)); // [15, 21] ms, 21.32 MB.
    }

    static constexpr const int C_VALUE_MIN = -100000;
    static constexpr const int C_VALUE_MAX = 100000;

private:

    // method 1.
    //
#define MY_V1_USE_IDX_TREE  0
#if MY_V1_USE_IDX_TREE
    typedef MyBinMinMax_IdxTree                 V1_BinMinMaxTree;
#else
    typedef MyBinMinMax_ValTree                 V1_BinMinMaxTree;
#endif
    //
    vector<bool> checkArithmeticSubarrays_v1(vector<int>& nums, const vector<int>& l, const vector<int>& r) {
        {
        #if 0
            myTest_testIndexNpos();
        #endif
        }
        const int n = static_cast<int>(nums.size());
        const int m = static_cast<int>(l.size());
        if (n < 3)
            return std::move(std::vector<bool>(m, true));
        
        std::vector<int> prefixSum(n+1);
        for (int i = 0; i < n; ++i) {
            prefixSum[i+1] = prefixSum[i] + nums[i];
        }

        // Performance Test Results:
        //    findMinMaxVal_(): [15, 21] ms.
        //    MyBinaryMinMaxTreeT (UseIdxInNodeB=false): [15, 30] ms.
        //    MyBinaryMinMaxTreeT (UseIdxInNodeB=true): [20, 29] ms.
        //
    #if 0 // Use Function:
        const auto& rcVals = nums;
    #else // Use My Tree:
        V1_BinMinMaxTree binMinMaxTree(0, std::move(nums));
        //V1_BinMinMaxTree binMinMaxTree(123, n);
        //V1_BinMinMaxTree binMinMaxTree = myTest_createTree_withRandomData<V1_BinMinMaxTree>(n, 123, C_VALUE_MIN, C_VALUE_MAX);
        {
        #if 0 // Test update tree
            myTest_updateTree_byNums(binMinMaxTree, myTest_generateRandomData(n, C_VALUE_MIN, C_VALUE_MAX) );
            //
            myTest_updateTree_byNums(binMinMaxTree, nums);
        #endif
        }
        const auto& rcVals = binMinMaxTree.getElemContainer();
    #endif // End Usage Selection.
        //
        std::vector<bool> res;
        res.resize(m);
        std::vector<bool> vTmpBool;
        vTmpBool.reserve(n);
        //MyMinMaxData mmDat;
        V1_BinMinMaxTree::res_data_t mmDat;
        for (int i = 0; i < m; ++i) {
            const int low = l[i];
            const int high = r[i];
            const int cntSep = high - low;
            //assert(0 < cntSep);
            if (1 < cntSep) {
                const int cntVal = cntSep + 1;
                //findMinMaxVal_(mmDat, &rcVals[low], cntVal);
                binMinMaxTree.findMinMax(mmDat, low, high+1);
            #if MY_V1_USE_IDX_TREE
                mmDat.xMin = rcVals[mmDat.xMin];
                mmDat.xMax = rcVals[mmDat.xMax];
            #endif // MY_V1_USE_IDX_TREE
                //
                const int vRangeLen = mmDat.xMax - mmDat.xMin;
                bool bIsOk = (0 == vRangeLen);
                if (!bIsOk && cntSep <= vRangeLen) {
                    const auto dv = std::div(vRangeLen, cntSep);
                    if (0 == dv.rem) {
                        const int tmpSum = prefixSum[high+1] - prefixSum[low];
                        const int requiredSum = ( ((mmDat.xMin + mmDat.xMax) * cntVal) >> 1 );
                        if (tmpSum == requiredSum) {
                            vTmpBool.clear();
                            vTmpBool.resize(cntVal);
                            bIsOk = true;
                            for (int t = low; t <= high; ++t) {
                                int v = rcVals[t];
                                v -= mmDat.xMin;
                                auto tmpDv = std::div(v, dv.quot);
                                if (0 != tmpDv.rem || vTmpBool[tmpDv.quot]) {
                                    bIsOk = false;
                                    break;
                                } else {
                                    vTmpBool[tmpDv.quot] = true;
                                }
                            }
                        }
                    }
                }
                res[i] = bIsOk;
            } else {
                res[i] = true;
            }
        }
        return std::move(res);
    }

    static void findMinMaxVal_(MyMinMaxData& res, const int* arrVal, int cntVal) {
        res.xMin = res.xMax = arrVal[0];
        for (int i = 1; i < cntVal; ++i) {
            const int v = arrVal[i];
            if (v < res.xMin) {
                res.xMin = v;
            } else if (res.xMax < v) {
                res.xMax = v;
            }
        }
    }
};



#pragma GCC optimize("Ofast","inline","fast-math","unroll-loops","no-stack-protector")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native","f16c")
static const auto fast = []() {ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();

// recursion  steps

step 1 -> Read the questions carefully.

step 2-> Identify the subproblem of the major problem and if and the process , method , funtion , block of code that is help to solve the subproblem and eventually  bigger problem.

step 3-> confirm that is as recusrive solution for the given recursive problem

step 4-> Identify the recursive equation

step 5->Identify the parameters that your are passing through the recursive function and also the way you are passing them
to decide on a return value of the function  
a-> if solution require printing  return typr value void
b-> if  a value needs to be returned then return data type according to the problem also make sure you are using the previous subsoltuion by caching the data (soltuion of the sub prob;em) and combining them efficiently to calculate a bigger Solution

step 7 -> chcek if subsolution can be combined in a better fashion to give a decrease time comlexity and check for and extra data structure or memory variables  whose use can be avoidant to make the solution more memory efficiently



Input: [1,2,3,4,[5,6,[7,[8]]]] -> [1 , 2 , 3 , 4 [[[]]]] -> solve this problem using stack 
Output: [1,2,3,4,5,6,7,8] 

